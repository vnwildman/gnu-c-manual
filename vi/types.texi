
@c This is part of The GNU C Reference Manual
@c Copyright (C) 2007-2009 Free Software Foundation, Inc.
@c See the file gnu-c-manual.texi for copying conditions.
@c author:tjr@gnu.org et al

@node Kiểu dữ liệu
@chapter Kiểu dữ liệu
@cindex kiểu dữ liệu
@cindex kiểu

@menu
* Kiểu cơ bản::
* Kiểu liệt kê::
* Tập hợp::
* Cấu trúc::
* Mảng::
* Con trỏ::
* Kiểu Khuyết thiếu::
* Từ hạn định::
* Định danh Lớp Lưu trữ::
* Đổi tên Kiểu::
@end menu

@c ----------------------------------------------------------------------------
@node Kiểu cơ bản
@section Kiểu dữ liệu cơ bản
@cindex kiểu dữ liệu cơ bản
@cindex kiểu dữ liệu, cơ bản
@cindex kiểu, cơ bản

@menu
* Số nguyên::
* Số thực::
* Số phức::
@end menu

@node Số nguyên
@subsection Số nguyên
@cindex số nguyên
@cindex kiểu dữ liệu, số nguyên
@cindex kiểu, số nguyên

Kiểu dữ liệu số nguyên có kích thước tối thiểu nằm trong vùng từ 8 bits đến 32 bits.
Chuẩn C99 mở rộng vùng này ra đến 64 bits.
Bạn có thể sử dụng kiểu số nguyên để lưu giữ giá trị bằng số (và kiểu dữ liệu dạng @code{char}
để lưu trữ ký tự).  (Chú ý là kích thước và độ rộng dành
cho các kiểu này được chọn ở mức tối thiểu; tùy thuộc vào hệ thống máy tính của bạn,
kích thước và độ rộng của chúng có thể lớn hơn.)

Trong khi độ rộng tối thiểu quy định xắp xếp theo tự nhiên, chuẩn không
yêu cầu là các kiểu dữ liệu khác nhau thì độ rộng phải khác nhau.  Ví dụ,
thông thường kiểu @code{int} và @code{long} có cùng độ rộng.
Thậm chí chuẩn còn cho phép @code{signed char} và @code{long} có
cùng độ rộng, mặc dù các nền tảng hệ thống cũng không ứng xử kỳ quặc đến vậy.

@itemize @bullet

@item @code{signed char}
@cindex kiểu dữ liệu @code{signed char}
@*
Kiểu dữ liệu @code{signed char} 8-bit có thể giữ giá trị nguyên trong
khoảng @minus{}128 đến 127.


@item @code{unsigned char}
@cindex kiểu dữ liệu @code{unsigned char}
@*
Kiểu dữ liệu @code{unsigned char} 8-bit có thể giữ giá trị nguyên trong
khoảng 0 tới 255.


@item @code{char}
@cindex kiểu dữ liệu @code{char}
@*
Tùy thuộc vào hệ thống của bạn là gì, kiểu dữ liệu @code{char} được hiểu có
độ rộng tương đương với kiểu dữ liệu @code{signed char} hay @code{unsigned char}
(mặc dù chúng cũng là ba kiểu riêng biệt).  Theo quy ước,
bạn nên sử dụng kiểu dữ liệu @code{char}
để lưu giữ ký tự trong bảng mã ASCII (như là @code{`m'}), bao gồm cả
ký tự được đặc biệt (như là @code{`\n'}).


@item @code{short int}
@cindex kiểu dữ liệu @code{short int}
@*
@code{short int} 16-bit có thể giữ giá trị nguyên trong
khoảng @minus{}32,768 đến 32,767.  Bạn cũng có thể chỉ định cho kiểu dữ liệu này sử dụng
@code{short}, @code{signed short int}, hay @code{signed short}.

@item @code{unsigned short int}
@cindex kiểu dữ liệu @code{unsigned short int}
@*
Kiểu dữ liệu @code{unsigned short int} 16-bit có thể giữ giá trị nguyên
trong vùng từ 0 đến 65,535.  Bạn có thể chỉ định kiểu cho dữ liệu này
bằng @code{unsigned short}.


@item @code{int}
@cindex kiểu dữ liệu @code{int}
@*
Kiểu dữ liệu @code{int} 32-bit có thể giữ giá trị nguyên trong vùng
từ @minus{}2,147,483,648 đến 2,147,483,647.  Bạn có thể chỉ định kiểu cho dữ liệu này
bằng @code{signed int} hoặc @code{signed}.

@item @code{unsigned int}
@cindex kiểu dữ liệu @code{unsigned int}
@*
Kiểu dữ liệu @code{unsigned int} 32-bit có thể giữ giá trị nguyên trong
khoảng từ 0 đến 4,294,967,295.  Bạn có thể định kiểu dữ liệu này
đơn giản chỉ cần dùng @code{unsigned}.


@item @code{long int}
@cindex kiểu dữ liệu @code{long int}
@*
Kiểu dữ liệu @code{long int} 32-bit có thể giữ giá trị nguyên trong
khoảng ít nhất là từ @minus{}2,147,483,648 đến 2,147,483,647.  (Tùy thuộc vào
từng hệ thống, kiểu dữ liệu có thể là 64-bit, trong trường hợp này vùng giá trị là
có cùng giá trị như kiểu @code{long long int}.)  Bạn cũng có thể chỉ định
cho kiểu dữ liệu này là @code{long}, @code{signed long int},
hay @code{signed long}.


@item @code{unsigned long int}
@cindex kiểu dữ liệu @code{unsigned long int}
@*
Kiểu dữ liệu @code{unsigned long int} 32-bit có thể giữ giá trị nguyên trong
khoảng ít nhất là từ 0 to 4,294,967,295.  (Tùy thuộc vào
từng hệ thống, kiểu dữ liệu có thể là 64-bit, trong trường hợp này vùng giá trị là
có cùng giá trị như kiểu @code{unsigned long long int}.)  Bạn cũng có thể chỉ định
cho kiểu dữ liệu này là @code{unsigned long}.


@item @code{long long int}
@cindex kiểu dữ liệu @code{long long int}
@*
Kiểu dữ liệu @code{long long int} 64-bit có thể giữ giá trị nguyên trong
khoảng @w{@minus{}9,223,372,036,854,775,808} đến @w{9,223,372,036,854,775,807}. Bạn cũng
có thể chỉ định cho kiểu dữ liệu này là @code{long long},
@code{signed long long int} hay @code{signed long long}. Kiểu dữ liệu này
không thuộc chuẩn C89, nhưng lại là chuẩn của cả C99 và GNU C.



@item @code{unsigned long long int}
@cindex kiểu dữ liệu @code{unsigned long long int}
@*
Kiểu dữ liệu 64-bit @code{unsigned long long int} 64-bit có thể giữ giá trị nguyên trong
khoảng ít nhất là từ 0 đến @w{18,446,744,073,709,551,615}.  Bạn cũng
có thể chỉ định cho kiểu dữ liệu này là @code{unsigned long long}.  Kiểu dữ liệu này
không thuộc chuẩn C89, nhưng lại là chuẩn của cả C99 và GNU C.

@end itemize

Sau đây là một số ví dụ về khai báo và định nghĩa biến số nguyên:

@example
@group
int foo;
unsigned int bar = 42;
char quux = 'a';
@end group
@end example

@noindent
Dòng thứ nhất khai báo một biến số nguyên với tên @code{foo} nhưng không đặt giá trị
cho nó; đây là sự tự khởi tạo giá trị, và giá trị của nó không thể ước định được
có thể là bất kỳ giá trị nào trong một số trường hợp cá biệt.

@node Kiểu số thực
@subsection Kiểu số thực
@cindex kiểu số thực
@cindex kiểu số thập phân dấu chấm động
@cindex kiểu, số thực
@cindex kiểu, dấu chấm động
@cindex kiểu, số thực
@cindex kiểu, dấu chấm động

Có ba kiểu dữ liệu tương ứng với số chữ số trong phần thập phân.  Trong khi
kích thước và vùng giá trị của các kiểu này là giống nhau với phần lớn các hệ
thống máy tính sử dụng ngày nay, trong quá khứ kích thước của các kiểu này thay đổi giữa các
hệ thống.  Như vậy, giá trị lớn nhất và nhỏ nhất được định nghĩa sẵn trong macro
trong tệp tin thư viện @code{float.h}.  Trong phần này, chúng ta tìm các tên
của macro để có được giá trị thích hợp; kiểm tra
@code{float.h} của hệ thống để biết được số chữ số mà nó hỗ trợ.

@itemize @bullet

@item @code{float}
@cindex kiểu dữ liệu @code{float}
@*
Kiểu dữ liệu @code{float} là kiểu dấu chấm động nhỏ nhất trong ba kiểu,
if they differ in size at all.  Giá trị nhỏ nhất được lưu trong
@code{FLT_MIN}, và cũng không thể lớn hơn @code{1e-37}.  Giá trị lớn nhất
của nó được lưu giữ trong @code{FLT_MAX}, và cũng không thể nhỏ hơn @code{1e37}.


@item @code{double}
@cindex kiểu dữ liệu @code{double}
@*
Kiểu dữ liệu @code{double} tối thiểu cũng phải rộng bằng kiểu @code{float},
và có lẽ là rộng hơn.  Giá trị tối thiểu có nó lưu trong
@code{DBL_MIN}, và giá trị lớn nhất của nó được lưu giữ trong @code{DBL_MAX}.


@item @code{long double}
@cindex kiểu dữ liệu @code{long double}
@*
Kiểu dữ liệu @code{long double} tối thiểu cũng phải rộng bằng kiểu @code{float},
và có lẽ là rộng hơn.  Giá trị tối thiểu có nó lưu trong
@code{LDBL_MIN}, và giá trị lớn nhất của nó được lưu giữ trong @code{LDBL_MAX}.

@end itemize
@comment --End of the floating point types

@noindent
Tất cả các dạng dấu chấm động đều có dấu; nếu sử dụng @code{unsigned float},
chẳng hạn thế, sẽ phát sinh lỗi biên dịch.

Đây là các ví dụ khai báo và định nghĩa các biến số thực:

@example
@group
float foo;
double bar = 114.3943;
@end group
@end example

@noindent
Dòng đầu tiên khai báo một biến số kiểu float có tên @code{foo} nhưng không định giá trị
cho nó; nó tự khởi tạo giá trị, và giá trị của nó sẽ không biết trước được
là gì.

Kiểu số thực được cung cấp bởi C có độ chính xác giới hạn, và
do đó, không phải tất cả các số thực đều có thể biểu diễn một cách chính xác.
Phần lớn hệ thống máy tính mà GCC biên dịch đều sử dụng cách biểu diễn số thực
theo kiểu giá trị nhị phân, mà nó không thể biểu diễn số một cách
chính xác được, ví dụ, 4.2.  Vì lý do này, chúng tôi khuyến nghị
rằng bạn nên cân nhắc khi cấn so sánh các số thực bằng
toán tử @code{==}, nên kiểm tra số thực bằng
phương sai thích hợp.

There are other more subtle implications of these imprecise
representations; để biết thêm chi tiết, hãy đọc bài
@cite{What Every Computer Scientist Should Know About Floating-Point
Arithmetic} của David Goldberg và phần 4.2.2 @cite{The Art of
Computer Programming} của Donald Knuth.


@node Kiểu số phức
@subsection Kiểu số phức
@cindex kiểu số phức
@cindex kiểu dữ liệu, số phức
@cindex kiểu, số phức

GCC cung cấp cho bạn kiểu số phức như là một phần mở rộng
cho chuẩn C89.  Cũng giống như các đặc tính này trong chuẩn
C99@footnote{C++ cũng hỗ trợ kiểu số phức, nhưng nó không
tương thích với kiểu có trong ISO C99}, nhưng ở đây có một số
khác biệt.  Chúng tôi sẽ mô tả kiểu số phức trước.

@subsubsection Kiểu số phức tiêu chuẩn
Kiểu số phức được giới thiệu trong chuẩn C99.   Có ba kiểu số
phức:

@itemize @asis
@item @code{float _Complex}
@item @code{double _Complex}
@item @code{long double _Complex}
@end itemize

Các tên ở đây bắt đầu bằng dấu gạch dưới và theo sau là một chữ cái viết hoa
để tránh xung đột với các định danh đã có của chương trình.
Tuy vậy, tệp tin đầu @code{<complex.h>} trong chuẩn C99 đưa ra
một số macro mà nó giúp cho việc sử dụng số phức dễ dàng hơn.

@itemize @asis
@item @code{complex}
@*
Phát triển thêm @code{_Complex}.  Điều này cho phép một biến được khai báo là
@code{double complex} mà nó có vẻ tự nhiên hơn.

@item @code{I}
@*
Một hằng thuộc kiểu phức @code{const float _Complex} có giá trị của
phần ảo được quy cho @math{i}.
@end itemize

Tệp tin đầu @code{<complex.h>} cũng khai báo các hàm
để thi hành tính toán trên số phức, ví dụ hàm
@code{creal} và @code{cimag} sẽ trả về cho chúng ta phần
thực và phần ảo của một số phức @code{double complex}.  Các hàm
khác cũng đồng thời được cung cấp, như trình bày ở ví dụ này:

@example
#include <complex.h>    
#include <stdio.h>  

void example (void) 
@{    
  complex double z = 1.0 + 3.0*I; 
  printf ("Phase is %f, modulus is %f\n", carg (z), cabs (z));
@}  
@end example

@subsubsection Kiểu số phức của phần mở rộng GCC
GCC giới thiệu kiểu số phức như là một phần mở rộng cho chuẩn C89, nhưng
cách viết thì khác.   Kiểu số phức dấu-chấm-động trong phần mở rộng từ C89
của GCC là

@itemize @asis
@item @code{__complex__ float}
@item @code{__complex__ double}
@item @code{__complex__ long double}
@end itemize

Phần mở rộng của GCC cung cấp kiểu số phức khác với kiểu số chấm động,
cho phép bạn khai báo theo kiểu ký tự và số nguyên;
trên thực tế @code{__complex__} có thể sử dụng với bất kỳ kiểu
dữ liệu nguyên thủy nào.  Chúng tôi sẽ không liệt kê tất cả các cách
có thể, nhưng đây là một số ví dụ:

@itemize @bullet

@item @code{__complex__ float}
@*
Kiểu dữ liệu @code{__complex__ float} có hai thành phần: phần thực
và phần ảo, cả hai đều thuộc kiểu @code{float}.


@item @code{__complex__ int}
@*
Kiểu dữ liệu @code{__complex__ int} cũng có hai thành phần: phần thực
và phần ảo, cả hai đều thuộc kiểu nguyên
@code{int}.

@end itemize
@comment --End list of __complex__ types

Để lấy phần thực của số phức trong một câu lệnh, sử dụng từ khóa
@code{__real__}, theo sau bởi một câu lệnh.  Cũng giống như thế, sử dụng @code{__imag__}
để lấy phần ảo.
 
@example
@group
__complex__ float a = 4 + 3i;

float b = __real__ a;          /* @r{@code{b} is now 4.} */
float c = __imag__ a;          /* @r{@code{c} is now 3.} */
@end group
@end example
 
Ví dụ này tạo ra biến phức @code{a} sử dụng số thập phân,
và định nghĩa phần thực là 4 và phần ảo là 3.  Sau đó, phần
thực sẽ được gán cho biến thực @code{b}, và phần
ảo được dùng để gán cho @code{c}.


@c ----------------------------------------------------------------------------
@node Kiểu liệt kê
@section Kiểu liệt kê
@cindex kiểu liệt kê
@cindex kiểu, liệt kê
@cindex kiểu dữ liệu, liệt kê

Liệt kê là một dạng dữ liệu do người dùng tự định nghĩa sử dụng để lưu các hằng số nguyên
và sử dụng chúng theo tên.  Theo mặc định, giá trị của chúng thuộc
kiểu số nguyên không dấu @code{signed int}; tuy nhiên, bạn vẫn có thể sử dụng tùy chọn @code{-fshort-enums}
khi dịch với GCC để mà có được kiểu số nguyên nhỏ nhất có thể được.
Cả hai cách trên đều tương thích với chuẩn C89,
nhưng trộn lẫn cả hai kiểu cùng một lúc có thể
gây ra sự không tương thích.

@menu
* Định nghĩa kiểu Liệt kê::       
* Khai báo biến Liệt kê::      
@end menu

@node Định nghĩa kiểu Liệt kê
@subsection Định nghĩa kiểu Liệt kê
@cindex định nghĩa kiểu liệt kê
@cindex định nghĩa, kiểu liệt kê

Bạn định nghĩa kiểu dữ liệu dạng liệt kê bằng cách sử dụng từ khóa
@code{enum}, theo sau là tên kiểu liệt kê (đây là tùy chọn), theo sau là danh sách
của các hằng (ngăn cách nhau bằng dấu phẩy và được bao trong dấu ngoặc nhọn,
và kết thúc bằng dấu chấm phẩy.

@example
@group
enum fruit @{grape, cherry, lemon, kiwi@};
@end group
@end example

Ví dụ đó định nghĩa một kiểu dữ liệu dạng liệt kê, @code{fruit}, nó có chứa bốn
hằng giá trị nguyên, @code{grape}, @code{cherry}, @code{lemon} và
@code{kiwi}, chứa các giá trị, theo mặc định, lần lượt là 0, 1, 2 và 3.
Bạn còn có thể chỉ định một hay nhiều giá trị một các rõ ràng:

@example
@group
enum more_fruit @{banana = -17, apple, blueberry, mango@};
@end group
@end example

Ví dụ đó định nghĩa{banana} có giá trị @minus{}17, và những giá trị còn lại
sẽ tăng dần: @code{apple} là @minus{}16,
@code{blueberry} là @minus{}15, và @code{mango} là -14.  Trừ phi
được định một giá trị khác, giá trị của một phần tử sẽ lớn hơn một so với
phần tử trước đó (và giá trị của phần tử đầu tiên theo mặc định là 0).

Bạn cũng có thể qui giá trị của một phần tử theo phần tử trước đó trong cùng
một định nghĩa:

@example
@group
enum yet_more_fruit @{kumquat, raspberry, peach,
                     plum = peach + 2@};
@end group
@end example

Trong ví dụ đó, @code{kumquat} là 0, @code{raspberry} là 1,
@code{peach} là 2, và @code{plum} là 4.

Bạn không thể sử dụng cùng một tên cho một kiểu @code{enum} cùng với kiểu @code{struct} hay
@code{union} trong cùng một phạm vi.

@node Khai báo biến Liệt kê
@subsection Khai báo biến Liệt kê
@cindex khai báo biến liệt kê
@cindex liệt kê, khai báo biến

Bạn có thể khai báo các biến thuộc kiểu liệt kê khi
kiểu liệt kê được định nghĩa hay sau đó.  Ví dụ này khai báo một
biến, có tên @code{my_fruit} thuộc kiểu @code{enum fruit}, tất cả chỉ
trong một câu lệnh đơn:

@example
@group
enum fruit @{banana, apple, blueberry, mango@} my_fruit;
@end group
@end example

@noindent
trong khi ví dụ này lại định nghĩa kiểu và khai báo biến riêng biệt nhau:

@example
@group
enum fruit @{banana, apple, blueberry, mango@};
enum fruit my_fruit;
@end group
@end example

(Tất nhiên, bạn không thể khai báo nó theo cách đó nếu bạn không đặt tên
cho kiểu liệt kê.)

Mặc dù các biến loại này đều được coi là thuộc một kiểu liệt kê,
bạn vẫn có thể gán cho chúng bất kỳ giá trị nào mà bạn có thể gán cho một biến @code{int},
bao gồm cả các giá trị từ các kiểu liệt kê khác.  Hơn thế nữa, bất kỳ biến nào
mà có thể được gán giá trị từ giá trị @code{int} cũng có thể gán từ một
phần tử thuộc kiểu liệt kê.

Tuy nhiên, bạn không thể thay đổi giá trị trong một biến liệt kê một khi nó đã được
định nghĩa rồi; chúng là các giá trị hằng.  Ví dụ như, đoạn mã sau sẽ lỗi:

@example
@group
enum fruit @{banana, apple, blueberry, mango@};
banana = 15;  /* @r{You can't do this!} */
@end group
@end example

Kiểu liệt kê rất hữu dụng khi kết hợp cùng với câu lệnh @code{switch},
bởi vì trình biên dịch có thể cảnh báo nếu bạn mắc lỗi
không sử dụng một giá trị của một phần tử thuộc kiểu liệt kê. Sử dụng lại ví dụ trên, nếu
mã của bạn chỉ sử dụng @code{banana}, @code{apple} và @code{mango}
mà không dùng @code{blueberry}, GCC sẽ cảnh báo bạn.

@c ----------------------------------------------------------------------------
@node Tập hợp
@section Tập hợp
@cindex tập hợp
@cindex kiểu, tập hợp
@cindex kiểu dữ liệu, tập hợp

Tập hợp là một kiểu dữ liệu do người dùng định nghĩa sử dụng để lưu giữ nhiều biến
trong cùng một ô nhớ.  Mặc dù bạn có thể truy cập bất kỳ biến nào trong số chúng
vào bất kỳ lúc nào, song bạn chỉ có thể đọc từ một trong số chúng vì vào lúc---gán một giá trị cho
một trong số chúng sẽ ghi đè lên giá trị của cả các biến khác.


@menu
* Định nghĩa kiểu Tập hợp::             
* Khai báo biến kiểu Tập hợp::   
* Truy cập các thành viên của kiểu Tập hợp::     
* Kích thước của kiểu Tập hợp::              
@end menu

@node Định nghĩa kiểu Tập hợp
@subsection Định nghĩa kiểu Tập hợp
@cindex định nghĩa kiểu tập hợp
@cindex  tập hợp, định nghĩa

Bạn định nghĩa một kiểu tập hợp bằng các sử dụng từ khóa @code{union} theo sau là
khai báo các thành viên của tập hợp, bao quanh bằng dấu ngoặc
ôm.  Bạn khai báo mỗi thành viên trong tập hợp giống như bạn khai báo
biến thường ---sử dụng kiểu dữ liệu sau đó là một
hay hơn tên của biến ngăn cách nhau bằng dấu phẩy, và kết thúc với một
dấu chấm phẩy.  Và kết thúc định nghĩa tập hợp với một dấu chấm phẩy sau
dấu ngoặc nhọn đóng.

Bạn cũng nên bao gồm cả tên cho tập hợp giữa từ khóa @code{union}
và dấu ngoặc nhọn mở.  Đây là cú pháp tùy chọn, nhưng nếu
bạn lờ nó đi, bạn không thể quy kiểu dữ liệu tập hợp đó sau này trên
(không có câu lệnh @code{typedef}, @pxref{Câu lệnh typedef}).

Đây là một định nghĩa tập hợp đơn giản dùng để lưu giữ một số nguyên
và một giá trị số thực:

@example
@group
union numbers
  @{
    int i;
    float f;
  @};
@end group
@end example

Đoạn mã này đã định nghĩa một tập hợp có tên @code{numbers}, mà nó chứa hai
thành viên, @code{i} và @code{f}, lần lượt thuộc kiểu @code{int}
và @code{float}.


@node Khai báo biến kiểu Tập hợp
@subsection Khai báo biến kiểu Tập hợp
@cindex khai báo biến kiểu tập hợp
@cindex biến kiểu tập hợp, khai báo

Bạn có thể khai báo biến kiểu tập hợp khi bạn định nghĩa
một tập hợp hay sau khi định nghĩa, miễn là bạn đã đặt cho
tập hợp một cái tên.


@menu
* Khai báo biến kiểu Tập hợp lúc Định nghĩa::
* Khai báo biến kiểu Tập hợp sau Định nghĩa::
* Khởi tạo giá trị của các thành viên::
@end menu

@node Khai báo biến kiểu Tập hợp lúc Định nghĩa
@subsubsection Khai báo biến kiểu Tập hợp lúc Định nghĩa
@cindex khai báo biến kiểu tập hợp lúc định nghĩa
@cindex biến kiểu tập hợp, khai báo lúc định nghĩa

Bạn có thể khai báo một biến kiểu tập hợp khi bạn định nghĩa
kiểu tập hợp đó bằng cách đặt tên biến ngay sau dấu ngoặc nhọn
đóng phần định nghĩa lại, trước dấu chấm phẩy cuối.
Bạn có thể khai báo hơn một biến như vậy bằng cách ngăn cách các
tên của chúng bằng dấu phẩy.

@example
@group
union numbers
  @{
    int i;
    float f;
  @} first_number, second_number;
@end group
@end example

Ví dụ trên khai báo hai biến thuộc kiểu @code{union numbers},
@code{first_number} và @code{second_number}.



@node Khai báo biến kiểu Tập hợp sau khi Định nghĩa
@subsubsection Khai báo biến kiểu Tập hợp sau khi Định nghĩa
@cindex declaring khai báo biến kiểu tập hợp sau khi định nghĩa
@cindex declaring biến kiểu tập hợp, khai báo sau khi định nghĩa

Bạn có thể khai báo biến kiểu tập hợp sau khi định nghĩa
bănngf cách sử dụng từ khóa @code{union} và tên bạn đã đặt
cho kiểu tập hợp, theo sau là tên của một hay nhiều biến
ngăn cách nhau bởi dấu phẩy.


@example
@group
union numbers
  @{
    int i;
    float f;
  @};
union numbers first_number, second_number;
@end group
@end example

Ví dụ này khai báo hai biến thuộc kiểu @code{union numbers},
@code{first_number} và @code{second_number}.


@node Khởi tạo các Thành viên của Tập hợp
@subsubsection Khởi tạo các Thành viên của Tập hợp
@cindex khởi tạo các thành viên của tập hợp
@cindex thành viên của tập hợp, khởi tạo

Bạn có thể khởi tạo giá trị cho thành viên đầu tiên của một biến
kiểu tập hợp khi bạn khai báo nó:

@example
@group
union numbers
  @{
    int i;
    float f;
  @};
union numbers first_number = @{ 5 @};
@end group
@end example

Trong ví dụ này, thành viên @code{i} của @code{first_number} nhận
giá trị là 5.  Thành viên @code{f} bị bỏ qua.

Cách khác để khởi tạo giá trị cho một thành viên của tập hợp là chỉ định tên của
thành viên cần khởi tạo.  Theo cách này, bạn có thể khởi tạo bất kỳ thành viên nào
mình muốn, không chỉ mỗi thành viên đầu tiên.  Có hai cách giúp bạn có thể
sử dụng ---hoặc sau tên thành viên là dấu hai chấm, sau đó là giá trị của nó,
giống như thế này:

@example
@group
union numbers first_number = @{ f: 3.14159 @};
@end group
@end example

@noindent
hay là đặt trước tên thành viên một dấu chấm và gán giá trị cho nó
với một toán tử dấu bằng, giống như thế này:

@example
@group
union numbers first_number = @{ .f = 3.14159 @};
@end group
@end example

Bạn còn có thể khởi tạo một thành viên của tập hợp khi bạn khai báo biến
trong lúc định nghĩa nó:

@example
@group
union numbers
  @{
    int i;
    float f;
  @} first_number = @{ 5 @};
@end group
@end example



@node Truy cập các Thành viên của Tập hợp
@subsection Truy cập các Thành viên của Tập hợp
@cindex truy cập các thành viên của tập hợp
@cindex  thành viên của tập hợp, truy cập

Bạn có thể truy cập các thành viên của một biến kiểu tập hợp bằng cách sử dụng
toán tử truy cập thành viên.  Bạn đặt tên của biến tập hợp
phía bên trái của toán tử này, và tên của thành viên
phía bên phải.

@example
@group
union numbers
  @{
    int i;
    float f;
  @};
union numbers first_number;
first_number.i = 5;
first_number.f = 3.9;
@end group
@end example

Chú ý là trong ví dụ trên việc gán giá trị cho thành viên @code{f} sẽ ghi đè
lên giá trị của thành viên @code{i}.

@c If a union member is accessed after a value has been stored in a
@c different member, the behavior is implementation-defined, but this
@c document doesn't specify the behavior.  There is an exception
@c though: if the two members are structs and they have a common
@c initial sequence.

@node Kích thước của Tập hợp
@subsection Kích thước của Tập hợp
@cindex kích thước của tập hợp
@cindex của tập hợp, kích thước

Kích thước của một tập hợp bằng với kích thước của thành viên cần số lượng ô nhớ lớn nhất.
Xét ví dụ sử dụng cho phần này:

@example
@group
union numbers
  @{
    int i;
    float f;
  @};
@end group
@end example

@noindent Kích thước của kiểu dữ liệu tập hợp thì bằng với @code{sizeof (float)},
bởi vì kiểu @code{float} thì cần nhiều ô nhớ hơn kiểu @code{int}.  Do đó tất cả
các thành viên của tập hợp chiếm giữ cùng một không gian ô nhớ, kích thước kiểu dữ liệu tập hợp
không cần thiết có độ rộng để chứa tổng kích thước của các thành viên; nó
chỉ cần đủ rộng để chứa được phần tử lớn nhất.


@c ----------------------------------------------------------------------------
@node Cấu trúc
@section Cấu trúc
@cindex cấu trúc
@cindex kiểu, cấu trúc
@cindex kiểu dữ liệu, cấu trúc

Một cấu trúc là kiểu dữ liệu do người lập trình định nghĩa được tạo thành từ
các biến thuộc các kiểu khác nhau (còn có thể chứa các kiểu cấu trúc khác nữa).

@menu
* Định nghĩa Cấu trúc::         
* Khai báo biến Cấu trúc::  
* Truy cập thành viên Cấu trúc::  
* Trường Bit::                  
* Kích thước của Cấu trúc::          
@end menu

@node Định nghĩa Cấu trúc
@subsection Định nghĩa Cấu trúc
@cindex Định nghĩa Cấu trúc
@cindex cấu trúc, định nghĩa

Bạn định nghĩa một cấu trúc sử dụng từ khóa @code{struct} theo sau là
các khai báo các thành viên dữ liệu, bao quanh trong dấu
ngoặc nhọn.  Bạn khai báo các thành viên của cấu trúc theo cách thông thường
mà bạn vẫn làm với các kiểu cơ bản---sử dụng kiểu dữ liệu theo sau là một
hay hơn tên các biến cách nhau bằng dấu phẩy, và kết thúc bằng dấu
chấm phẩy.  Sau đó ở dấu ngoặc nhọn đóng của phần định nghĩa cấu trúc
là một dấu chấm phẩy.

Bạn có thể gộp thêm tên của cấu trúc vào giữa
từ khóa @code{struct} và dấu ngoặc nhọn mở đầu.  Đây là tùy chọn, nhưng nếu
bạn không làm thế, bạn không thể sử dụng kiểu cấu trúc này sau này nữa
(không sử dụng @code{typedef}, @pxref{Câu lệnh typedef}).

Đây là một ví dụ về việc tạo ra một cấu trúc để lưu tọa độ
X và Y của một điểm:

@example
@group
struct point
  @{
    int x, y;
  @};
@end group
@end example

Đoạn mã này định nghĩa một kiểu cấu trúc có tên @code{struct point}, nó chứa hai
thành viên dữ liệu là @code{x} và @code{y}, cả hai đều thuộc kiểu @code{int}.

Các Cấu trúc (và cả tập hợp) còn có thể chứa trong nó các kiểu dữ liệu như cấu trúc và
tập hợp unions, nhưng tất nhiên là không là là chính nó.  Nhưng một cấu trúc hay tập hợp
có thể chứa trong đó một con trỏ mà nó lại trỏ đến kiểu của chính nó.
(@pxref{Incomplete Types}).

@node Khai báo biến Cấu trúc
@subsection Khai báo biến Cấu trúc
@cindex khai báo biến cấu trúc
@cindex biến cấu trúc, khai báo

Bạn có thể khai báo các biến thuộc kiểu cấu trúc khi khởi tạo
định nghĩa một cấu trúc và cả sau khi định nghĩa, miễn là bạn đặt cho
kiểu cấu trúc một cái tên.


@menu
* Khai báo biến Cấu trúc khi Định nghĩa::  
* Khai báo biến Cấu trúc sau khi Định nghĩa::  
* Khởi tạo các thành viên của Cấu trúc::  
@end menu

@node Khai báo biến Cấu trúc khi Định nghĩa
@subsubsection Khai báo biến Cấu trúc khi Định nghĩa
@cindex khai báo biến cấu trúc khi định nghĩa
@cindex biến cấu trúc, khai báo khi định nghĩa

Bạn có thể khai báo các biến thuộc kiểu cấu trúc khi định nghĩa
nó bằng cách đặt tên biến sau dấu ngoặc nhọnđóng của phần
định nghĩa cấu trúc, nhưng phải trước dấu chấm phẩy kết thúc.
Bạn có thể tạo ra nhiều hơn một biến bằng cách ngăn cách chúng
bằng dấu phẩy.

@example
@group
struct point
  @{
    int x, y;
  @} first_point, second_point;
@end group
@end example

Ví dụ này khai báo hai biến thuộc kiểu @code{struct point},
@code{first_point} và @code{second_point}.



@node Khai báo biến Cấu trúc sau khi Định nghĩa
@subsubsection Khai báo biến Cấu trúc sau khi Định nghĩa
@cindex khai báo biến cấu trúc sau khi định nghĩa
@cindex biến cấu trúc, khai báo sau khi định nghĩa

Bạn có thể khai báo biến cấu trúc sau khi định nghĩa cấu
trúc bằng cách sử dụng từ khóa @code{struct} và tên mà
bạn đặt cho nó, theo sau là một hay nhiều tên của biến
cách nhau bằng dấu phẩy.


@example
@group
struct point
  @{
    int x, y;
  @};
struct point first_point, second_point;
@end group
@end example

Ví dụ này khai báo hai biến thuộc kiểu @code{struct point},
@code{first_point} và @code{second_point}.


@node Khởi tạo các thành viên của Cấu trúc
@subsubsection Khởi tạo các thành viên của Cấu trúc
@cindex khởi tạo các thành viên của cấu trúc
@cindex thành viên của cấu trúc, khởi tạo

Bạn có thể khởi tạo giá trị thật cho các thành viên
của cấu trúc khi bạn khai báo biến.  

Nếu bạn không khởi tạo cho một biến cấu trúc, thì giá trị sau khi khởi tạo
hoặc phụ thuộc vào nó có bộ nhớ kiểu gì (@pxref{Định danh Lớp Lưu trữ}) hoặc
không.  Nếu là vậy, các thành viên của tất cả các kiểu khởi tạo với giá trị bằng 0
và con trỏ sẽ khởi tạo với giá trị NULL; nếu không, giá trị của
các thành viên cấu trúc là vô định.

Một cách khởi tạo một cấu trúc là chỉ rõ các giá trị cách nhau bằng dấu phẩy và
đặt chúng trong dấu ngoặc nhọn.  Các giá trị này sẽ gán cho từng thành viên
trong cấu trúc với cùng thứ tự như khi chúng được
định nghĩa.


@example
@group
struct point
  @{
    int x, y;
  @};
struct point first_point = @{ 5, 10 @};
@end group
@end example

Trong ví dụ đó, thành viên @code{x} của biến @code{first_point} nhận
giá trị là 5, và thành viên @code{y} nhận giá trị là 10.

Cách khác để khởi tạo các thành viên là chỉ định tên của thành viên
cần khởi tạo.  Theo cách này, bạn có thể khởi tạo các thành viên
theo thứ tự tùy thích, và thậm chí còn bỏ qua việc khởi tạo cho một số thành viên.
Có hai phương thức mà bạn có thể sử dụng.  Cách thứ nhất có thể sử dụng trong
C99 và như là phần mở rộng C89 trong GCC:

@example
@group
struct point first_point = @{ .y = 10, .x = 5 @};
@end group
@end example

Bạn còn có thể bỏ qua dấu chấm và sử dụng dấu hai chấm thay vì sử dụng dấu @samp{=},
mặc dù đây là phần mở rộng riêng của GNU C:

@example
@group
struct point first_point = @{ y: 10, x: 5 @};
@end group
@end example

Bạn cũng có thể khởi tạo các thành viên của biến khi bạn khai báo
biến trong quá trình bạn định nghĩa cấu trúc:

@example
@group
struct point
  @{
    int x, y;
  @} first_point = @{ 5, 10 @};
@end group
@end example

Bạn cũng có thể khởi tạo số lượng thành viên ít hơn tổng số thành viên trong một cấu trúc:

@example
@group
struct pointy
  @{
    int x, y;
    char *p;
  @};
struct pointy first_pointy = @{ 5 @};
@end group
@end example

Ở đây, @code{x} được khởi tạo bằng 5, @code{y} bằng 0,
và @code{p} được khởi tạo bằng NULL.  Quy tắc ở đây là @code{y}
và @code{p} được khởi tạo như vậy nếu chúng là các
biến tĩnh.
@c See ANSI C89, sec 6.5.7, ``Initialization''.


Đây là ví dụ khác về việc khỏi tạo một thành viên của một cấu trúc
mà thành viên đó lại thuộc kiểu cấu trúc:

@example
@group
struct point
  @{
    int x, y;
  @};

struct rectangle
  @{
    struct point top_left, bottom_right;
  @};

struct rectangle my_rectangle = @{ @{0, 5@}, @{10, 0@} @};
@end group
@end example

Ví dụ này định nghĩa cấu trúc @code{rectangle} bao gồm
hai biến thuộc kiểu cấu trúc @code{point}.  Sau đó nó khai báo một biến
thuộc kiểu @code{struct rectangle} và khởi tạo giá trị cho các thành viên.  Do
các thành viên của nó là các biến thuộc kiểu cấu trúc, chúng ta sử dụng các cặp dấu ngoặc nhọn
bao quanh các thành viên mà nó thuộc kiểu biến cấu trúc @code{point}.
Tuy nhiên, những dấu ngoặc nhọn bổ xung thêm này không thực sự là bắt buộc; chúng chỉ
làm cho việc đọc mã dễ hơn mà thôi.



@node Truy cập thành viên Cấu trúc
@subsection Truy cập thành viên Cấu trúc
@cindex truy cập thành viên cấu trúc
@cindex thành viên cấu trúc, truy cập

Bạn có thể truy cập các thành viên của một biến cấu trúc sử dụng toán tử
truy cập thành viên.  Bạn đặt tên của biến cấu trúc
bên trái của toán tử, và tên của thành viên
ở phía bên phải.

@example
@group
struct point
  @{
    int x, y;
  @};

struct point first_point;

first_point.x = 0;
first_point.y = 5;
@end group
@end example

Bạn cungc có thể truy cập các thành viên của biến cấu trúc
mà bản thân thành viên này cũng thuộc kiểu cấu trúc.

@example
@group
struct rectangle
  @{
    struct point top_left, bottom_right;
  @};

struct rectangle my_rectangle;

my_rectangle.top_left.x = 0;
my_rectangle.top_left.y = 5;

my_rectangle.bottom_right.x = 10;
my_rectangle.bottom_right.y = 0;
@end group
@end example



@node Trường Bit
@subsection Trường Bit
@cindex trường bit
@cindex trường, bit

Bạn có thể tạo cấu trúc với các thành viên là số nguyên có kích thước không chuẩn, được gọi là
@emph{bit fields}.  Bạn tạo bằng cách chỉ định một thành viên thuộc kiểu số nguyên (@code{int},
@code{char}, @code{long int}, v.v..@:) như thông thường, và chèn thêm một dấu hai chấm
và số bít mà thành viên đó chiếm giữ giữa
tên thành viên bà dấu chấm phẩy.

@example
@group
struct card
  @{
    unsigned int suit : 2;
    unsigned int face_value : 4;
  @};
@end group
@end example

Ví dụ đó định nghĩa một kiểu cấu trúc với hai trường bít, @code{suit} và
@code{face_value}, mà chúng lần lượt chiếm giữ 2 bít và 4 bít.  @code{suit}
có thể nhận giá trị từ 0 đến 3, và @code{face_value} thì từ 0 tới
15.  Chú ý là những trường bit này được khai báo thuộc kiểu @code{unsigned int}; nếu
chúng là kiểu nguyên có dấu, thế thì vùng giá trị mà chúng có thể nhận tương ứng
là từ @minus{}2 đến 1, và từ @minus{}8 đến 7.

Đại để, vùng giá trị của trường bit không dấu có @math{N} bít là từ
0 đến @math{2^N - 1}, và nếu có dấu thì từ
@math{-(2^N) / 2} đến @math{((2^N) / 2) - 1}.

@c ??? Want to research this further...

@c Avoid using signed bitfields of size 1, since the interpretation of
@c that single bit (that is, whether it is a sign bit or not) is
@c implementation-defined.  GCC implements it as a sign bit.

@c @c @c At least it does on the platform I tried.  Unsure about other platforms.

Các trường bít có thể được chỉ rõ mà không cần tên cốt để mà điều khiển chính xác
bít nào bên trong đơn vị thùng chứa được sử dụng.  Tuy nhiên,
hiệu ứng của việc này không khả chuyển lắm và nó cũng ít khi hữu dụng.
Bạn cũng có thể chỉ định một trường bít có kích thước là 0, cái này chỉ thị rằng
các trường bít tiếp sau không có thêm bit nào nữa mà nó được đóng gói vào trong
đơn vị chứa trường bít kế trước.  Điều này cơ bản cũng không
hữu dụng.

Bạn không thể lấy địa chỉ của trường bít với
toán tử @code{&} (@pxref{Toán tử Con trỏ}).

@node Kích thước của Cấu trúc
@subsection Kích thước của Cấu trúc
@cindex kích thước của cấu trúc
@cindex cấu trúc, kích thước

Kích thước của kiểu cấu trúc là tổng kích cỡ của các thành viên của nó,
có lẽ bao gồm cả phần độn thêm có nguyên nhân là kiểu cấu trúc được hiệu chỉnh cho
chẵn với đơn vị byte chuẩn.  Chi tiết có thể biến đổi phụ thuộc vào nền tảng kiến trúc
máy tính của bạn, nhưng nó thường chèn thêm vào cấu trúc cho chẵn với
bốn- hay tám-byte.  Điều này được thực hiện cốt để mà tăng tốc
việc truy cập bộ nhớ cho các minh dụ thuộc kiểu cấu trúc.

Đối với phần mở rộng GNU, GCC cho phép cấu trúc không có thành viên nào.  Những cấu trúc như thế
có kích thước bằng không.

Nếu bạn thực sự muốn bỏ đi phần độn thêm trong kiểu cấu trúc của mình (vì lý do nào đó,
chẳng hạn, làm giảm tốc độ truy cập bộ nhớ của cấu trúc), thế thì GCC cung cấp
nhiều phương thức khác nhau để xếp chặt dữ liệu lại.  Cách thức dễ dàng và đơn giản là sử dụng
tùy chọn khi biên dịch là @code{-fpack-struct}.  Để có thêm thông tin chi tiết khi bỏ qua
việc xếp chặt, xin hãy xem sổ tay GCC tương ứng với phiên bản
trình dịch bạn đang dùng.

@c ----------------------------------------------------------------------------
@node Mảng
@section Mảng
@cindex mảng
@cindex kiểu, mảng
@cindex kiểu dữ liệu, mảng

Một mảng là một cấu trúc dữ liệu mà nó cho phép bạn lưu một phần tử hay nhiều hơn
liên tiếp nhau trong bộ nhớ.  Trong C, các phần tử mảng được đánh chỉ mục bắt đầu tại
vị trí số không, không phải một.

@menu
* Khai báo Mảng::
* Khởi tạo Mảng::
* Truy cập các Phần tử Mảng::
* Mảng nhiều Chiều::
* Mảng và Xâu chuỗi::
* Mảng Tập hợp::
* Mảng Cấu trúc::
@end menu


@node Khai báo Mảng
@subsection Khai báo Mảng
@cindex khai báo mảng
@cindex mảng, khai báo

Bạn khai báo một mảng bằng cách chỉ định kiểu dữ liệu của các phần tử, tên của nó,
và số lượng phần tử mà nó chứa.  Sau đây là một ví dụ khai báo
một mảng mà nó lưu giữ mời số nguyên:

@example
@group
int my_array[10];
@end group
@end example


Đối với mã C chuẩn, số thể hiện số phần tử trong mảng phải dương.

Đối với phần mở rộng GNU, số phần tử có thể nhỏ tới mức là số không.
Mảng có độ rộng là không là hữu dụng như khi nó là phần tử cuối của một cấu trúc mà nó
thực sự lại là phần đầu cho một đối tượng biến có độ dài thay đổi:

@example
@group
struct line
@{
  int length;
  char contents[0];
@};

@{
  struct line *this_line = (struct line *)
    malloc (sizeof (struct line) + this_length);
  this_line -> length = this_length;
@}
@end group
@end example

Một đặc tính mở rộng khác của GNU là cho phép bạn khai báo độ dài một mảng sử dụng
biến số, không chỉ mỗi hằng số.  Ví dụ, đây là định nghĩa một hàm
mà nó khai báo một mảng mà mảng này lại sử dụng tham số của nó để làm số lượng phần tử của mảng:

@example
@group
int
my_function (int number)
@{
  int my_array[number];
  @dots{};
@}
@end group
@end example


@node Khởi tạo Mảng
@subsection Khởi tạo Mảng
@cindex khởi tạo mảng
@cindex mảng, khởi tạo

Bạn có thể khởi tạo các phần tử trong một mảng khi bạn khai báo bằng cách liệt kê
các giá trị của chúng, ngăn cách nhau bằng dấu phẩy, đặt trong cặp dấu ngoặc nhọn.  Đây
là một ví dụ:

@example
@group
int my_array[5] = @{ 0, 1, 2, 3, 4 @};
@end group
@end example

Bạn không nhất thiết phải khởi tạo tất cả các phần tử.  Ví dụ, đoạn mã
sau chỉ khởi tạo ba phần tử đầu tiên:

@example
@group
int my_array[5] = @{ 0, 1, 2 @};
@end group
@end example

@noindent
Các phần tử không được khởi tạo một cách rõ ràng sẽ có giá trị
không xác định trừ phi mảng thuộc kiểu lưu trữ tĩnh.  Trong
trường hợp này, các kiểu số học sẽ khởi tạo là số không và
kiểu con trỏ được khởi tạo bằng NULL.

Vậu thì trong ví dụ trên, nếu định nghĩa ở mức file hay đứng
trước bởi @code{static}, hai phần tử cuối sẽ có giá trị là 0.
Nếu không, chúng sẽ có giá trị không định trước.

Khi sử dụng hoặc là ISO C99, hay C89 có mở rộng của GNU, bạn có thể khởi tạo các phần tử
của một mảng không theo đúng thứ tự của nó, bằng cách chỉ định chỉ mục của mảng để khởi tạo.  Để
thực hiện việc này, để chỉ mục của mảng trong dấu ngoặc vuông và đặt toán tử dấu bằng, đây là tùy chọn,
trước giá trị.  Sau đây là một ví dụ:

@example
@group
int my_array[5] = @{ [2] 5, [4] 9 @};
@end group
@end example
@c
@noindent
Hay có sử dụng toán tử dấu bằng:

@example
@group
int my_array[5] = @{ [2] = 5, [4] = 9 @};
@end group
@end example

@noindent
Cả hai ví dụ trên tương đương với:

@example
int my_array[5] = @{ 0, 0, 5, 0, 9 @};
@end example


Khi sử dụng đặc tính mở rộng của GNU, bạn có thể khởi tạo một vùng các phần tử
có cùng giá trị, bằng cách chỉ định chỉ mục đầu tiên và cuối cùng, theo định dạng
@code{ [@var{first}] ... [@var{last}] }.  Đây là một ví dụ:

@example
@group
int new_array[100] = @{ [0 ... 9] = 1, [10 ... 98] = 2, 3 @};
@end group
@end example

Sẽ khởi tạo các phần tử từ 0 đến 9 thành 1, các phần tử từ 10 cho đến 98
có giá trị là 2, và phần tử 99 là 3.  (Bạn cũng có thể ghi rõ là
@code{[99] = 3}.)  Cũng vậy, chú ý là bạn @emph{phải} có khoảng trống cho cả
hai bên của @samp{...}.

Nếu bạn khởi tạo mọi phần tử của một mảng, thế thì bạn không nhất thiết phải
chỉ định kích thước cho nó nữa; kích thước của nó sẽ được quyết định bằng số phần tử mà bạn
đã khởi tạo.  Đây là một ví dụ:

@example
@group
int my_array[] = @{ 0, 1, 2, 3, 4 @};
@end group
@end example

Cho dù đoạn mã trên không chỉ ra rõ ràng là mảng này có năm phần tử bằng cách
sử dụng @code{my_array[5]}, bạn đã khởi tạo năm phần tử, vậy thì đấy cũng là số
phần tử mà nó có.

Thay cho cách trên, nếu bạn chỉ ra số phần tử để khởi tạo, thế thì kích thước của
một mảng thì bằng với số phần tử cao nhất được khởi tạo, cộng thêm một.
Ví dụ:

@example
@group
int my_array[] = @{ 0, 1, 2, [99] = 99 @};
@end group
@end example

Trong ví dụ đó, chỉ có bốn phần tử được khởi tạo, nhưng phần tử cuối cùng
được khởi tạo là phần tử số 99, vậy thì nó có 100 phần tử.


@node Truy cập các Phần tử Mảng
@subsection Truy cập các Phần tử Mảng
@cindex truy cập các phần tử mảng
@cindex phần tử mảng, truy cập

Bạn truy cập các phần tử của một mảng bằng cách chỉ định tên của mảng,
theo sau là chỉ số của phần tử đặt trong cặp dấu ngoặc vuông.  Nên nhớ rằng các phần tử
của một mảng bắt đầu bằng số không.  Đây là ví dụ:

@example
@group
my_array[0] = 5;
@end group
@end example

Nó gán giá trị bằng 5 cho phần tử đầu tiên trong mảng, tại vị trí
số không.  Bạn đối đãi với các phần tử của mảng như một biến bình thường cho dù
nó thuộc kiểu dữ liệu nào.  Ví dụ, nếu bạn có một mảng của một kiểu cấu trúc,
bạn có thể truy cập các phần tử của cấu trúc giống như thế này:

@example
@group
struct point
@{
  int x, y;
@};
struct point point_array[2] = @{ @{4, 5@}, @{8, 9@} @};
point_array[0].x = 3;
@end group
@end example



@node Mảng nhiều Chiều
@subsection Mảng nhiều Chiều
@cindex mảng nhiều chiều
@cindex mảng, nhiều chiều

Bạn có thể tạo các mảng nhiều chiều, hay còn gọi là ``mảng của mảng''.
Bạn thực hiện bằng cách thêm các cặp dấu ngoặc vuông và độ dài cho mỗi
chiều mà bạn muốn mảng có.  Ví dụ, đây là một khai báo
cho một mảng hai-chiều mà nó có chứa năm phần tử cho mỗi
chiều (mảng hai phần tử của một mảng năm phần tử):

@example
@group
int two_dimensions[2][5] @{ @{1, 2, 3, 4, 5@}, @{6, 7, 8, 9, 10@} @};
@end group
@end example

Các phần tử của mảng nhiều chiều được truy cập bằng cách chỉ định chỉ số cần thiết
cho tất cả các chiều:

@example
@group
two_dimensions[1][3] = 12;
@end group
@end example

Trong ví dụ của chúng ta, @code{two_dimensions[0]} bản thân nó cũng là một mảng.
Phần tử @code{two_dimensions[0][2]} được theo sau bởi
@code{two_dimensions[0][3]}, không phải là @code{two_dimensions[1][2]}.

@node Mảng và Xâu chuỗi
@subsection Mảng và Xâu chuỗi
@cindex mảng và xâu chuỗi
@cindex xâu chuỗi, mảng

Bạn có thể sử dụng một mảng ký tự để lưu một xâu chuỗi (@pxref{Hằng Chuỗi}).
Mảng có thể được xây dựng hoặc là có dấu hoặc là không.

@cindex mảng xâu chuỗi, khai báo
@cindex khai báo mảng xâu chuỗi
Khi bạn khai báo mảng, bạn có thể chỉ rõ số phần tử mà nó sẽ
có.  Con số đó sẽ là số phần tử ký tự tối đa có thể có của một
xâu chuỗi, bao gồm cả ký tự null được sử dụng để kết thúc một chuỗi.  Nếu bạn
chọn tùy chọn này, thế thì bạn không cần phải khởi tạo mảng khi bạn
khai báo nó.  Cách khác là bạn có thể đơn giản chỉ cần khởi tạo giá trị cho mảng,
và kích thước chính xác của nó sẽ đủ rộng để chứa toàn bộ chuỗi ký tự mà bạn đã sử dụng để
khởi tạo nó.

@cindex mảng xâu chuỗi, khởi tạo
@cindex khởi tạo mảng xâu chuỗi
Có hai cách khác nhau để khởi tạo một mảng.  Bạn có thể chỉ định bằng một danh sách
các ký tự cách nhau bằng dấu phẩy và đóng gói chúng trong dấu ngoặc nhọn, hay là bạn chỉ định
một chuỗi văn bản và đóng chúng trong dấu nháy kép.

Đây là một số ví dụ:

@example
@group
char blue[26];
char yellow[26] = @{'y', 'e', 'l', 'l', 'o', 'w', '\0'@};
char orange[26] = "orange";
char gray[] = @{'g', 'r', 'a', 'y', '\0'@};
char salmon[] = "salmon";
@end group
@end example

Trong từng ví dụ trên, ký tự null @code{\0} được chèn vào vị trí
cuỗi của chuỗi, thâm chí cả khi không được công bố rõ ràng.   (Chú ý là nếu bạn
khởi tạo xâu chuỗi sử dụng một mảng các ký tự riêng biệt, thế thì
ký tự null sẽ @emph{không} được đảm bảo là luôn có.  Nó có thể có,
nhưng chuyện xảy ra có tính ngẫu nhiên, cho nên điều đó
không còn đáng tin cậy.)


Sau khi khởi tạo, bạn không thể gán một chuỗi mới cho một mảng
sử dụng toán tử dấu bằng.  Ví dụ, đoạn mã này
@emph{sẽ không hoạt động}:

@example
@group
char lemon[26] = "custard";
lemon = "steak sauce";      /* @r{Bị lỗi!} */
@end group
@end example

@noindent
Tuy nhiên, có một số hàm trong thư viện GNU C có thể thực hiện việc này
(bao gồm việc sao chép) trên một mảng chuỗi.  Bạn cũng còn có thể thay đổi từng ký tự
một, bằng cách truy cập từng phần tử riêng biệt của chuỗi như cách bạn làm với bất kỳ
loại mảng nào khác:

@example
@group
char name[] = "bob";
name[0] = 'r';
@end group
@end example

Việc không chỉ định rõ số phần tử trong một mảng là được phép,
và thế thì việc khởi tạo nó sử dụng một xâu chuỗi mà nó có nhiều phần tử hơn
số phần tử trong mảng.  Điều này là không tốt. Xâu chuỗi dài hơn
sẽ @emph{không} ghi đè lên chỉ định kích thước của mảng trước đó, và bạn
sẽ nhận được cảnh báo khi biên dịch.  Vì lẽ kích thước mảng nguyên bản còn thừa,
bất kỳ phần nào của xâu chuỗi mà nó thừa ra so với nguyên bản đó được ghi tại vị trí trong bộ nhớ
mà sẽ không được cấp cho nó.


@node Mảng Tập Hợp
@subsection Mảng Tập Hợp
@cindex mảng tập hợp
@cindex tập hợp, mảng

Bạn có thể tạo ra một mảng tập hợp cũng chỉ giống như cách chúng ta làm với
các kiểu dữ liệu cơ bản.

@example
@group
union numbers
  @{
    int i;
    float f;
  @};
union numbers number_array [3];
@end group
@end example

Ví dụ này tạo ra mảng có 3 phần tử thuộc kiểu @code{union numbers}
biến có tên @code{number_array}.  Bạn cũng còn có thể khởi tạo
thành viên đầu tiên của mảng:

@example
@group
struct point point_array [3] = @{ @{3@}, @{4@}, @{5@} @};
@end group
@end example

@noindent Các nhóm ngoặc nhọn phía trong là tùy chọn.

Sau khi khởi tạo, bạn vẫn có thể truy cập các thành viên của tập hợp trong
mảng sử dụng toán tử truy cập thành viên.  Bạn đặt tên mảng và
số của phần tử (trong dâu ngoặc vuông) bên trái của toán tử, và
tên thành viên đó ở bên phải.

@example
@group
union numbers number_array [3];
number_array[0].i = 2;
@end group
@end example

@node Mảng Cấu trúc
@subsection Mảng Cấu trúc
@cindex mảng cấu trúc
@cindex cấu trúc, mảng

Bạn có thể tạo một mảng cấu trúc giống như các kiểu dữ liệu
sơ cấp khác.

@example
@group
struct point
  @{
    int x, y;
  @};
struct point point_array [3];
@end group
@end example

Ví dụ này tạo ra mảng 3 phần tử có kiểu @code{struct point}
biến có tên @code{point_array}.  Bạn còn có thể khởi tạo
các phần tử của một mảng cấu trúc:

@example
@group
struct point point_array [3] = @{ @{2, 3@}, @{4, 5@}, @{6, 7@} @};
@end group
@end example

Đối với việc khởi tạo cấu trúc mà nó lại chứa một cấu trúc khác,
các cặp dấu ngoặc nhọn phía trong là tùy chọn.  Thế nhưng, nếu bạn sử dụng
những dấu ngoặc nhọn này, thế thì bạn có thể khởi tạo một phần cho một số
cấu trúc nhất định trong mảng, và khởi tạo đầy đủ các phần tử khác:

@example
@group
struct point point_array [3] = @{ @{2@}, @{4, 5@}, @{6, 7@} @};
@end group
@end example

Trong ví dụ đó, phần tử đầu tiên của mảng chỉ có thành viên @code{x}
được khởi tạo.  Bởi vì được nhóm trong dấu ngoặc nhọn, giá trị 4 là
gán cho thành viên @code{x} cảu phần tử mảng thứ hai,
@emph{không phải} cho thành viên @code{y} của phần tử thứ nhất, như trong
trường hợp không nhóm chúng trong cặp dấu ngoặc nhọn.

Sau khi khởi tạo, bạn vẫn có thể truy cập các thành viên của cấu trúc trong
một mảng sử dụng toán tử truy cập thành viên.  Bạn đặt tên mảng và số của
phần tử (bao trong cặp ngoặc vuông) bên trái của toán tử, và
tên của thành viên bên phải.

@example
@group
struct point point_array [3];
point_array[0].x = 2;
point_array[0].y = 3;
@end group
@end example

@c ----------------------------------------------------------------------------
@node Con trỏ
@section Con trỏ
@cindex con trỏ
@cindex kiểu, con trỏ
@cindex kiểu dữ liệu, con trỏ

Con trỏ lưu giữ địa chỉ bộ nhớ của các hằng hay biến.  Đối với
bất kỳ loại dữ liệu nào, bao gồm cả kiểu cơ bản và kiểu do người dùng định nghĩa, bạn
có thể tạo con trỏ mà nó giữ địa chỉ của từng minh dụ
của kiểu đó.

@menu
* Khai báo Con trỏ::
* Khởi tạo Con trỏ::
* Con trỏ Tập hợp::
* Con trỏ Cấu trúc::
@end menu

@node Khai báo Con trỏ
@subsection Khai báo Con trỏ
@cindex khai báo con trỏ
@cindex con trỏ, khai báo

Bạn khai báo một con trỏ bằng cách chỉ định tên và kiểu dữ liệu cho nó.
Kiểu dữ liệu chỉ ra kiểu dữ liệu của biến
mà con trỏ sẽ giữ địa chỉ.

Để khai báo một con trỏ, bao gồm toán tử
gián tiếp (@pxref{Toán tử Con trỏ}) trước định danh.
Đây là dạng thức chung của khai báo một con trỏ:

@example
@var{data-type} * @var{name};
@end example

@noindent
Khoảng trống xung quanh toán tử gián tiếp là không quan trọng:

@example
@group
@var{data-type} *@var{name};
@var{data-type}* @var{name};
@end group
@end example

Đây là một ví dụ cụ thể khai báo một con trỏ mà nó lưu giữ địa chỉ của
một biến @code{int}:

@example
@group
int *ip;
@end group
@end example

Dẫu sao cũng hãy cẩn thận:  khi khai báo nhiều con trỏ trong cùng một dòng, bạn phải
khai báo một cách rõ ràng từng biến một là con trỏ, sử dụng toán tử gián tiếp:

@example
@group
int *foo, *bar;  /* @r{Two pointers.} */
int *baz, quux;   /* @r{A pointer and an integer variable.} */
@end group
@end example


@node Khởi tạo Con trỏ
@subsection Khởi tạo Con trỏ
@cindex khởi tạo con trỏ
@cindex con trỏ, khởi tạo

Bạn có thể khởi tạo một con trỏ khi khai báo bằng cách chỉ rõ
địa chỉ biến mà nó lưu giữ.  Ví dụ, đoạn mã sau đây khai báo
một biến @samp{i} thuộc kiểu @code{int}, và một con trỏ mà nó được
khởi tạo với địa chỉ của @samp{i}:

@example
@group
int i;
int *ip = &i;
@end group
@end example

Chú ý là việc sử dụng toám tử địa chỉ (@pxref{Toán tử Con trỏ}), được sử dụng để
lấy địa chỉ của một biến.  Sau khi bạn khai báo một con trỏ, bạn
@emph{không} sử dụng toán tử gián tiếp cùng với tên của con trỏ khi gán
cho nó một địa chỉ mới mà nó muốn trỏ tới.  Trái lại, việc này lại thay đổi
giá trị của biến mà nó chỉ tới, không phải là giá trị của chính bản thân
con trỏ.  Ví dụ:

@example
@group
int i, j;
int *ip = &i;  /* @r{@samp{ip} lúc này chứa địa chỉ của @samp{i}.} */
ip = &j;       /* @r{@samp{ip} lúc này chứa địa chỉ của @samp{j}.} */
*ip = &i;      /* @r{@samp{j} lúc này chứa địa chỉ của @samp{i}.} */
@end group
@end example

Giá trị được lưu trong một con trỏ là một số nguyên: một vị trí bên trong
không gian bộ nhớ của máy tính.  Nếu bạn quá cực đoan, bạn có thể gán giá trị
một con trỏ bằng một số nguyên, rồi áp đổi kiểu cho chúng thành kiểu
con trỏ tương ứng.  Tuy nhiên, chúng tôi không khuyến khích bạn làm điều này trừ phi
trong trường hợp cực chẳng đã bạn cần phải điều khiển việc truy cập trực tiếp bộ nhớ, và bạn
thực sự biết mình đang làm gì.  Việc làm này rất dễ dẫn đến rủi ro là ghi đè dữ liệu
lên thứ gì đó mà bạn thực sự không muốn vậy.  Phần lớn việc sử dụng
kỹ thuật này cũng không tương thích rộng.

Một điều đáng chú ý nữa là việc khai báo một con trỏ sẽ không
kiểm tra biên của bộ nhớ.  Nếu bạn không
khởi tạo con trỏ bằng một địa chỉ của một đối tượng đã có nào đó,
nó sẽ trỏ đến một chỗ không mong muốn và có lẽ sẽ làm cho chương trình của bạn
gặp lỗi khi thi hành (về mặt hình thức, những việc thế này được gọi là
@dfn{undefined behavior}).

@node Con trỏ Tập hợp
@subsection Con trỏ Tập hợp
@cindex con trỏ tập hợp
@cindex tập hợp, con trỏ

Bạn có thể tạo con trỏ đến kiểu tập hợp giống như cách bạn
tạo con trỏ tới các kiểu dữ liệu cơ bản.

@example
@group
union numbers
  @{
    int i;
    float f;
  @};
union numbers foo = @{4@};
union numbers *number_ptr = &foo;
@end group
@end example

Ví dụ này tạo một kiểu tập hợp mới, @code{union numbers}, và
khai báo (đồng thời khởi tạo thành viên đầu tiên của nó) một biến của kiểu đó
có tên @code{foo}.  Cuối cùng, nó khai báo một con trỏ trỏ đến kiểu
@code{union numbers}, và đưa cho nó địa chỉ của @code{foo}.

Bạn có thể truy cập các thành viên của biến tập hợp thông qua con trỏ, nhưng
bạn không thể sử dụng toán tử truy cập thành viên như thông thường nữa.  Thay vào đấy,
bạn phải sử dụng toán tử truy cập thành viên gián tiếp
(@pxref{Biểu thức Truy cập Thành viên}).  Tiếp tục với ví dụ trước,
ví dụ sau sẽ thay đổi giá trị của thành viên đầu tiên của
@code{foo}:

@example
@group
number_ptr -> i = 450;
@end group
@end example

Bây giờ thành viên @code{i} trong @code{foo} có giá trị là 450.


@node Con trỏ Cấu trúc
@subsection Con trỏ Cấu trúc
@cindex con trỏ cấu trúc
@cindex cấu trúc, con trỏ

Bạn có thể tạo con trỏ tới kiểu dữ liệu cấu trúc như cách
bạn làm với các dạng dữ liệu cơ bản.

@example
@group
struct fish
  @{
    float length, weight;
  @};
struct fish salmon = @{4.3, 5.8@};
struct fish *fish_ptr = &salmon;
@end group
@end example

Ví dụ đó tạo ra một kiểu cấu trúc mới, @code{struct fish}, và
khai báo (đồng thời khởi tạo) một biến thuộc kiểu đó có tên @code{salmon}.
Cuối cùng, nó khai bao một con trỏ đến kiểu @code{struct fish}, và
đưa cho nó địa chỉ của @code{salmon}.

Bạn có thể truy cập các thành viên của một cấu trúc thông qua một con trỏ,
nhưng bạn không thể sử dụng toán tử truy cập thanh viên thông thường được nữa.
Thay vào đó, bạn phải sử dụng toán tử truy cập thành viên gián tiếp
(@pxref{Biểu thức Truy cập Thành viên}).  Tiếp tục sử dụng ví dụ trước,
ví dụ sau sẽ thay đổi giá trị của thành viên của
@code{salmon}:

@example
@group
fish_ptr -> length = 5.1;
fish_ptr -> weight = 6.2;
@end group
@end example

Bây giờ thành viên @code{length} và @code{width} trong @code{salmon} có giá trị
tương ứng là 5.1 và 6.2.


@c ----------------------------------------------------------------------------

@node Kiểu Khuyết thiếu
@section Kiểu Khuyết thiếu
@cindex kiểu khuyết thiếu
@cindex kiểu, khuyết thiếu
@cindex cấu trúc, khuyết thiếu
@cindex liệt kê, khuyết thiếu
@cindex tập hợp, khuyết thiếu

Bạn có thể định nghĩa kiểu cấu trúc, tập hợp và liệt kê mà không liệt kê
các thành viên (hay giá trị trong trường hợp kiểu liệt kê) của chúng ra.  Việc làm đó tạo ra
kiểu khuyết thiếu.  Bạn không thể khai báo biến dành cho kiểu này, nhưng
bạn có thể làm việc với con trỏ với kiểu này.

@example
@group
struct point;
@end group
@end example

Đến một lúc nào đó trong một chương trình bạn cần kiểu đầy đủ.
Bạn làm điều đó bằng cách định nghĩa như bạn mong muốn:

@example
@group
struct point
  @{
    int x, y;
  @};
@end group
@end example

Kỹ thuật này thường được sử dụng cho danh sách liên kết:

@example
@group
struct singly_linked_list
  @{
    struct singly_linked_list *next;
    int x;
    /* other members here perhaps */
  @};
struct singly_linked_list *list_head;
@end group
@end example


@c ----------------------------------------------------------------------------
@node Từ Hạn Định
@section Từ Hạn Định
@cindex từ hạn định
@cindex hạn định, kiểu
@cindex từ hạn định @code{const}
@cindex từ hạn định @code{volatile}
@c ANSI C89, section 6.5.3. ``Type Qualifiers''.
Có hai kiểu từ hạn định bạn có thể bổ xung vào khai báo biến
những từ này làm thay đổi cách mà biến có thể được truy cập:  @code{const} và @code{volatile}.

@code{const} làm cho biến chỉ có thể đọc; sau khi khởi tạo, giá trị
của nó không thể thay đổi được.

@example
const float pi = 3.14159f;
@end example

@noindent
Ngoài việc ngăn ngừa việc lỡ tay thay đổi dữ liệu nhầm, việc khai báo biến
với từ hạn định @code{const} có thể giúp cho trình dịch tối ưu hóa mã nguồn.

@code{volatile} thông báo cho trình dịch rõ ràng rằng biến này chắc chẵn sẽ thay đổi,
và việc truy cập của biến (cụ thể là thông qua con trỏ)
không được phép tối ưu hóa.  Bạn nên sử dụng biến có từ hạn định @code{volatile} để lưu giữ dữ liệu
mà nó được cập nhật thông qua các hàm callback hay giữ tín hiệu.
@ref{Trỏ Liên tiếp và Phân phối Tín hiệu}.

@example
volatile float currentTemperature = 40.0;
@end example

@c ----------------------------------------------------------------------------
@node Định danh Lớp Lưu trữ
@section Định danh Lớp Lưu trữ
@cindex định danh lớp lưu trữ
@cindex định danh, lớp lưu trữ
@cindex lớp lưu trữ @code{auto}
@cindex lớp lưu trữ @code{extern}
@cindex lớp lưu trữ @code{register}
@cindex lớp lưu trữ @code{static}

Có bốn kiểu lớp lưu trữ mà bạn có thể chỉ định cho biến của mình
khi khai báo để mà thay đổi cách chúng được lưu trữ trong bộ nhớ:
@code{auto}, @code{extern}, @code{register}, và @code{static}.

Bạn sử dụng @code{auto} cho các biến mà chúng chỉ hoạt động trong nội hàm, và những
giá trị của nó sẽ bị phá hủy sau lệnh return từ hàm nơi mà chúng được
khai báo.  Đây là kiểu mặc định cho các biến được khai báo trong các hàm.

@example
@group
void
foo (int value)
@{
  auto int x = value;
  @dots{}
  return;
@}
@end group
@end example

@code{register} thì cũng gần như đồng nhất mục đích với @code{auto}, mong muốn rằng
nó cũng đưa ra gợi ý cho trình duyệt rằng biến đó sẽ được sử dụng rất thường xuyên, và,
nếu có thể, nên lưu giữ biến này trong một thanh ghi (register).  Bạn không thể sử dụng
toán tử địa chỉ để lấy địa chỉ của một biến được khai báo với
@code{register}.  Điều đó có nghĩa là bạn không thể khai báo các phần tử
của một mảng cho kiểu lưu trữ @code{register}.  Trên thực tế thứ
duy nhất bạn có thể làm với một mảng là đo lường kích thước của nó bằng
@code{sizeof}.  Thông thường, GCC tự biết lựa chọn giá trị nào là tốt để lưu chúng
trong thanh ghi, và vì vậy @code{register} không hay được dùng.

@code{static} cơ bản là đối lập với @code{auto}: khi áp dụng với
các biến trong một hàm hay khối lệnh, những biến này vẫn giữ nguyên giá trị
của chúng ngay cả khi hàm hay khối lệnh đã kết thúc.   Nó được biết đến là
@dfn{static storage duration}.

@example
@group
int
sum (int x)
@{
  static int sumSoFar = 0;
  sumSoFar = sumSoFar + x;
  return sumSoFar;
@}
@end group
@end example

@noindent
Bạn cũng còn có thể khai báo các biến (hay hàm) ở trên cùng (cái mà
không nằm trong hàm) là @code{static}; những biến kiểu đó là
khả dụng cho toàn bộ (global) file mã nguồn hiện hành (nhưng các file mã nguồn
khác thì không).  Điều này mang đến một hạn chế kép cho @code{static};
nghĩa thứ hai này được biến như là @dfn{static linkage}.  Hai hàm
hay biến có sự liên kết tĩnh với nhau nhưng lại ở các file khác nhau là riêng rẽ
hoàn toàn; mà cũng không khả dụng bên ngoài file nơi mà nó được khai báo.

Việc không khởi tạo các biến mà nó được khai báo là @code{extern} sẽ đưa cho nó
giá trị mặc định là @code{0}, @code{0.0}, hay @code{NULL}, còn tùy thuộc vào
kiểu.  Việc không khởi tạo các biến mà nó được khai báo là @code{auto} hay
@code{register} (bao gồm cả cách dùng của @code{auto}) là trái lại
không được khởi tạo, và do vậy nên được giả định là không mang giá trị
cụ thể nào.

@code{extern} là hữu dụng khi khai báo một biến mà bạn muốn nó khả dụng với
tất các các file mã nguồn mà nó được liên kết đến dự án của mình.  Bạn không thể khởi tạo
một biến mà nó được khai báo với @code{extern}, cũng như không có không gian lưu trữ nào thực
sự được phân bổ trong quá trình khai báo.  Bạn phải khai báo @code{extern} trong hai trường hợp
(thông thường là trong header file cái mà được bao gồm include bởi các file mã nguồn khác mà
nó lại muốn truy cập biến này) và không khai báo @code{extern} với những chỗ mà
không có không gian bộ nhớ thực tế nào được phân bổ.  Khai báo @code{extern}
có thể lặp đi lặp lại nhiều lần.

@example
@group
extern int numberOfClients;

@dots{}

int numberOfClients = 0;
@end group
@end example

@xref{Cấu trúc Chương trình và Phạm vi}, để có thêm chi tiết.

@c ----------------------------------------------------------------------------
@node Đổi tên Kiểu
@section Đổi tên Kiểu
@cindex đổi tên kiểu
@cindex kiểu, đổi tên

Đôi khi mọi việc sẽ thuận lợi hơn nến đặt cho kiểu một cái tên mới.  Bạn thực hiện điều này sử dụng
điều lệnh @code{typedef}.  Xem @xref{Câu lệnh typedef} để biết thêm chi tiết.
