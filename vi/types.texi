
@c This is part of The GNU C Reference Manual
@c Copyright (C) 2007-2009 Free Software Foundation, Inc.
@c See the file gnu-c-manual.texi for copying conditions.
@c author:tjr@gnu.org et al

@node Kiểu dữ liệu
@chapter Kiểu dữ liệu
@cindex kiểu dữ liệu
@cindex kiểu

@menu
* Kiểu cơ bản::
* Kiểu liệt kê::
* Tập hợp::
* Cấu trúc::
* Mảng::
* Con trỏ::
* Incomplete Types::
* Từ hạn định::
* Storage Class Specifiers::
* Renaming Types::
@end menu

@c ----------------------------------------------------------------------------
@node Kiểu cơ bản
@section Kiểu dữ liệu cơ bản
@cindex kiểu dữ liệu cơ bản
@cindex kiểu dữ liệu, cơ bản
@cindex kiểu, cơ bản

@menu
* Số nguyên::
* Số thực::
* Số phức::
@end menu

@node Số nguyên
@subsection Số nguyên
@cindex số nguyên
@cindex kiểu dữ liệu, số nguyên
@cindex kiểu, số nguyên

Kiểu dữ liệu số nguyên có kích thước tối thiểu nằm trong vùng từ 8 bits đến 32 bits.
Chuẩn C99 mở rộng vùng này ra đến 64 bits.
Bạn có thể sử dụng kiểu số nguyên để lưu giữ giá trị bằng số (và kiểu dữ liệu dạng @code{char}
để lưu trữ ký tự).  (Chú ý là kích thước và độ rộng dành
cho các kiểu này được chọn ở mức tối thiểu; tùy thuộc vào hệ thống máy tính của bạn,
kích thước và độ rộng của chúng có thể lớn hơn.)

Trong khi độ rộng tối thiểu quy định xắp xếp theo tự nhiên, chuẩn không
yêu cầu là các kiểu dữ liệu khác nhau thì độ rộng phải khác nhau.  Ví dụ,
thông thường kiểu @code{int} và @code{long} có cùng độ rộng.
Thậm chí chuẩn còn cho phép @code{signed char} và @code{long} có
cùng độ rộng, mặc dù các nền tảng hệ thống cũng không ứng xử kỳ quặc đến vậy.

@itemize @bullet

@item @code{signed char}
@cindex kiểu dữ liệu @code{signed char}
@*
Kiểu dữ liệu @code{signed char} 8-bit có thể giữ giá trị nguyên trong
khoảng @minus{}128 đến 127.


@item @code{unsigned char}
@cindex kiểu dữ liệu @code{unsigned char}
@*
Kiểu dữ liệu @code{unsigned char} 8-bit có thể giữ giá trị nguyên trong
khoảng 0 tới 255.


@item @code{char}
@cindex kiểu dữ liệu @code{char}
@*
Tùy thuộc vào hệ thống của bạn là gì, kiểu dữ liệu @code{char} được hiểu có
độ rông tương đương với kiểu dữ liệu @code{signed char} hay @code{unsigned char}
(mặc dù chúng cũng là ba kiểu riêng biệt).  Theo quy ước,
bạn nên sử dụng kiểu dữ liệu @code{char}
để lưu giữ ký tự trong bảng mã ASCII (như là @code{`m'}), bao gồm cả
ký tự được đặc biệt (như là @code{`\n'}).


@item @code{short int}
@cindex kiểu dữ liệu @code{short int}
@*
@code{short int} 16-bit có thể giữ giá trị nguyên trong
khoảng @minus{}32,768 đến 32,767.  Bạn cũng có thể chỉ định cho kiểu dữ liệu này sử dụng
@code{short}, @code{signed short int}, hay @code{signed short}.

@item @code{unsigned short int}
@cindex kiểu dữ liệu @code{unsigned short int}
@*
Kiểu dữ liệu @code{unsigned short int} 16-bit có thể giữ giá trị nguyên
trong vùng từ 0 đến 65,535.  Bạn có thể chỉ định kiểu cho dữ liệu này
bằng @code{unsigned short}.


@item @code{int}
@cindex kiểu dữ liệu @code{int}
@*
Kiểu dữ liệu @code{int} 32-bit có thể giữ giá trị nguyên trong vùng
từ @minus{}2,147,483,648 đến 2,147,483,647.  Bạn có thể chỉ định kiểu cho dữ liệu này
bằng @code{signed int} hoặc @code{signed}.

@item @code{unsigned int}
@cindex kiểu dữ liệu @code{unsigned int}
@*
Kiểu dữ liệu @code{unsigned int} 32-bit có thể giữ giá trị nguyên trong
khoảng từ 0 đến 4,294,967,295.  Bạn có thể định kiểu dữ liệu này
đơn giản chỉ cần dùng @code{unsigned}.


@item @code{long int}
@cindex kiểu dữ liệu @code{long int}
@*
Kiểu dữ liệu @code{long int} 32-bit có thể giữ giá trị nguyên trong
khoảng ít nhất là từ @minus{}2,147,483,648 đến 2,147,483,647.  (Tùy thuộc vào
từng hệ thống, kiểu dữ liệu có thể là 64-bit, trong trường hợp này vùng giá trị là
có cùng giá trị như kiểu @code{long long int}.)  Bạn cũng có thể chỉ định
cho kiểu dữ liệu này là @code{long}, @code{signed long int},
hay @code{signed long}.


@item @code{unsigned long int}
@cindex kiểu dữ liệu @code{unsigned long int}
@*
Kiểu dữ liệu @code{unsigned long int} 32-bit có thể giữ giá trị nguyên trong
khoảng ít nhất là từ 0 to 4,294,967,295.  (Tùy thuộc vào
từng hệ thống, kiểu dữ liệu có thể là 64-bit, trong trường hợp này vùng giá trị là
có cùng giá trị như kiểu @code{unsigned long long int}.)  Bạn cũng có thể chỉ định
cho kiểu dữ liệu này là @code{unsigned long}.


@item @code{long long int}
@cindex kiểu dữ liệu @code{long long int}
@*
Kiểu dữ liệu @code{long long int} 64-bit có thể giữ giá trị nguyên trong
khoảng @w{@minus{}9,223,372,036,854,775,808} đến @w{9,223,372,036,854,775,807}. Bạn cũng
có thể chỉ định cho kiểu dữ liệu này là @code{long long},
@code{signed long long int} hay @code{signed long long}. Kiểu dữ liệu này
không thuộc chuẩn C89, nhưng lại là chuẩn của cả C99 và GNU C.



@item @code{unsigned long long int}
@cindex kiểu dữ liệu @code{unsigned long long int}
@*
Kiểu dữ liệu 64-bit @code{unsigned long long int} 64-bit có thể giữ giá trị nguyên trong
khoảng ít nhất là từ 0 đến @w{18,446,744,073,709,551,615}.  Bạn cũng
có thể chỉ định cho kiểu dữ liệu này là @code{unsigned long long}.  Kiểu dữ liệu này
không thuộc chuẩn C89, nhưng lại là chuẩn của cả C99 và GNU C.

@end itemize

Sau đây là một số ví dụ về khai báo và định nghĩa biến số nguyên:

@example
@group
int foo;
unsigned int bar = 42;
char quux = 'a';
@end group
@end example

@noindent
Dòng thứ nhất khai báo một biến số nguyên với tên @code{foo} nhưng không đặt giá trị
cho nó; đây là sự tự khởi tạo giá trị, và giá trị của nó không thể ước định được
có thể là bất kỳ giá trị nào trong một số trường hợp cá biệt.

@node Kiểu số thực
@subsection Kiểu số thực
@cindex kiểu số thực
@cindex kiểu số thập phân dấu chấm động
@cindex kiểu, số thực
@cindex kiểu, dấu chấm động
@cindex kiểu, số thực
@cindex kiểu, dấu chấm động

Có ba kiểu dữ liệu tương ứng với số chữ số trong phần thập phân.  Trong khi
kích thước và vùng giá trị của các kiểu này là giống nhau với phần lớn các hệ
thống máy tính sử dụng ngày nay, trong quá khứ kích thước của các kiểu này thay đổi giữa các
hệ thống.  Như vậy, giá trị lớn nhất và nhỏ nhất được định nghĩa sẵn trong macro
trong tệp tin thư viện @code{float.h}.  Trong phần này, chúng ta tìm các tên
của macro để có được giá trị thích hợp; kiểm tra
@code{float.h} của hệ thống để biết được số chữ số mà nó hỗ trợ.

@itemize @bullet

@item @code{float}
@cindex kiểu dữ liệu @code{float}
@*
Kiểu dữ liệu @code{float} là kiểu dấu chấm động nhỏ nhất trong ba kiểu,
if they differ in size at all.  Giá trị nhỏ nhất được lưu trong
@code{FLT_MIN}, và cũng không thể lớn hơn @code{1e-37}.  Giá trị lớn nhất
của nó được lưu giữ trong @code{FLT_MAX}, và cũng không thể nhỏ hơn @code{1e37}.


@item @code{double}
@cindex kiểu dữ liệu @code{double}
@*
Kiểu dữ liệu @code{double} tối thiểu cũng phải rộng bằng kiểu @code{float},
và có lẽ là rộng hơn.  Giá trị tối thiểu có nó lưu trong
@code{DBL_MIN}, và giá trị lớn nhất của nó được lưu giữ trong @code{DBL_MAX}.


@item @code{long double}
@cindex kiểu dữ liệu @code{long double}
@*
Kiểu dữ liệu @code{long double} tối thiểu cũng phải rộng bằng kiểu @code{float},
và có lẽ là rộng hơn.  Giá trị tối thiểu có nó lưu trong
@code{LDBL_MIN}, và giá trị lớn nhất của nó được lưu giữ trong @code{LDBL_MAX}.

@end itemize
@comment --End of the floating point types

@noindent
Tất cả các dạng dấu chấm động đều có dấu; nếu sử dụng @code{unsigned float},
chẳng hạn thế, sẽ phát sinh lỗi biên dịch.

Đây là các ví dụ khai báo và định nghĩa các biến số thực:

@example
@group
float foo;
double bar = 114.3943;
@end group
@end example

@noindent
Dòng đầu tiên khai báo một biến số kiểu float có tên @code{foo} nhưng không định giá trị
cho nó; nó tự khởi tạo giá trị, và giá trị của nó sẽ không biết trước được
là gì.

Kiểu số thực được cung cấp bởi C có độ chính xác giới hạn, và
do đó, không phải tất cả các số thực đều có thể biểu diễn một cách chính xác.
Phần lớn hệ thống máy tính mà GCC biên dịch đều sử dụng cách biểu diễn số thực
theo kiểu giá trị nhị phân, mà nó không thể biểu diễn số một cách
chính xác được, ví dụ, 4.2.  Vì lý do này, chúng tôi khuyến nghị
rằng bạn nên cân nhắc khi cấn so sánh các số thực bằng
toán tử @code{==}, nên kiểm tra số thực bằng
phương sai thích hợp.

There are other more subtle implications of these imprecise
representations; để biết thêm chi tiết, hãy đọc bài
@cite{What Every Computer Scientist Should Know About Floating-Point
Arithmetic} của David Goldberg và phần 4.2.2 @cite{The Art of
Computer Programming} của Donald Knuth.


@node Kiểu số phức
@subsection Kiểu số phức
@cindex kiểu số phức
@cindex kiểu dữ liệu, số phức
@cindex kiểu, số phức

GCC cung cấp cho bạn kiểu số phức như là một phần mở rộng
cho chuẩn C89.  Cũng giống như các đặc tính này trong chuẩn
C99@footnote{C++ cũng hỗ trợ kiểu số phức, nhưng nó không
tương thích với kiểu có trong ISO C99}, nhưng ở đây có một số
khác biệt.  Chúng tôi sẽ mô tả kiểu số phức trước.

@subsubsection Kiểu số phức tiêu chuẩn
Kiểu số phức được giới thiệu trong chuẩn C99.   Có ba kiểu số
phức:

@itemize @asis
@item @code{float _Complex}
@item @code{double _Complex}
@item @code{long double _Complex}
@end itemize

Các tên ở đây bắt đầu bằng dấu gạch dưới và theo sau là một chữ cái viết hoa
để tránh xung đột với các định danh đã có của chương trình.
Tuy vậy, tệp tin đầu @code{<complex.h>} trong chuẩn C99 đưa ra
một số macro mà nó giúp cho việc sử dụng số phức dễ dàng hơn.

@itemize @asis
@item @code{complex}
@*
Phát triển thêm @code{_Complex}.  Điều này cho phép một biến được khai báo là
@code{double complex} mà nó có vẻ tự nhiên hơn.

@item @code{I}
@*
Một hằng thuộc kiểu phức @code{const float _Complex} có giá trị của
phần ảo được quy cho @math{i}.
@end itemize

Tệp tin đầu @code{<complex.h>} cũng khai báo các hàm
để thi hành tính toán trên số phức, ví dụ hàm
@code{creal} và @code{cimag} sẽ trả về cho chúng ta phần
thực và phần ảo của một số phức @code{double complex}.  Các hàm
khác cũng đồng thời được cung cấp, như trình bày ở ví dụ này:

@example
#include <complex.h>    
#include <stdio.h>  

void example (void) 
@{    
  complex double z = 1.0 + 3.0*I; 
  printf ("Phase is %f, modulus is %f\n", carg (z), cabs (z));
@}  
@end example

@subsubsection Kiểu số phức của phần mở rộng GCC
GCC giới thiệu kiểu số phức như là một phần mở rộng cho chuẩn C89, nhưng
cách viết thì khác.   Kiểu số phức dấu-chấm-động trong phần mở rộng từ C89
của GCC là

@itemize @asis
@item @code{__complex__ float}
@item @code{__complex__ double}
@item @code{__complex__ long double}
@end itemize

Phần mở rộng của GCC cung cấp kiểu số phức khác với kiểu số chấm động,
cho phép bạn khai báo theo kiểu ký tự và số nguyên;
trên thực tế @code{__complex__} có thể sử dụng với bất kỳ kiểu
dữ liệu nguyên thủy nào.  Chúng tôi sẽ không liệt kê tất cả các cách
có thể, nhưng đây là một số ví dụ:

@itemize @bullet

@item @code{__complex__ float}
@*
Kiểu dữ liệu @code{__complex__ float} có hai thành phần: phần thực
và phần ảo, cả hai đều thuộc kiểu @code{float}.


@item @code{__complex__ int}
@*
Kiểu dữ liệu @code{__complex__ int} cũng có hai thành phần: phần thực
và phần ảo, cả hai đều thuộc kiểu nguyên
@code{int}.

@end itemize
@comment --End list of __complex__ types

Để lấy phần thực của số phức trong một câu lệnh, sử dụng từ khóa
@code{__real__}, theo sau bởi một câu lệnh.  Cũng giống như thế, sử dụng @code{__imag__}
để lấy phần ảo.
 
@example
@group
__complex__ float a = 4 + 3i;

float b = __real__ a;          /* @r{@code{b} is now 4.} */
float c = __imag__ a;          /* @r{@code{c} is now 3.} */
@end group
@end example
 
Ví dụ này tạo ra biến phức @code{a} sử dụng số thập phân,
và định nghĩa phần thực là 4 và phần ảo là 3.  Sau đó, phần
thực sẽ được gán cho biến thực @code{b}, và phần
ảo được dùng để gán cho @code{c}.


@c ----------------------------------------------------------------------------
@node Kiểu liệt kê
@section Kiểu liệt kê
@cindex kiểu liệt kê
@cindex kiểu, liệt kê
@cindex kiểu dữ liệu, liệt kê

Liệt kê là một dạng dữ liệu do người dùng tự định nghĩa sử dụng để lưu các hằng số nguyên
và sử dụng chúng theo tên.  Theo mặc định, giá trị của chúng thuộc
kiểu số nguyên không dấu @code{signed int}; tuy nhiên, bạn vẫn có thể sử dụng tùy chọn @code{-fshort-enums}
khi dịch với GCC để mà có được kiểu số nguyên nhỏ nhất có thể được.
Cả hai cách trên đều tương thích với chuẩn C89,
nhưng trộn lẫn cả hai kiểu cùng một lúc có thể
gây ra sự không tương thích.

@menu
* Định nghĩa kiểu Liệt kê::       
* Khai báo biến Liệt kê::      
@end menu

@node Định nghĩa kiểu Liệt kê
@subsection Định nghĩa kiểu Liệt kê
@cindex định nghĩa kiểu liệt kê
@cindex định nghĩa, kiểu liệt kê

Bạn định nghĩa kiểu dữ liệu dạng liệt kê bằng cách sử dụng từ khóa
@code{enum}, theo sau là tên kiểu liệt kê (đây là tùy chọn), theo sau là danh sách
của các hằng (ngăn cách nhau bằng dấu phẩy và được bao trong dấu ngoặc ôm,
và kết thúc bằng dấu chấm phẩy.

@example
@group
enum fruit @{grape, cherry, lemon, kiwi@};
@end group
@end example

Ví dụ đó định nghĩa một kiểu dữ liệu dạng liệt kê, @code{fruit}, nó có chứa bốn
hằng giá trị nguyên, @code{grape}, @code{cherry}, @code{lemon} và
@code{kiwi}, chứa các giá trị, theo mặc định, lần lượt là 0, 1, 2 và 3.
Bạn còn có thể chỉ định một hay nhiều giá trị một các rõ ràng:

@example
@group
enum more_fruit @{banana = -17, apple, blueberry, mango@};
@end group
@end example

Ví dụ đó định nghĩa{banana} có giá trị @minus{}17, và những giá trị còn lại
sẽ tăng dần: @code{apple} là @minus{}16,
@code{blueberry} là @minus{}15, và @code{mango} là -14.  Trừ phi
được định một giá trị khác, giá trị của một phần tử sẽ lớn hơn một so với
phần tử trước đó (và giá trị của phần tử đầu tiên theo mặc định là 0).

Bạn cũng có thể qui giá trị của một phần tử theo phần tử trước đó trong cùng
một định nghĩa:

@example
@group
enum yet_more_fruit @{kumquat, raspberry, peach,
                     plum = peach + 2@};
@end group
@end example

Trong ví dụ đó, @code{kumquat} là 0, @code{raspberry} là 1,
@code{peach} là 2, và @code{plum} là 4.

Bạn không thể sử dụng cùng một tên cho một kiểu @code{enum} cùng với kiểu @code{struct} hay
@code{union} trong cùng một phạm vi.

@node Khai báo biến Liệt kê
@subsection Khai báo biến Liệt kê
@cindex khai báo biến liệt kê
@cindex liệt kê, khai báo biến

Bạn có thể khai báo các biến thuộc kiểu liệt kê khi
kiểu liệt kê được định nghĩa hay sau đó.  Ví dụ này khai báo một
biến, có tên @code{my_fruit} thuộc kiểu @code{enum fruit}, tất cả chỉ
trong một câu lệnh đơn:

@example
@group
enum fruit @{banana, apple, blueberry, mango@} my_fruit;
@end group
@end example

@noindent
trong khi ví dụ này lại định nghĩa kiểu và khai báo biến riêng biệt nhau:

@example
@group
enum fruit @{banana, apple, blueberry, mango@};
enum fruit my_fruit;
@end group
@end example

(Tất nhiên, bạn không thể khai báo nó theo cách đó nếu bạn không đặt tên
cho kiểu liệt kê.)

Mặc dù các biến loại này đều được coi là thuộc một kiểu liệt kê,
bạn vẫn có thể gán cho chúng bất kỳ giá trị nào mà bạn có thể gán cho một biến @code{int},
bao gồm cả các giá trị từ các kiểu liệt kê khác.  Hơn thế nữa, bất kỳ biến nào
mà có thể được gán giá trị từ giá trị @code{int} cũng có thể gán từ một
phần tử thuộc kiểu liệt kê.

Tuy nhiên, bạn không thể thay đổi giá trị trong một biến liệt kê một khi nó đã được
định nghĩa rồi; chúng là các giá trị hằng.  Ví dụ như, đoạn mã sau sẽ lỗi:

@example
@group
enum fruit @{banana, apple, blueberry, mango@};
banana = 15;  /* @r{You can't do this!} */
@end group
@end example

Kiểu liệt kê rất hữu dụng khi kết hợp cùng với câu lệnh @code{switch},
bởi vì trình biên dịch có thể cảnh báo nếu bạn mắc lỗi
không sử dụng một giá trị của một phần tử thuộc kiểu liệt kê. Sử dụng lại ví dụ trên, nếu
mã của bạn chỉ sử dụng @code{banana}, @code{apple} và @code{mango}
mà không dùng @code{blueberry}, GCC sẽ cảnh báo bạn.

@c ----------------------------------------------------------------------------
@node Tập hợp
@section Tập hợp
@cindex tập hợp
@cindex kiểu, tập hợp
@cindex kiểu dữ liệu, tập hợp

Tập hợp là một kiểu dữ liệu do người dùng định nghĩa sử dụng để lưu giữ nhiều biến
trong cùng một ô nhớ.  Mặc dù bạn có thể truy cập bất kỳ biến nào trong số chúng
vào bất kỳ lúc nào, song bạn chỉ có thể đọc từ một trong số chúng vì vào lúc---gán một giá trị cho
một trong số chúng sẽ ghi đè lên giá trị của cả các biến khác.


@menu
* Định nghĩa kiểu Tập hợp::             
* Khai báo biến kiểu Tập hợp::   
* Truy cập các thành viên của kiểu Tập hợp::     
* Kích thước của kiểu Tập hợp::              
@end menu

@node Định nghĩa kiểu Tập hợp
@subsection Định nghĩa kiểu Tập hợp
@cindex định nghĩa kiểu tập hợp
@cindex  tập hợp, định nghĩa

Bạn định nghĩa một kiểu tập hợp bằng các sử dụng từ khóa @code{union} theo sau là
khai báo các thành viên của tập hợp, bao quanh bằng dấu ngoặc
ôm.  Bạn khai báo mỗi thành viên trong tập hợp giống như bạn khai báo
biến thường ---sử dụng kiểu dữ liệu sau đó là một
hay hơn tên của biến ngăn cách nhau bằng dấu phẩy, và kết thúc với một
dấu chấm phẩy.  Và kết thúc định nghĩa tập hợp với một dấu chấm phẩy sau
dấu ngoặc ôm đóng.

Bạn cũng nên bao gồm cả tên cho tập hợp giữa từ khóa @code{union}
và dấu ngoặc ôm mở.  Đây là cú pháp tùy chọn, nhưng nếu
bạn lờ nó đi, bạn không thể quy kiểu dữ liệu tập hợp đó sau này trên
(không có câu lệnh @code{typedef}, @pxref{Câu lệnh typedef}).

Đây là một định nghĩa tập hợp đơn giản dùng để lưu giữ một số nguyên
và một giá trị số thực:

@example
@group
union numbers
  @{
    int i;
    float f;
  @};
@end group
@end example

Đoạn mã này đã định nghĩa một tập hợp có tên @code{numbers}, mà nó chứa hai
thành viên, @code{i} và @code{f}, lần lượt thuộc kiểu @code{int}
và @code{float}.


@node Khai báo biến kiểu Tập hợp
@subsection Khai báo biến kiểu Tập hợp
@cindex khai báo biến kiểu tập hợp
@cindex biến kiểu tập hợp, khai báo

Bạn có thể khai báo biến kiểu tập hợp khi bạn định nghĩa
một tập hợp hay sau khi định nghĩa, miễn là bạn đã đặt cho
tập hợp một cái tên.


@menu
* Khai báo biến kiểu Tập hợp lúc Định nghĩa::
* Khai báo biến kiểu Tập hợp sau Định nghĩa::
* Khởi tạo giá trị của các thành viên::
@end menu

@node Khai báo biến kiểu Tập hợp lúc Định nghĩa
@subsubsection Khai báo biến kiểu Tập hợp lúc Định nghĩa
@cindex khai báo biến kiểu tập hợp lúc định nghĩa
@cindex biến kiểu tập hợp, khai báo lúc định nghĩa

Bạn có thể khai báo một biến kiểu tập hợp khi bạn định nghĩa
kiểu tập hợp đó bằng cách đặt tên biến ngay sau dấu ngoặc ôm
đóng phần định nghĩa lại, trước dấu chấm phẩy cuối.
Bạn có thể khai báo hơn một biến như vậy bằng cách ngăn cách các
tên của chúng bằng dấu phẩy.

@example
@group
union numbers
  @{
    int i;
    float f;
  @} first_number, second_number;
@end group
@end example

Ví dụ trên khai báo hai biến thuộc kiểu @code{union numbers},
@code{first_number} và @code{second_number}.



@node Khai báo biến kiểu Tập hợp sau khi Định nghĩa
@subsubsection Khai báo biến kiểu Tập hợp sau khi Định nghĩa
@cindex declaring khai báo biến kiểu tập hợp sau khi định nghĩa
@cindex declaring biến kiểu tập hợp, khai báo sau khi định nghĩa

Bạn có thể khai báo biến kiểu tập hợp sau khi định nghĩa
bănngf cách sử dụng từ khóa @code{union} và tên bạn đã đặt
cho kiểu tập hợp, theo sau là tên của một hay nhiều biến
ngăn cách nhau bởi dấu phẩy.


@example
@group
union numbers
  @{
    int i;
    float f;
  @};
union numbers first_number, second_number;
@end group
@end example

Ví dụ này khai báo hai biến thuộc kiểu @code{union numbers},
@code{first_number} và @code{second_number}.


@node Khởi tạo các Thành viên của Tập hợp
@subsubsection Khởi tạo các Thành viên của Tập hợp
@cindex khởi tạo các thành viên của tập hợp
@cindex thành viên của tập hợp, khởi tạo

Bạn có thể khởi tạo giá trị cho thành viên đầu tiên của một biến
kiểu tập hợp khi bạn khai báo nó:

@example
@group
union numbers
  @{
    int i;
    float f;
  @};
union numbers first_number = @{ 5 @};
@end group
@end example

Trong ví dụ này, thành viên @code{i} của @code{first_number} nhận
giá trị là 5.  Thành viên @code{f} bị bỏ qua.

Cách khác để khởi tạo giá trị cho một thành viên của tập hợp là chỉ định tên của
thành viên cần khởi tạo.  Theo cách này, bạn có thể khởi tạo bất kỳ thành viên nào
mình muốn, không chỉ mỗi thành viên đầu tiên.  Có hai cách giúp bạn có thể
sử dụng ---hoặc sau tên thành viên là dấu hai chấm, sau đó là giá trị của nó,
giống như thế này:

@example
@group
union numbers first_number = @{ f: 3.14159 @};
@end group
@end example

@noindent
hay là đặt trước tên thành viên một dấu chấm và gán giá trị cho nó
với một toán tử dấu bằng, giống như thế này:

@example
@group
union numbers first_number = @{ .f = 3.14159 @};
@end group
@end example

Bạn còn có thể khởi tạo một thành viên của tập hợp khi bạn khai báo biến
trong lúc định nghĩa nó:

@example
@group
union numbers
  @{
    int i;
    float f;
  @} first_number = @{ 5 @};
@end group
@end example



@node Truy cập các Thành viên của Tập hợp
@subsection Truy cập các Thành viên của Tập hợp
@cindex truy cập các thành viên của tập hợpaccessing union members
@cindex  thành viên của tập hợp, truy cập

Bạn có thể truy cập các thành viên của một biến kiểu tập hợp bằng cách sử dụng
toán tử truy cập thành viên.  Baj đặt tên của biến tập hợp
phía bên trái của toán tử này, và tên của thành viên
phía bên phải.

@example
@group
union numbers
  @{
    int i;
    float f;
  @};
union numbers first_number;
first_number.i = 5;
first_number.f = 3.9;
@end group
@end example

Chú ý là trong ví dụ trên việc gán giá trị cho thành viên @code{f} sẽ ghi đè
lên giá trị của thành viên @code{i}.

@c If a union member is accessed after a value has been stored in a
@c different member, the behavior is implementation-defined, but this
@c document doesn't specify the behavior.  There is an exception
@c though: if the two members are structs and they have a common
@c initial sequence.

@node Kích thước của Tập hợp
@subsection Kích thước của Tập hợp
@cindex kích thước của tập hợp
@cindex của tập hợp, kích thước

Kích thước của một tập hợp bằng với kích thước của thành viên cần số lượng ô nhớ lớn nhất.
Xét ví dụ sử dụng cho phần này:

@example
@group
union numbers
  @{
    int i;
    float f;
  @};
@end group
@end example

@noindent Kích thước của kiểu dữ liệu tập hợp thì bằng với @code{sizeof (float)},
bởi vì kiểu @code{float} thì cần nhiều ô nhớ hơn kiểu @code{int}.  Do đó tất cả
các thành viên của tập hợp chiếm giữ cùng một không gian ô nhớ, kích thước kiểu dữ liệu tập hợp
không cần thiết có độ rộng để chứa tổng kích thước của các thành viên; nó
chỉ cần đủ rộng để chứa được phần tử lớn nhất.


@c ----------------------------------------------------------------------------
@node Structures
@section Structures
@cindex structures
@cindex types, structure
@cindex data types, structure

A structure is a programmer-defined data type made up of
variables of other data types (possibly including other structure types).

@menu
* Defining Structures::         
* Declaring Structure Variables::  
* Accessing Structure Members::  
* Bit Fields::                  
* Size of Structures::          
@end menu

@node Defining Structures
@subsection Defining Structures
@cindex defining structures
@cindex structures, defining

You define a structure using the @code{struct} keyword followed by
the declarations of the structure's members, enclosed in
braces.  You declare each member of a structure just as you would
normally declare a variable---using the data type followed by one
or more variable names separated by commas, and ending with a
semicolon.  Then end the structure definition with a semicolon after
the closing brace.

You should also include a name for the structure in between the
@code{struct} keyword and the opening brace.  This is optional, but if
you leave it out, you can't refer to that structure data type later
on (without a @code{typedef}, @pxref{The typedef Statement}).

Here is an example of defining a simple structure for holding the
X and Y coordinates of a point:

@example
@group
struct point
  @{
    int x, y;
  @};
@end group
@end example

That defines a structure type named @code{struct point}, which contains two
members, @code{x} and @code{y}, both of which are of type @code{int}.

Structures (and unions) may contain instances of other structures and
unions, but of course not themselves.  It is possible for a structure
or union type to contain a field which is a pointer to the same type
(@pxref{Incomplete Types}).

@node Declaring Structure Variables
@subsection Declaring Structure Variables
@cindex declaring structure variables
@cindex structure variables, declaring

You can declare variables of a structure type when both you initially
define the structure and after the definition, provided you gave the
structure type a name.


@menu
* Declaring Structure Variables at Definition::  
* Declaring Structure Variables After Definition::  
* Initializing Structure Members::  
@end menu

@node Declaring Structure Variables at Definition
@subsubsection Declaring Structure Variables at Definition
@cindex declaring structure variables at definition
@cindex structure variables, declaring at definition

You can declare variables of a structure type when you define the
structure type by putting the variable names after the closing
brace of the structure definition, but before the final semicolon.
You can declare more than one such variable by separating the names
with commas.

@example
@group
struct point
  @{
    int x, y;
  @} first_point, second_point;
@end group
@end example

That example declares two variables of type @code{struct point},
@code{first_point} and @code{second_point}.



@node Declaring Structure Variables After Definition
@subsubsection Declaring Structure Variables After Definition
@cindex declaring structure variables after definition
@cindex structure variables, declaring after definition

You can declare variables of a structure type after defining the
structure by using the @code{struct} keyword and the name you
gave the structure type, followed by one or more variable names
separated by commas.


@example
@group
struct point
  @{
    int x, y;
  @};
struct point first_point, second_point;
@end group
@end example

That example declares two variables of type @code{struct point},
@code{first_point} and @code{second_point}.


@node Initializing Structure Members
@subsubsection Initializing Structure Members
@cindex initializing structure members
@cindex structure members, initializing

You can initialize the members of a structure type to have certain
values when you declare structure variables.  

If you do not initialize a structure variable, the effect depends on
whether it is has static storage (@pxref{Storage Class Specifiers}) or
not.  If it is, members with integral types are initialized with 0 and
pointer members are initialized to NULL; otherwise, the value of the
structure's members is indeterminate.

One way to initialize a structure is to specify the values in a set of
braces and separated by commas.  Those values are assigned to the
structure members in the same order that the members are declared in
the structure in definition.


@example
@group
struct point
  @{
    int x, y;
  @};
struct point first_point = @{ 5, 10 @};
@end group
@end example

In that example, the @code{x} member of @code{first_point} gets the
value 5, and the @code{y} member gets the value 10.

Another way to initialize the members is to specify the name of the
member to initialize.  This way, you can initialize the members in
any order you like, and even leave some of them uninitialized.  There
are two methods that you can use.  The first method is available in
C99 and as a C89 extension in GCC:

@example
@group
struct point first_point = @{ .y = 10, .x = 5 @};
@end group
@end example

You can also omit the period and use a colon instead of @samp{=},
though this is a GNU C extension:

@example
@group
struct point first_point = @{ y: 10, x: 5 @};
@end group
@end example

You can also initialize the structure variable's members when you declare
the variable during the structure definition:

@example
@group
struct point
  @{
    int x, y;
  @} first_point = @{ 5, 10 @};
@end group
@end example

You can also initialize fewer than all of a structure variable's members:

@example
@group
struct pointy
  @{
    int x, y;
    char *p;
  @};
struct pointy first_pointy = @{ 5 @};
@end group
@end example

Here, @code{x} is initialized with 5, @code{y} is initialized with 0,
and @code{p} is initialized with NULL.  The rule here is that @code{y}
and @code{p} are initialized just as they would be if they were static
variables.
@c See ANSI C89, sec 6.5.7, ``Initialization''.


Here is another example that initializes a structure's members which
are structure variables themselves:

@example
@group
struct point
  @{
    int x, y;
  @};

struct rectangle
  @{
    struct point top_left, bottom_right;
  @};

struct rectangle my_rectangle = @{ @{0, 5@}, @{10, 0@} @};
@end group
@end example

That example defines the @code{rectangle} structure to consist of
two @code{point} structure variables.  Then it declares one variable
of type @code{struct rectangle} and initializes its members.  Since
its members are structure variables, we used an extra set of braces
surrounding the members that belong to the @code{point} structure
variables.  However, those extra braces are not necessary; they just
make the code easier to read.



@node Accessing Structure Members
@subsection Accessing Structure Members
@cindex accessing structure members
@cindex structure members, accessing

You can access the members of a structure variable using the member
access operator.  You put the name of the structure
variable on the left side of the operator, and the name of the
member on the right side.

@example
@group
struct point
  @{
    int x, y;
  @};

struct point first_point;

first_point.x = 0;
first_point.y = 5;
@end group
@end example

You can also access the members of a structure variable which is itself a
member of a structure variable.

@example
@group
struct rectangle
  @{
    struct point top_left, bottom_right;
  @};

struct rectangle my_rectangle;

my_rectangle.top_left.x = 0;
my_rectangle.top_left.y = 5;

my_rectangle.bottom_right.x = 10;
my_rectangle.bottom_right.y = 0;
@end group
@end example



@node Bit Fields
@subsection Bit Fields
@cindex bit fields
@cindex fields, bit

You can create structures with integer members of nonstandard sizes, called
@emph{bit fields}.  You do this by specifying an integer (@code{int},
@code{char}, @code{long int}, etc.@:) member as usual, and inserting a colon
and the number of bits that the member should occupy in between the
member's name and the semicolon.

@example
@group
struct card
  @{
    unsigned int suit : 2;
    unsigned int face_value : 4;
  @};
@end group
@end example

That example defines a structure type with two bit fields, @code{suit} and
@code{face_value}, which take up 2 bits and 4 bits, respectively.  @code{suit}
can hold values from 0 to 3, and @code{face_value} can hold values from 0 to
15.  Notice that these bit fields were declared as @code{unsigned int}; had
they been signed integers, then their ranges would have been from
@minus{}2 to 1, and from @minus{}8 to 7, respectively.

More generally, the range of an unsigned bit field of @math{N} bits is from
0 to @math{2^N - 1}, and the range of a signed bit field of @math{N}
bits is from @math{-(2^N) / 2} to @math{((2^N) / 2) - 1}.

@c ??? Want to research this further...

@c Avoid using signed bitfields of size 1, since the interpretation of
@c that single bit (that is, whether it is a sign bit or not) is
@c implementation-defined.  GCC implements it as a sign bit.

@c @c @c At least it does on the platform I tried.  Unsure about other platforms.

Bit fields can be specified without a name in order to control which
actual bits within the containing unit are used.  However,
the effect of this is not very portable and it is rarely useful.
You can also specify a bit field of size 0, which indicates that
subsequent bit fields not further bit fields should be packed into the
unit containing the previous bit field.  This is likewise not
generally useful.

You may not take the address of a bit field with the address
operator @code{&} (@pxref{Pointer Operators}).

@node Size of Structures
@subsection Size of Structures
@cindex size of structures
@cindex structures, size of

The size of a structure type is equal to the sum of the size of all of its
members, possibly including padding to cause the structure type to align to
a particular byte boundary.  The details vary depending on your computer
platform, but it would not be atypical to see structures padded to align
on four- or eight-byte boundaries.  This is done in order to speed up
memory accesses of instances of the structure type.

As a GNU extension, GCC allows structures with no members.  Such structures
have zero size.

If you wish to explicitly omit padding from your structure types (which may,
in turn, decrease the speed of structure memory accesses), then GCC provides
multiple methods of turning packing off.  The quick and easy method is to
use the @code{-fpack-struct} compiler option.  For more details on omitting
packing, please see the GCC manual which corresponds to your version of the
compiler.

@c ----------------------------------------------------------------------------
@node Arrays
@section Arrays
@cindex arrays
@cindex types, array
@cindex data types, array

An array is a data structure that lets you store one or more elements
consecutively in memory.  In C, array elements are indexed beginning at
position zero, not one.

@menu
* Declaring Arrays::
* Initializing Arrays::
* Accessing Array Elements::
* Multidimensional Arrays::
* Arrays as Strings::
* Arrays of Unions::
* Arrays of Structures::
@end menu


@node Declaring Arrays
@subsection Declaring Arrays
@cindex declaring arrays
@cindex arrays, declaring

You declare an array by specifying the data type for its elements, its name,
and the number of elements it can store.  Here is an example that declares
an array that can store ten integers:

@example
@group
int my_array[10];
@end group
@end example


For standard C code, the number of elements in an array must be positive.

As a GNU extension, the number of elements can be as small as zero.
Zero-length arrays are useful as the last element of a structure which is
really a header for a variable-length object:

@example
@group
struct line
@{
  int length;
  char contents[0];
@};

@{
  struct line *this_line = (struct line *)
    malloc (sizeof (struct line) + this_length);
  this_line -> length = this_length;
@}
@end group
@end example

Another GNU extension allows you to declare an array size using
variables, rather than only constants.  For example, here is a function definition
that declares an array using its parameter as the number of elements:

@example
@group
int
my_function (int number)
@{
  int my_array[number];
  @dots{};
@}
@end group
@end example


@node Initializing Arrays
@subsection Initializing Arrays
@cindex initializing arrays
@cindex arrays, initializing

You can initialize the elements in an array when you declare it by listing
the initializing values, separated by commas, in a set of braces.  Here
is an example:

@example
@group
int my_array[5] = @{ 0, 1, 2, 3, 4 @};
@end group
@end example

You don't have to initialize all of the array elements.  For example, this code
initializes only the first three elements:

@example
@group
int my_array[5] = @{ 0, 1, 2 @};
@end group
@end example

@noindent
Items that are not explicitly initialized will have an indeterminate
value unless the array is of static storage duration.  For arrays of
static storage duration, arithmetic types are initialized as zero and
pointers are initialized as NULL.

So, in the example above, if the definition is at file level or is
preceded by @code{static}, the final two elements will be 0.
Otherwise, the final two elements will have an indeterminate value.

When using either ISO C99, or C89 with GNU extensions, you can initialize array
elements out of order, by specifying which array indices to initialize.  To do
this, include the array index in brackets, and optionally the assignment operator,
before the value.  Here is an example:

@example
@group
int my_array[5] = @{ [2] 5, [4] 9 @};
@end group
@end example
@c
@noindent
Or, using the assignment operator:

@example
@group
int my_array[5] = @{ [2] = 5, [4] = 9 @};
@end group
@end example

@noindent
Both of those examples are equivalent to:

@example
int my_array[5] = @{ 0, 0, 5, 0, 9 @};
@end example


When using GNU extensions, you can initialize a range of elements to
the same value, by specifying the first and last indices, in the form
@code{ [@var{first}] ... [@var{last}] }.  Here is an example:

@example
@group
int new_array[100] = @{ [0 ... 9] = 1, [10 ... 98] = 2, 3 @};
@end group
@end example

That initializes elements 0 through 9 to 1, elements 10 through 98
to 2, and element 99 to 3.  (You also could explicitly write
@code{[99] = 3}.)  Also, notice that you @emph{must} have spaces on both
sides of the @samp{...}.

If you initialize every element of an array, then you do not have to
specify its size; its size is determined by the number of elements you
initialize.  Here is an example:

@example
@group
int my_array[] = @{ 0, 1, 2, 3, 4 @};
@end group
@end example

Although this does not explicitly state that the array has five elements
using @code{my_array[5]}, it initializes five elements, so that is how many
it has.

Alternately, if you specify which elements to initialize, then the size of
the array is equal to the highest element number initialized, plus one.
For example:

@example
@group
int my_array[] = @{ 0, 1, 2, [99] = 99 @};
@end group
@end example

In that example, only four elements are initialized, but the last one
initialized is element number 99, so there are 100 elements.


@node Accessing Array Elements
@subsection Accessing Array Elements
@cindex accessing array elements
@cindex array elements, accessing

You can access the elements of an array by specifying the array name,
followed by the element index, enclosed in brackets.  Remember that the array
elements are numbered starting with zero.  Here is an example:

@example
@group
my_array[0] = 5;
@end group
@end example

That assigns the value 5 to the first element in the array, at position
zero.  You can treat individual array elements like variables of whatever
data type the array is made up of.  For example, if you have an array made
of a structure data type, you can access the structure elements like this:

@example
@group
struct point
@{
  int x, y;
@};
struct point point_array[2] = @{ @{4, 5@}, @{8, 9@} @};
point_array[0].x = 3;
@end group
@end example



@node Multidimensional Arrays
@subsection Multidimensional Arrays
@cindex multidimensional arrays
@cindex arrays, multidimensional

You can make multidimensional arrays, or ``arrays of arrays''.
You do this by adding an extra set of brackets and array lengths for every
additional dimension you want your array to have.  For example, here is
a declaration for a two-dimensional array that holds five elements in each
dimension (a two-element array consisting of five-element arrays):

@example
@group
int two_dimensions[2][5] @{ @{1, 2, 3, 4, 5@}, @{6, 7, 8, 9, 10@} @};
@end group
@end example

Multidimensional array elements are accessed by specifying the desired index
of both dimensions:

@example
@group
two_dimensions[1][3] = 12;
@end group
@end example

In our example, @code{two_dimensions[0]} is itself an array.  The
element @code{two_dimensions[0][2]} is followed by
@code{two_dimensions[0][3]}, not by @code{two_dimensions[1][2]}.

@node Arrays as Strings
@subsection Arrays as Strings
@cindex arrays as strings
@cindex strings, arrays as

You can use an array of characters to hold a string (@pxref{String Constants}).
The array may be built of either signed or unsigned characters.

@cindex string arrays, declaring
@cindex declaring string arrays
When you declare the array, you can specify the number of elements it will
have.  That number will be the maximum number of characters that should be
in the string, including the null character used to end the string.  If you
choose this option, then you do not have to initialize the array when you
declare it.  Alternately, you can simply initialize the array to a value,
and its size will then be exactly large enough to hold whatever string you
used to initialize it.

@cindex string arrays, initializing
@cindex initializing string arrays
There are two different ways to initialize the array.  You can specify of
comma-delimited list of characters enclosed in braces, or you can specify a
string literal enclosed in double quotation marks.

Here are some examples:

@example
@group
char blue[26];
char yellow[26] = @{'y', 'e', 'l', 'l', 'o', 'w', '\0'@};
char orange[26] = "orange";
char gray[] = @{'g', 'r', 'a', 'y', '\0'@};
char salmon[] = "salmon";
@end group
@end example

In each of these cases, the null character @code{\0} is included at the
end of the string, even when not explicitly stated.   (Note that if you
initialize a string using an array of individual characters, then the
null character is @emph{not} guaranteed to be present.  It might be,
but such an occurrence would be one of chance, and should not be relied
upon.)


After initialization, you cannot assign a new string literal to an array
using the assignment operator.  For example, this
@emph{will not work}:

@example
@group
char lemon[26] = "custard";
lemon = "steak sauce";      /* @r{Fails!} */
@end group
@end example

@noindent
However, there are functions in the GNU C library that perform operations
(including copy) on string arrays.  You can also change one character at
a time, by accessing individual string elements as you would any other
array:

@example
@group
char name[] = "bob";
name[0] = 'r';
@end group
@end example

It is possible for you to explicitly state the number of elements in the
array, and then initialize it using a string that has more characters than
there are elements in the array.  This is not a good thing.  The larger string
will @emph{not} override the previously specified size of the array, and you
will get a compile-time warning.  Since the original array size remains, any
part of the string that exceeds that original size is being written to a memory
location that was not allocated for it.


@node Arrays of Unions
@subsection Arrays of Unions
@cindex arrays of unions
@cindex unions, arrays of

You can create an array of a union type just as you can an array
of a primitive data type.

@example
@group
union numbers
  @{
    int i;
    float f;
  @};
union numbers number_array [3];
@end group
@end example

That example creates a 3-element array of @code{union numbers}
variables called @code{number_array}.  You can also initialize the
first members of the elements of a number array:

@example
@group
struct point point_array [3] = @{ @{3@}, @{4@}, @{5@} @};
@end group
@end example

@noindent The additional inner grouping braces are optional.

After initialization, you can still access the union members in the
array using the member access operator.  You put the array name and
element number (enclosed in brackets) to the left of the operator, and
the member name to the right.

@example
@group
union numbers number_array [3];
number_array[0].i = 2;
@end group
@end example

@node Arrays of Structures
@subsection Arrays of Structures
@cindex arrays of structures
@cindex structures, arrays of

You can create an array of a structure type just as you can an array
of a primitive data type.

@example
@group
struct point
  @{
    int x, y;
  @};
struct point point_array [3];
@end group
@end example

That example creates a 3-element array of @code{struct point}
variables called @code{point_array}.  You can also initialize the
elements of a structure array:

@example
@group
struct point point_array [3] = @{ @{2, 3@}, @{4, 5@}, @{6, 7@} @};
@end group
@end example

As with initializing structures which contain structure members, the
additional inner grouping braces are optional.  But, if you use the
additional braces, then you can partially initialize some of the
structures in the array, and fully initialize others:

@example
@group
struct point point_array [3] = @{ @{2@}, @{4, 5@}, @{6, 7@} @};
@end group
@end example

In that example, the first element of the array has only its @code{x}
member initialized.  Because of the grouping braces, the value 4 is
assigned to the @code{x} member of the second array element,
@emph{not} to the @code{y} member of the first element, as would be
the case without the grouping braces.

After initialization, you can still access the structure members in the
array using the member access operator.  You put the array name and
element number (enclosed in brackets) to the left of the operator, and
the member name to the right.

@example
@group
struct point point_array [3];
point_array[0].x = 2;
point_array[0].y = 3;
@end group
@end example

@c ----------------------------------------------------------------------------
@node Pointers
@section Pointers
@cindex pointers
@cindex types, pointer
@cindex data types, pointer

Pointers hold memory addresses of stored constants or variables.  For
any data type, including both primitive types and custom types, you
can create a pointer that holds the memory address of an instance of
that type.

@menu
* Declaring Pointers::
* Initializing Pointers::
* Pointers to Unions::
* Pointers to Structures::
@end menu

@node Declaring Pointers
@subsection Declaring Pointers
@cindex declaring pointers
@cindex pointers, declaring

You declare a pointer by specifying a name for it and a data type.
The data type indicates of what type of variable the pointer will
hold memory addresses.

To declare a pointer, include the indirection
operator (@pxref{Pointer Operators}) before 
the identifier.  Here is the general form of a pointer declaration:

@example
@var{data-type} * @var{name};
@end example

@noindent
White space is not significant around the indirection operator:

@example
@group
@var{data-type} *@var{name};
@var{data-type}* @var{name};
@end group
@end example

Here is an example of declaring a pointer to hold the address of
an @code{int} variable:

@example
@group
int *ip;
@end group
@end example

Be careful, though:  when declaring multiple pointers in the same statement, you must
explicitly declare each as a pointer, using the indirection operator:

@example
@group
int *foo, *bar;  /* @r{Two pointers.} */
int *baz, quux;   /* @r{A pointer and an integer variable.} */
@end group
@end example


@node Initializing Pointers
@subsection Initializing Pointers
@cindex initializing pointers
@cindex pointers, initializing

You can initialize a pointer when you first declare it by specifying
a variable address to store in it.  For example, the following code
declares an @code{int} variable @samp{i}, and a pointer which is
initialized with the address of @samp{i}:

@example
@group
int i;
int *ip = &i;
@end group
@end example

Note the use of the address operator (@pxref{Pointer Operators}), used
to get the memory address of a variable.  After you declare a pointer, you
do @emph{not} use the indirection operator with the pointer's name when
assigning it a new address to point to.  On the contrary, that would change
the value of the variable that the points to, not the value of the pointer
itself.  For example:

@example
@group
int i, j;
int *ip = &i;  /* @r{@samp{ip} now holds the address of @samp{i}.} */
ip = &j;       /* @r{@samp{ip} now holds the address of @samp{j}.} */
*ip = &i;      /* @r{@samp{j} now holds the address of @samp{i}.} */
@end group
@end example

The value stored in a pointer is an integral number: a location within
the computer's memory space.  If you are so inclined, you can assign pointer
values explicitly using literal integers, casting them to the appropriate
pointer type.  However, we do not recommend this practice unless you need
to have extremely fine-tuned control over what is stored in memory, and you
know exactly what you are doing.  It would be all too easy to accidentally
overwrite something that you did not intend to.   Most uses of this
technique are also non-portable.

It is important to note that declaring a pointer variable does not
have the side effect of reserving any storage.  If you do not
initialize a pointer with the address of some other existing object,
it points nowhere in particular and will likely make your program
crash if you use it (formally, this kind of thing is called
@dfn{undefined behavior}).

@node Pointers to Unions
@subsection Pointers to Unions
@cindex pointers to unions
@cindex unions, pointers to

You can create a pointer to a union type just as you can a pointer
to a primitive data type.

@example
@group
union numbers
  @{
    int i;
    float f;
  @};
union numbers foo = @{4@};
union numbers *number_ptr = &foo;
@end group
@end example

That example creates a new union type, @code{union numbers}, and
declares (and initializes the first member of) a variable of that type
named @code{foo}.  Finally, it declares a pointer to the type
@code{union numbers}, and gives it the address of @code{foo}.

You can access the members of a union variable through a pointer, but
you can't use the regular member access operator anymore.  Instead,
you have to use the indirect member access operator (@pxref{Member
Access Expressions}).  Continuing with the previous example, the
following example will change the value of the first member of
@code{foo}:

@example
@group
number_ptr -> i = 450;
@end group
@end example

Now the @code{i} member in @code{foo} is 450.


@node Pointers to Structures
@subsection Pointers to Structures
@cindex pointers to structures
@cindex structures, pointers to

You can create a pointer to a structure type just as you can a pointer
to a primitive data type.

@example
@group
struct fish
  @{
    float length, weight;
  @};
struct fish salmon = @{4.3, 5.8@};
struct fish *fish_ptr = &salmon;
@end group
@end example

That example creates a new structure type, @code{struct fish}, and
declares (and initializes) a variable of that type named @code{salmon}.
Finally, it declares a pointer to the type @code{struct fish}, and
gives it the address of @code{salmon}.

You can access the members of a structure variable through a pointer,
but you can't use the regular member access operator anymore.
Instead, you have to use the indirect member access operator
(@pxref{Member Access Expressions}).  Continuing with the previous
example, the following example will change the values of the members
of @code{salmon}:

@example
@group
fish_ptr -> length = 5.1;
fish_ptr -> weight = 6.2;
@end group
@end example

Now the @code{length} and @code{width} members in @code{salmon} are
5.1 and 6.2, respectively.


@c ----------------------------------------------------------------------------

@node Incomplete Types
@section Incomplete Types
@cindex incomplete types
@cindex types, incomplete
@cindex structures, incomplete
@cindex enumerations, incomplete
@cindex unions, incomplete

You can define structures, unions, and enumerations without listing their
members (or values, in the case of enumerations).  Doing so results in
an incomplete type.  You can't declare variables of incomplete types, but
you can work with pointers to those types.

@example
@group
struct point;
@end group
@end example

At some time later in your program you will want to complete
the type.  You do this by defining it as you usually would:

@example
@group
struct point
  @{
    int x, y;
  @};
@end group
@end example

This technique is commonly used to for linked lists:

@example
@group
struct singly_linked_list
  @{
    struct singly_linked_list *next;
    int x;
    /* other members here perhaps */
  @};
struct singly_linked_list *list_head;
@end group
@end example


@c ----------------------------------------------------------------------------
@node Type Qualifiers
@section Type Qualifiers
@cindex type qualifiers
@cindex qualifiers, type
@cindex @code{const} type qualifier
@cindex @code{volatile} type qualifier
@c ANSI C89, section 6.5.3. ``Type Qualifiers''.
There are two type qualifiers that you can prepend to your variable declarations
which change how the variables may be accessed:  @code{const} and @code{volatile}.

@code{const} causes the variable to be read-only; after initialization, its
value may not be changed.

@example
const float pi = 3.14159f;
@end example

@noindent
In addition to helping to prevent accidental value changes, declaring variables
with @code{const} can aid the compiler in code optimization.

@code{volatile} tells the compiler that the variable is explicitly changeable,
and seemingly useless accesses of the variable (for instance, via pointers) should
not be optimized away.  You might use @code{volatile} variables to store data
that is updated via callback functions or signal handlers.
@ref{Sequence Points and Signal Delivery}.

@example
volatile float currentTemperature = 40.0;
@end example

@c ----------------------------------------------------------------------------
@node Storage Class Specifiers
@section Storage Class Specifiers
@cindex storage class specifiers
@cindex specifiers, storage class
@cindex @code{auto} storage class specifier
@cindex @code{extern} storage class specifier
@cindex @code{register} storage class specifier
@cindex @code{static} storage class specifier

There are four storage class specifiers that you can prepend to your variable
declarations which change how the variables are stored in memory:
@code{auto}, @code{extern}, @code{register}, and @code{static}.

You use @code{auto} for variables which are local to a function, and whose
values should be discarded upon return from the function in which they are
declared.  This is the default behavior for variables declared within functions.

@example
@group
void
foo (int value)
@{
  auto int x = value;
  @dots{}
  return;
@}
@end group
@end example

@code{register} is nearly identical in purpose to @code{auto}, except that
it also suggests to the compiler that the variable will be heavily used, and,
if possible, should be stored in a register.  You cannot use the
address-of operator to obtain the address of a variable declared with
@code{register}.  This means that you cannot refer to the elements of
an array declared with storage class @code{register}.  In fact the
only thing you can do with such an array is measure its size with
@code{sizeof}.  GCC normally makes good choices about which values to
hold in registers, and so @code{register} is not often used.

@code{static} is essentially the opposite of @code{auto}: when applied to
variables within a function or block, these variables will retain their
value even when the function or block is finished.   This is known as
@dfn{static storage duration}.

@example
@group
int
sum (int x)
@{
  static int sumSoFar = 0;
  sumSoFar = sumSoFar + x;
  return sumSoFar;
@}
@end group
@end example

@noindent
You can also declare variables (or functions) at the top level (that
is, not inside a function) to be @code{static}; such variables are
visible (global) to the current source file (but not other source
files).  This gives an unfortunate double meaning to @code{static};
this second meaning is known as @dfn{static linkage}.  Two functions
or variables having static linkage in separate files are entirely
separate; neither is visible outside the file in which it is declared.

Uninitialized variables that are declared as @code{extern} are given
default values of @code{0}, @code{0.0}, or @code{NULL}, depending on
the type.  Uninitialized variables that are declared as @code{auto} or
@code{register} (including the default usage of @code{auto}) are left
uninitialized, and hence should not be assumed to hold any particular
value.

@code{extern} is useful for declaring variables that you want to be visible to
all source files that are linked into your project.  You cannot initialize a
variable in an @code{extern} declaration, as no space is actually allocated
during the declaration.  You must make both an @code{extern} declaration
(typically in a header file that is included by the other source files which
need to access the variable) and a non-@code{extern} declaration which is where
space is actually allocated to store the variable.  The @code{extern} declaration
may be repeated multiple times.

@example
@group
extern int numberOfClients;

@dots{}

int numberOfClients = 0;
@end group
@end example

@xref{Program Structure and Scope}, for related information.

@c ----------------------------------------------------------------------------
@node Renaming Types
@section Renaming Types
@cindex renaming types
@cindex types, renaming

Sometimes it is convenient to give a new name to a type.  You can do this using
the @code{typedef} statement.  @xref{The typedef Statement}, for more information.
