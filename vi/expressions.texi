@c ??? It might be a good idea to turn each example of an expression
@c into a small program that prints output and thus shows what
@c the expression does.

@c This is part of The GNU C Reference Manual
@c Copyright (C) 2007-2011 Free Software Foundation, Inc.
@c See the file gnu-c-manual.texi for copying conditions.

@node Biểu thức và Toán tử
@chapter Biểu thức và Toán tử

@menu
* Biểu thức::
* Toán tử Gán::
* Gia và Giảm::
* Toán tử Số học::
* Toán tử Kết hợp với Số phức::
* Toán tử So sánh::
* Toán tử Lô-gíc::
* Dịch Bít::
* Toán tử Lô-gíc trên Bít::
* Toán tử Con trỏ::
* Toán tử sizeof::
* Áp đổi Kiểu::
* Chỉ số Mảng::
* Biểu thức từ Gọi Hàm::
* Toán tử dấu Phẩy::
* Biểu thức Truy cập Thành viên::
* Biểu thức Điều kiện::
* Câu lệnh và Khai báo trong Biểu thức::
* Quyền ưu tiên của Toán tử::
* Thứ tự Định giá::
* Tràn::
@end menu

@node Biểu thức
@section Biểu thức
@cindex biểu thức

Một @dfn{biểu thức} gồm có ít nhất là một toán hạng không hoặc nhiều hơn một
toán tử.  Đối tượng kiểu của toán hạng như là hằng, biến, và
giá trị trả về từ cú gọi hàm.  Đây là một số ví dụ:

@example
@group
47
2 + 2
cosine(3.14159) /* @r{Chúng ta giả sử rằng nó trả về giá trị dấu chấm động.} */
@end group
@end example

Các dấu ngoặc đơn dùng để nhóm các biểu thức con:

@example
( 2 * ( ( 3 + 10 ) - ( 2 * 6 ) ) )
@end example

@noindent
Biểu thức ở trong cùng được định giá trước.  Trong ví dụ trên,
@code{3 + 10} và @code{2 * 6} được định giá là @code{13} và @code{12},
tương ứng.  Sau đó @code{12} được trừ đi
@code{13}, kết quả là một @code{1}.  Cuối cùng, @code{1} được nhân với
@code{2}, kết quả là @code{2}.  Cặp dấu ngoặc ngoài cùng chỉ là
tùy chọn.

@cindex toán tử

Một @dfn{toán tử} định ra một hành động để thực thi trên toán hạng.
Toán tử có thể có một, hai hay nhiều toán hạng, còn phụ thuộc vào toán tử.

@node Toán tử Gán
@section Toán tử Gán
@cindex toán tử gán
@cindex toán tử, gán

Toán tử gán đưa giá trị lưu trữ vào biến.  C cung cấp nhiều biến thể
khác nhau của toán tử gán.

Toán tử gán theo tiêu chuẩn @code{=} đơn giản chỉ lưu trữ giá trị của
toán hạng bên phải của nó vào biến được chỉ ra ở toán hạng bên trái.  Với
mọi toán tử gán, toán hạng bên trái (thông thường được xem như là
``lvalue'') không thể là dạng văn bản hay hằng giá trị.

@example
@group
int x = 10;
float y = 45.12 + 2.0;
int z = (2 * (3 + function () ));

struct foo @{
  int bar;
  int baz;
@} quux = @{3, 4, 5@};
@end group
@end example

@noindent
Chú ý rằng, không giống như phần mô tả các toán tử gán ở phía dưới, bạn
có thể sử dụng toán tử gán thường để mà lưu trữ giá trị của kiểu
cấu trúc.

Toán tử gán phức hợp thực hiện việc thi hành perform an operation bao gồm
cả hai phía trái và phải của các toán tử, và sau đó gán kết quả của
biểu thức cho toán hạng trái.  Sau đây là danh sách các toán tử
gán phức hợp, và mô tả vắn tắt về hoạt động của chúng:

@itemize

@item
@code{+=}

Cộng hai toán hạng với nhau, sau đó thì gán kết quả của phép
cộng cho toán hạng bên trái.

@item
@code{-=}

Trừ toán hạng bên phải cho toán hạng bên trái, và
sau đó thì gán kết quả của phép trừ cho toán hạng bên trái.

@item
@code{*=}

Nhân hai toán hạng với nhau, sau đó thì gán kết quả của phép
nhân cho toán hạng bên trái.

@item
@code{/=}

Lấy toán hạng bên trái chia cho toán hạng bên phải, và
gán kết quả cho toán hạng bên trái.

@item
@code{%=}

Thực hiện phép lấy chia lấy phần dư trên hai toán hạng, và
gán kết quả cho toán hạng bên trái.

@item
@code{<<=}

Thực hiện việc đẩy trái toán hạng trái, số bít
được đẩy được chỉ định bởi toán hạng bên phải, và gán
kết quả của quá trình đẩy này cho toán hạng bên trái.

@item
@code{>>=}

Thực hiện việc đẩy phải toán hạng trái, số bít
được đẩy được chỉ định bởi toán hạng bên phải, và gán
kết quả của quá trình đẩy này cho toán hạng bên trái.

@item
@code{&=}

Thực hiện phép luận lý VÀ trên bít (bitwise) trên hai toán hạng, và
gán kết quả sau khi thực hiện cho toán hạng bên phải.

@item
@code{^=}

Thực hiện phép luận lý LOẠI TRỪ trên bít (bitwise) trên hai toán hạng, và
gán kết quả sau khi thực hiện cho toán hạng bên phải.

@item
@code{|=}

Thực hiện phép luận lý HOẶC trên bít (bitwise) trên hai toán hạng, và
gán kết quả sau khi thực hiện cho toán hạng bên phải.

@end itemize
@comment  __End of compound assignment operator list

Đây là một ví dụ về việc sử dụng toán tử gán phức hợp:

@example
x += y;
@end example

@noindent
Từ đó không có kết quả cuối cùng khác biệt nào bởi việc định giá biến
@code{x} là một lvalue (giá trị có địa chỉ), đoạn mã trên có cùng kết quả với:

@example
x = x + y;
@end example


@c GNU C Extension -- temporarily commented out for manual 0.1
@c @node Generalized Lvalues
@c @subsubsection Generalized Lvalues
@c @cindex compound expressions as lvalues
@c @cindex expressions, compound, as lvalues
@c @cindex conditional expressions as lvalues
@c index expressions, conditional, as lvalues
@c @cindex casts as lvalues
@c @cindex generalized lvalues
@c @cindex lvalues, generalized
@c @cindex extensions, @code{?:}
@c @cindex @code{?:} extensions
@c 
@c Compound expressions, conditional expressions and casts are allowed as
@c lvalues provided their operands are lvalues.  This means that you can take
@c their addresses or store values into them.
@c 
@c For example, you can assign a value to a compound expression, provided the
@c last expression in the sequence is an lvalue.  These two expressions are
@c equivalent:
@c 
@c @example
@c (a, b) += 5
@c a, (b += 5)
@c @end example
@c 
@c Similarly, you can take the address of a compound expression.  So, these two
@c expressions are equivalent:
@c 
@c @example
@c &(a, b)
@c a, &b
@c @end example
@c 
@c A conditional expression is a valid lvalue if its type is not void and if
@c both the second and third operands are valid lvalues.  For example, these two
@c expressions are equivalent:
@c 
@c @example
@c (a ? b : c) = 5
@c (a ? b = 5 : (c = 5))
@c @end example
@c 
@c A type cast is a valid lvalue if its operand is an lvalue.  A simple
@c assignment whose left-hand side is a cast works by converting the
@c right-hand side first to the specified type, then to the type of the
@c inner left-hand side expression.  After this is stored, the value is
@c converted back to the specified type to become the value of the
@c assignment.  Thus, if @code{a} has type @code{char *}, the following two
@c expressions are equivalent:
@c 
@c @example
@c (int)a = 5
@c (int)(a = (char *)(int)5)
@c @end example
@c 
@c An assignment-with-arithmetic operation such as @code{+=} applied to a cast
@c performs the arithmetic using the type resulting from the cast, and then
@c continues as in the previous case.  Therefore, these two expressions are
@c equivalent:
@c 
@c @example
@c (int)a += 5
@c (int)(a = (char *)(int) ((int)a + 5))
@c @end example

@c You cannot take the address of an lvalue cast, because the use of its
@c address would not work out coherently.  Suppose that @code{&(int)f} were
@c permitted, where @code{f} has type @code{float}.  Then the following
@c statement would try to store an integer bit-pattern where a floating
@c point number belongs:
@c 
@c @example
@c *&(int)f = 1;
@c @end example
@c 
@c This is quite different from what @code{(int)f = 1} would do---that
@c would convert 1 to floating point and store it.  Rather than cause this
@c inconsistency, we think it is better to prohibit use of @code{&} on a cast.
@c 
@c If you really do want an @code{int *} pointer with the address of
@c @code{f}, you can simply write @code{(int *)&f}.

@node Gia và Giảm
@section Gia và Giảm
@cindex toán tử gia
@cindex toán tử giảm
@cindex toán tử, gia
@cindex toán tử, giảm

Toán tử gia số @code{++} thêm 1 vào toán hạng của nó.  Toán hạng phải
hoặc là biến thuộc một kiểu dữ liệu cơ bản, một con trỏ, hay một
biến thuộc kiểu liệt kê.  Bạn có thể áp dụng toán tử gia trước cũng như sau
toán hạng.  Đây là một số ví dụ:

@example
@group
char w = '1';
int x = 5;
char y = 'B';
float z = 5.2;
int *p = &x;

x++;   /* @r{@code{x} bây giờ là 6.} */
++y;   /* @r{@code{y} bây giờ là `C' (on ASCII systems).} */
++w;   /* @r{@code{y} bây giờ là ký tự `2' (không phải giá trị là 2).} */
z++;   /* @r{@code{z} bây giờ là 6.2.} */
++p;   /* @r{@code{p} bây giờ là @code{&x} + @code{sizeof(int)}.} */
@end group
@end example

@noindent
(Chú ý là việc gia một con trỏ chỉ khôn ngoan nếu như bạn có lý do để mà tin rằng
giá trị mới của con trỏ sẽ trong vùng nhớ hợp lệ.)

Việc gia số trước thêm 1 trước khi toán hạng được ước lượng.  Một sự gia
số sau thêm một sau khi toán hạng được ước lượng.  Trong ví dụ trước,
việc thay đổi vị trí của toán tử cũng không làm thay đổi gì.
Tuy nhiên, có một số trường hợp lại tạo ra sự khác biệt:

@example
@group
int x = 5;
printf ("%d \n", x++);    /* @r{In @code{x} ra màn hình sau đó mới gia số.} */
/* @r{@code{x} is now equal to 6.} */
printf ("%d \n", ++x);    /* @r{Gia số @code{x} lên và sau đó mới in ra màn hình.} */
@end group
@end example

@noindent
Kết xuất của ví dụ trên là:

@example
@group
5
7
@end group
@end example

Cũng giống vậy, bạn có thể trừ một từ toán hạng sử dụng toán tử giảm:

@example
@group
int x = 5;

x--; /* @r{@code{x} giờ là 4.} */
@end group
@end example

@noindent
Việc giảm trước và sau cũng giống như toán tử
gia được giới thiệu ở trên.

@node Toán tử Số học
@section Toán tử Số học
@cindex toán tử số học
@cindex toán tử, số học

C cung cấp các toán tử cho các tính toán số học: phép cộng, phép trừ,
phép nhân, và phép chia, cùng với phép chia lấy phần dư và phép phủ định.  Cách sử dụng
của những toán tử này không phức tạp; đây là một số ví dụ:

@example
@group
/* @r{Phép cộng.} */
x = 5 + 3;
y = 10.23 + 37.332;
quux_pointer = foo_pointer + bar_pointer;
@end group
@end example

@example
@group
/* @r{Phép trừ.} */
x = 5 - 3;
y = 57.223 - 10.903;
quux_pointer = foo_pointer - bar_pointer;
@end group
@end example

@noindent
Bạn có thể cộng và trừ bộ nhớ con trỏ, nhưng không thể nhân
hay chia chúng.

@example
@group
/* @r{Phép nhân.} */
x = 5 * 3;
y = 47.4 * 1.001;
@end group
@end example

@example
@group
/* @r{Phép chia.} */
x = 5 / 3;
y = 940.0 / 20.2;
@end group
@end example

@noindent
Sự chia hai số nguyên dương được cắt cụt phần thập phân phía sau, vậy thì 5/3 bằng
1.  Tuy nhiên, nếu một trong hai toán hạng là số âm, hướng làm tròn
được thực hiện.  @ref{Phép chia số Nguyên có Dấu} để
có thông tin thêm về tràn số âm trong phép chia số nguyên có dấu.

@c We should state how GCC behaves if an operand is negative.


Bạn có thể sử dụng toán tử modulus @code{%} để mà lấy được phần dư của
phép chia hai toán hạng.  Bạn đặt các toán hạng hai bên của toán
tử, và thứ tự các bên của toán hạng không giao hoán:
@code{3 % 5} và @code{5 % 3} là không có cùng kết quả.
Các toán hạng phải là biểu thức của một kiểu nguyên.

@example
@group
/* @r{Phép chia lầy Modular.} */
x = 5 % 3;
y = 74 % 47;
@end group
@end example

@noindent
Phép chia Modular trả về phân dư của việc chia hai toán hạng
số nguyên. Các toán hạng phải là kiểu dữ liệu
nguyên.

@example
@group
/* @r{Phép đảo.} */
int x = -5;
float y = -3.14159;
@end group
@end example

Nếu toán hạng bạn sử dụng với toán tử đảo (âm) với một kiểu dữ liệu
không dấu, thế thì kết quả sẽ không thể âm được, nhưng đúng hơn là
bít có giá trị lớn nhất của kiểu dữ liệu không dấu, chứa dấu trừ của toán hạng.

Nhiều hệ thống sử dụng hệ thống số bù hai, và trên những hệ thống như vậy
tất cả các giá trị âm của kiểu không dấu có thể lưu giữ ở xa số không hơn là
các giá trị dương.   Ví dụ, trên một hệ thống, chương
trình này:

@example
@group
#include <limits.h>
#include <stdio.h>

int main (int argc, char *argv[]) 
@{
  int x;
  x = INT_MAX;
  printf("INT_MAX  = %d\n", x);
  x = INT_MIN;
  printf("INT_MIN  = %d\n", x);
  x = -x;
  printf("-INT_MIN = %d\n", x);
  return 0;
@}
@end group
@end example

Sản phẩm đầu ra là:

@example
@group
INT_MAX  = 2147483647
INT_MIN  = -2147483648
-INT_MIN = -2147483648
@end group
@end example

Điều này không quan trọng, bạn còn có thể áp dụng toán tử dương (cộng)
cho một biểu thức số học:

@example
int x = +42;
@end example

@noindent
Numeric values are assumed to be positive unless explicitly made
negative, so this operator has no effect on program operation.

@node Toán tử Kết hợp cho Số phức
@section Toán tử Kết hợp cho Số phức
@cindex toán tử kết hợp cho số phức
@cindex kết hợp
 
Đây là phần mở rộng của GNU, bạn có thể sử dụng toán tử kết hợp cho số phức @code{~} để
mà thực hiện các phép toán trên toán hạng --- thật vậy, nó đảo ngược dấu
của phần ảo của nó.   Toán hạng phải là một biểu thức thuộc kiểu dữ liệu
số phức.  Đây là một ví dụ:
 
@example
@group
__complex__ int x = 5 + 17i;
 
printf ("%d  \n", (x * ~x));
@end group
@end example
 
Từ đó phần ảo của số phức @math{(a + bi)} được nhân bằng sự tiếp hợp thì bằng
@math{a^2 + b^2}, câu lệnh @code{printf} phía trên sẽ in ra 314, mà nó lại
bằng với @math{25 + 289}.

@node Toán tử So sánh
@section Toán tử So sánh
@cindex toán tử so sánh
@cindex toán tử, so sánh

Bạn sử dụng toán tử so sánh để mà phân định rõ sự tương quan giữa hai toán
hạng: có phải chúng như nhau, cái này lớn hơn cái kia,
cái này nhỏ hơn cái kia, và cứ thế.   Khi bạn sử dụng bất kỳ toán tử
so sánh nào, kết quả chỉ là 1 hoặc 0, nghĩa là đúng (true) hay sai (false),
một cách tương ứng.

(Trong ví dụ sau đây, biến @code{x} và @code{y} có thể
là hai biểu thức của kiểu số học hay con trỏ.)

Toán tử băng-với @code{==} kiểu tra hai toán hạng của nó về tính ngang bằng.
Kết quả là 1 nếu hai toán hạng bằng nhau và 0 nếu chúng không bằng.

@example
@group
if (x == y)
  puts (``x bằng với y'');
else
  puts (``x không bằng với y'');
@end group
@end example

Toán tử không-bằng @code{!=} kiểm tra sự khác nhau của hai toán hạng.
Kết quả trả về là một nếu hai toán hạng không bằng nhau và không nếu các toán hạng
@emph{là} như nhau.

@example
@group
if (x != y)
  puts (``x không bằng với y'');
else
  puts (``x bằng với y'');
@end group
@end example

Việc so sánh hai giá trị số chấm động theo cách thông thường
có thể tạo ra các kết quả không như mong muốn.  @ref{Kiểu Số Thực} để có
thêm thông tin.

Bạn có thể so sánh con trỏ hàm; quá trình so sánh
cho biết con trỏ có trả về cùng một hàm
hay không.

Ngoài việc so sánh bằng hay không như ở trên, có một số toán tử mà bạn có thể
sử dụng để mà kiểm tra một giá trị có nhỏ hơn, lớn hơn, nhỏ-hơn-hoặc-bằng, hay
lớn-hơn-hoặc-bằng một giá trị khác.  Đây là một số ví dụ mẫu mà nó
đưa ra các ví dụ minh họa về các toán tử này:

@example
@group
if (x < y)
  puts (``x nhỏ hơn y'');
@end group
@end example

@example
@group
if (x <= y)
  puts (``x nhỏ hơn hoặc bằng y'');
@end group
@end example

@example
@group
if (x > y)
  puts (``x lớn hơn y'');
@end group
@end example

@example
@group
if (x >= y)
  puts (``x lớn hơn hoặc bằng y'');
@end group
@end example


@node Toán tử Lô-gíc
@section Toán tử Lô-gíc
@cindex toán tử lô-gíc

Toán tử lô-gíc kiểm tra giá trị chân lý của một cặp toán hạng.  Bất kỳ
biểu thức khác không nào đều coi là đúng (true) trong C, trong khi một biểu thức mà
được ước tính là không sẽ được coi là sai (false).

Toán tử lô-gíc tiếp hợp @code{&&} kiểm tra xem cả hai biểu thức
có cùng đúng không.  Nếu biểu thức thứ nhất là sai, thế thì biểu thức
thứ hai không cần định giá nữa.

@example
@group
if ((x == 5) && (y == 10))
  printf (``x là 5 và y là 10'');
@end group
@end example

Toán tử lô-gíc tiếp hợp @code{||} kiểm tra xem có ít nhất một
trong hai biểu thức là đúng.  Nếu biểu thức thứ nhất là đúng, thế thì
biểu thức thứ hai không cần phải định giá nữa.

@example
@group
if ((x == 5) || (y == 10))
   printf (``x bằng 5 hay y là 10'');
@end group
@end example

Bạn có thể đặt trước một biểu thức lô-gíc một toán tử
phủ định @code{!} để lật ngược giá trị chân lý:

@example
@group
if (!(x == 5))
  printf (``x không là 5'');
@end group
@end example

Vì lẽ rằng toán hạng thứ hai trong cặp biểu thức lô-gíc không cần thiết phải
định giá, bạn có thể viết mã với kết quả có lẽ không trực giác:

@example
@group
if (foo && x++)
  bar();
@end group
@end example

@noindent
Nếu @code{foo} mãi là số không, thế thì không chỉ những hàm @code{bar} không được gọi,
mà @code{x} cũng sẽ không được gia số lên.  Nếu bạn có ý định gia số cho @code{x}
nà không cần biết giá trị của @code{foo} là gì, bạn phải viết biểu thức đó ra ngoài
chỗ toán tử tiếp hợp.


@node Dịch Bít
@section Dịch Bít Bit
@cindex dịch bít bit
@cindex dịch

Bạn có thể sử dụng toán tử dịch-trái @code{<<} để mà dịch chuyển bít của toán hạng
đầu tiên sang phía bên trái.  Toán hạng thứ hai là số vị trí bít cần dịch chuyển.
Các bít được đẩy ra ngoài phía bên trái của giá trị sẽ bị bỏ qua; các bít mối được
thêm vào từ phía bên phải tất cả đều là số không.

@example
@group
x = 47;    /* @r{47 là 00101111 ở dạng nhị phân.} */
x << 1;    /* @r{00101111 << 1 thành 01011110.} */
@end group
@end example

Cũng tương tự như thế, bạn có thể sử dụng toán tử dịch-phải @code{>>} để mà dịch chuyển
các bít của toán hạng thứ nhất sang phải. Số bít tràn ra ngoài cạnh phải
được bỏ đi; các bít mới được thêm vào cạnh trái @emph{thường} là số 0, nhưng
nếu toán hạng thứ nhất là kiểu có dấu, thế thì việc thêm bít sẽ hoặc là
0 @emph{hoặc là} còn phụ thuộc vào giá trị bít ngoài cùng bên
trái trước đó.

@example
@group
x = 47;   /* @r{47 là 00101111 ở dạng nhị phân.} */
x >> 1;   /* @r{00101111 >> 1 thành 00010111.} */
@end group
@end example

Đối với cả hai @code{<<} và @code{>>}, nếu toán hạng thứ hai lớn hơn
độ rộng bít của toán hạng thứ nhất, hay toán hạng thứ hai
kà âm, cách thực hiện là không được định nghĩa.

Bạn có thể sử dụng toán tử dịch để mà thực hiện được nhiều việc thú vị
khác nhau.  Ví dụ như, một ngày mà ngày của nó được coi là số
@code{d}, tháng là @code{m}, và năm là @code{y}, bạn
có thể lưu trữ các mục của ngày tháng này vào trong một số @code{x}:

@example
int d = 12;
int m = 6;
int y = 1983;
int x = ((y << 4) + m) << 5) +  d;
@end example

@noindent
Bạn có thẻ rút trích ngày, tháng và năm từ @code{x}
sử dụng kết hợp toán tử dịch và phép chia lấy phần dư:

@example
d = x % 32;
m = (x >> 5) % 16;
y = x >> 9;
@end example

@node Toán tử Lô-gíc trên Bít
@section Toán tử Lô-gíc trên Bít
@cindex toán tử lô-gíc trên bít
@cindex toán tử lô-gíc, trên bít

C cung cấp các toán tử để thi hành phép hội, phép tuyển không loại,
phép tuyển loại, và phép phủ định (lấy bù).

Phép hội trên bít thực thi trên từng bít tương ứng của hai toán hạng, và khi hai
bít tương ứng đều là 1 thì kết quả là 1.  Tất cả các trường hợp khác
kết quả là 0.  Đây là một ví dụ để thấy được nó hoạt động như thế nào, sử dụng số nhị phân:

@example
11001001 & 10011011 = 10001001
@end example

Phép tuyển không loại trên bít cũng thực hiện trên từng bít của hai toán hạng,
và khi hai bít này đều cùng là 0, bít kết quả sẽ là 0.  Tất cả các trường hợp
khác bít kết quả là 1.

@example
11001001 | 10011011 = 11011011
@end example

Phép tuyển không loại trên bít thực hiện trên từng bít của hai toán hạng, và khi
hai bít tương ứng là khác nhau, bít kết quả là 1.  Tất cả các trường hợp
khác bít kết quả là 0.

@example
11001001 ^ 10011011 = 01010000
@end example

Phép phủ định trên bít đảo ngược từng bít của toán hạng của nó:

@example
~11001001 = 00110110
@end example

Trong ngôn ngữ C, bạn chỉ có thể sử dụng các toán tử này với toán hạng là một kiểu số nguyên
(hay ký tự), và cho dễ thích nghi với các hệ thống khác nhau, bạn nên sử dụng toán tử phủ định trên bít
với kiểu nguyên không dấu.  Đây là một số ví dụ về việc sử dụng các toán tử này trong
mã C:

@example
@group
unsigned int foo = 42;
unsigned int bar = 57;
unsigned int quux;

quux = foo & bar;
quux = foo | bar;
quux = foo ^ bar;
quux = ~foo;
@end group
@end example

@node Toán tử Con trỏ
@section Toán tử Con trỏ
@cindex toán tử con trỏ

Bạn có thể sử dụng toán tử lấy địa chỉ @code{&} để có được địa chỉ bộ nhớ của một
đối tượng.

@example
@group
int x = 5;
int *pointer_to_x = &x;
@end group
@end example

Việc sử dụng toán tử này để lấy được địa chỉ của một hàm là không thực sự
cần thiết, cho dù bạn vẫn có thể làm thế:

@example
@group
extern int foo (void);
int (*fp1) (void) = foo; /* fp1 chỉ đến foo */
int (*fp2) (void) = &foo; /* fp1 cũng chỉ đến foo */
@end group
@end example

Con trỏ hàm và con trỏ dữ liệu là không tương thích nhau, về ý nghĩa
rằng bạn không thể kỳ vọng lưu trữ địa chỉ của một hàm vào vào trong một con trỏ
dữ liệu, và sau đó sao chép nó vào một con trỏ hàm và gọi nó
được.  Nó có thể hoạt động trên một số hệ thống, nhưng nó không tương thích
về mặt kỹ thuật.

Với phân mở rộng GNU C89, bạn cũng còn có thể lấy được địa chỉ của một nhãn
bằng toán tử lấy địa chỉ nhãn @code{&&}.  Kết quả là một con
trỏ @code{void*} mà nó có thể sử dụng với câu lệnh @code{goto}.  @xref{
Câu lệnh goto}.

Với địa chỉ bộ nhớ xác định được lưu trữ trong một con trỏ, bạn có thể sử dụng toán tử
gián tiếp @code{*} để có thể có được giá trị tại địa chỉ. (Đây được gọi là
con trỏ @dfn{tham chiếu}.)

@example
@group
int x = 5;
int y;
int *ptr;

ptr = &x;    /* @r{@code{ptr} bây giờ giữ địa chỉ của @code{x}.} */

y = *ptr;    /* @r{@code{y} lấy giá trị lưu trong địa chỉ}
                @r{được lưu trữ trong @code{ptr}.} */
@end group
@end example

@noindent
Tránh việc sử dụng con trỏ tham chiếu mà nó được khởi tạo vào
một vị trí bộ nhớ không xác định.


@node Toán tử sizeof
@section Toán tử sizeof
@cindex toán tử sizeof

Bạn có thể sử dụng toán tử @code{sizeof} để lấy kích thước (bằng bytes)
của kiểu dữ liệu của toán hạng của nó.  Toán hạng có thể là một kiểu được chỉ
ra, như là @code{int} hay @code{float}), cũng còn có thể là bất kỳ một
biểu thức hợp lệ nào.  Khi toán hạng là tên một kiểu, nó phải được bao trong cặp
dấu ngoặc.  Đây là một số ví dụ:

@example
@group
size_t a = sizeof(int);
size_t b = sizeof(float);
size_t c = sizeof(5);
size_t d = sizeof(5.143);
size_t e = sizeof a;
@end group
@end example

Kết quả trả về từ toán tử @code{sizeof} thì thuộc một kiểu có tên @code{size_t},
mà nó được định nghĩa trong file @code{<stddef.h>}.  @code{size_t} là kiểu
số nguyên không dấu, có lẽ là đồng nhất với @code{unsigned int} hay
@code{unsigned long int}; nó biến đổi phụ thuộc vào từng hệ thống.

Kiểu @code{size_t} là kiểu thường thích hợp cho chỉ số vòng lặp,
vì lẽ rằng nó được đảm bảo rằng có thể giữ số các phần tử trong
một mảng; Điểu này không chỉ đúng với trường hợp kiểu @code{int}, ví dụ.

Toán tử @code{sizeof} có thể sử dụng để tính toán tự động số
phần tử trong một mảng:

@example
@group
#include <stddef.h>
#include <stdio.h>

static const int values[] = @{ 1, 2, 48, 681 @};
#define ARRAYSIZE(x) (sizeof x/sizeof x[0])

int main (int argc, char *argv[]) 
@{
    size_t i;
    for (i = 0; i < ARRAYSIZE(values); i++) 
    @{
        printf("%d\n", values[i]);
    @}
    return 0;
@}
@end group
@end example

Có hai trường hợp mà kỹ thuật này không dùng được.  Đầu tiên là
mảng mà phần tử đầu có kích thước là không (GCC hỗ trợ cấu trúc có
kích-thước-bằng-không đây là phần mở rộng của GNU).  Trường hợp thứ hai là mảng là
tham số cho một hàm (@pxref{Tham số Hàm}).

@node Áp đổi Kiểu
@section Áp đổi Kiểu
@cindex áp đổi kiểu
@cindex áp đổi

Bạn có thể sử dụng áp đổi kiểu để biểu thức trả về kiểu dữ liệu
bạn mong muốn.  Việc áp đổi kiểu bao gồm kiểu được chỉ ra bao quanh bằng cặp dấu ngoặc đơn,
theo sau là một biểu thức.  Để chắc chắn hơn, bạn cũng nên đóng biểu thức
theo sau đó bằng cặp dấu ngoặc đơn.  Đây là một
ví dụ:

@example
@group
float x;
int y = 7;
int z = 3;
x = (float) (y / z);
@end group
@end example

Trong ví dụ đó, vì lẽ @code{y} và @code{z} đều thuộc kiểu nguyên, phép chia
số nguyên sẽ được thực hiện, và thậm chỉ là cho dù @code{x} thuộc kiểu biến
dấu chấm động, nó vẫn nhận về giá trị là 2.  Rõ ràng là việc áp đổi kết quả
phép chia thành @code{float} không tốt, bởi vì việc tính toán
biểu thức @code{y/z} đã là 2 trước rồi.

Để mà sửa lỗi này, bạn cần chuyển đổi kiểu của một trong hai toán hạng
thành kiểu dấu chấm động trước khi đặt phép chia:

@example
@group
float x;
int y = 7;
int z = 3;
x = (y / (float)z);
@end group
@end example

@noindent Ở đây, giá trị đấu chấm động 2.333@dots{} được gán cho @code{x}.

Việc áp đổi kiểu chỉ hoạt động với các kiểu vô hướng (đó là kiểu nguyên,
dấu chấm động hay là con trỏ).  Thành ra, điểu này là không được phép:

@example
@group
struct fooTag @{ /* các thành viên ... */ @};
struct fooTag foo;
unsigned char byteArray[8];

foo = (struct fooType) byteArray; /* @r{Lỗi!} */
@end group
@end example

@node Chỉ số Mảng
@section Chỉ số Mảng
@cindex chỉ số mảng

Bạn có thể truy cập các phần tử của mảng bằng cách chỉ ra tên của mảng, và
chỉ số của mảng (hay còn gọi là chỉ số phụ, số của phần tử) bao quanh bằng dấu ngoặc vuông.  Đây là
một ví dụ, giả sử ta có mảng số nguyên có tên là @code{my_array}:

@example
@group
my_array[0] = 5;
@end group
@end example

Biểu thức chỉ số mảng @code{A[i]} được định nghĩa là
đồng nhất với biểu thức @code{(*((A)+(i)))}.  Điều đó có nghĩa là nhiều
việc sử dụng tên mảng tương đương một biểu thức con trỏ.  Nó cũng
có nghĩa là bạn không thể sử dụng chỉ số mảng để lấy được lớp lưu trữ
@code{register}.

@node Biểu thức từ Gọi Hàm
@section Biểu thức từ Gọi Hàm
@cindex gọi hàm, biểu thức

Một cú gọi hàm mà nó trả về giá trị là một biểu thức.

@example
@group
int function(void);
@dots{}
a = 10 + function();
@end group
@end example


@node Toán tử dấu Phẩy
@section Toán tử dấu Phẩy
@cindex toán tử dấu phẩy

Bạn sử dụng toán tử dấu phẩy @code{,} để mà ngăn cách (về mặt hình thức bề ngoài) hai biểu thức.
Cụ thể, biểu thức thứ nhất có lẽ sinh ra một giá trị mà nó được sử dụng bởi biểu thức
thứ hai:
@c This works because there is a sequence point after the evaluation
@c of the left hand side.
@example
@group
x++, y = x * x;
@end group
@end example

Thông thường nhất, toán tử dấu phẩy được sử dụng trong câu lệnh @code{for}, giống như
thế này:

@example
@group
/* @r{toán tử dấu phẩy được sử dụng trong câu lệnh @code{for}.} */

for (x = 1, y = 10;  x <=10 && y >=1;  x++, y--)
  @{
    @dots{}
  @}
@end group
@end example

@noindent
Điểu này là thuật tiện cho việc đặt, theo dõi, và chỉnh sửa nhiều biểu thức
cho một câu lệnh @code{for}.

Dấu phẩy cũng được sử dụng để ngăn cách các tham số của hàm; tuy nhiên điều đó
thì @emph{không} thực hiện việc tính toán cho toán tử dấu phẩy.   Trên thực tế, nếu toán
tử dấu phẩy được sử dụng như ta nói ở đây trong một cú gọi hàm, thế thì
trình dịch sẽ
biên dịch là cú gọi hàm này có tham số mở rộng.

Nếu bạn muốn sử dụng toán tử dấu phẩy trong một tham số của hàm, bạn cần
đặt dấu ngoặc đơn bao quanh nó.  Đó là bởi vì dấu phẩy trong một danh sách tham số
của hàm có nghĩa khác: chúng ngăn cách các tham số.
Như vậy,

@example
foo (x,  y=47,  x,  z);
@end example

@noindent
được biên dịch như là một hàm có bốn tham số, nhưng

@example
foo (x,  (y=47,  x),  z);
@end example

@noindent
chỉ là cú gọi hàm có ba tham số.  (Tham số thứ hai là
@code{(y=47, x)}.)

@node Biểu thức Truy cập Thành viên
@section Biểu thức Truy cập Thành viên
@cindex biểu thức truy cập thành viên

Bạn có thể sử dụng toán tử truy cập thành viên @code{.} để mà truy cập các
thành viên của một biến cấu trúc hay tập hợp.  Bạn đặt tên của biến cấu trúc
hay tập hợp bên trái của toán tử, và tên của thành viên
ở bên phải.

@example
@group
struct point
@{
  int x, y;
@};

struct point first_point;

first_point.x = 0;
first_point.y = 5;
@end group
@end example

@cindex toán tử truy cập thành viên gián tiếp
Bạn cũng còn có thể truy cập các thành viên của một biến cấu trúc hay tập hợp
thông quan một con trỏ sử dụng toán tử truy cập thành viên gián tiếp @code{->}.
@code{x->y} là tương đương với @code{(*x).y}.

@example
@group
struct fish
  @{
    int length, weight;
  @};

struct fish salmon;

struct fish *fish_pointer = &salmon;

fish_pointer->length = 3;
fish_pointer->weight = 9;
@end group
@end example 

@xref{Con trỏ}.


@node Biểu thức Điều kiện
@section Biểu thức Điều kiện
@cindex biểu thức điều kiện
@cindex biểu thức, điều kiện
@cindex toán tử bộ ba

Bạn sử dụng toán tử điều kiện để tạo biểu thức điều kiện mà nó
được định giá bằng biểu thức thứ hai hay thứ ba, trên cơ sở
giá trị chân lý của toán hạng thứ nhất của nó.  Đây là một ví dụ:

@example
a ? b : c
@end example

Nếu biểu thức @code{a} là đúng, thế thì biểu thức @code{b} được định giá
và kết quả là giá trị của @code{b}.  Nếu không thế, biểu thức
@code{c} được định giá và kết quả sẽ là @code{c}.  

Biểu thức @code{b} và @code{c} phải tương thích nhau.   Tức là, chúng
phải cùng kiểu 

@enumerate
@item kiểu số học
@item kiểu @code{struct} hay @code{union} tương đương nhau
@item con trỏ đến cùng kiểu (một trong số chúng có thể là con trỏ NULL)
@end enumerate 

Cách khác, một toán hạng là một con trỏ còn con trỏ còn lại
là con trỏ @code{void*}.

Đây là ví dụ:

@example
a = (x == 5) ? y : z;
@end example

Ở đây, nếu @code{x} bằng 5, thế thì @code{a} sẽ nhận giá trị
từ @code{y}.  Nếu không, @code{a} sẽ nhận giá trị từ
@code{z}.  Cách viết này nên được cân nhắc sử dụng trong trường hợp
câu lệnh @code{if}@dots{}@code{else} ở dạng đơn giản.  Ví dụ theo sau đây sẽ
thực hiện đúng các công việc như ví dụ trước:

@example
@group
if (x == 5)
    a = y;
else
    a = z;
@end group
@end example

Nếu toán hạng thứ nhất của toán tử điều kiện là đúng, thế thì toán hạng
thứ ba không bao giờ được định giá.  Cũng tương tự như thế, nếu toán hạng
thứ nhất là sai thế thì toán hạng thứ hai sẽ không bao giờ được định giá.
Toán hạng thứ nhất luôn luôn được định giá.


@c GNU C Extension

@node Câu lệnh và Khai báo trong Biểu thức
@section Câu lệnh và Khai báo trong Biểu thức
@cindex câu lệnh trong biểu thức
@cindex khai báo trong biểu thức
@cindex biểu thức chứa câu lệnh
@cindex macros, câu lệnh trong biểu

Là phần mở rộng của GNU C, bạn có thể xây dựng một biểu thức sử dụng
tổ hợp các câu lệnh bao quanh chúng bằng cặp dấu ngoặc đơn.  Điều này cho phép bạn gộp các
vòng lặp, câu lệnh switch, và các biến nội bộ bên trong một biểu thức.

Nhắc lại rằng một câu lệnh phức (cũng được biết với cái tên khối lệnh) là một chuỗi
các câu lệnh bao quanh bởi dấu ngoặc nhọn.  Trong cấu trúc này, dấu ngoặc đơn bao quanh
dấu ngoặc nhọn.  Đây là một ví dụ:

@example
@group
(@{ int y = function (); int z;
    if (y > 0) z = y;
   else z = - y;
   z; @})
@end group
@end example

Điều này là biểu thức hợp lệ (dẫu cho nó hơi phức tạp hơn mức cần thiết)
cho giá trị tuyệt đối của @code{function ()}.

Điều cuối cùng về câu lệnh phức là nó có thể là một biểu thức
theo sau bởi dấu chấm phẩy; giá trị của biểu thức con này được phục vụ như là giá trị
của toàn bộ cấu trúc.  (Nếu bạn sử dụng một số kiểu câu lệnh
ở cuối phía trong cặp ngoặc nhọn, cấu trúc sẽ là kiểu @code{void}, và như vậy
không quả là không có giá trị.)

Đặc tính này đặc biệt hữu dụng trong việc tạo nên macro được định nghĩa một cách  ``an toàn'' (như thế
chúng sẽ được định giá chính xác từ toán hạng một).  Ví dụ,
hàm ``maximum'' thông thường được định nghĩa là một macro trong C chuẩn như
sau:

@example
#define max(a,b) ((a) > (b) ? (a) : (b))
@end example

@noindent
@cindex side effects, tham số macro
Nhưng định nghĩa này mỗi @code{a} hoặc @code{b} được tính toán hai lần, trường
hợp kết quả xấu nhất nếu như toán hạng có side effects.  Trong GNU C, nếu bạn biết
kiểu của các toán hạng (ở đây hãy giả sử là @code{int}), bạn có thể định nghĩa
macro một cách an toàn theo các sau:

@example
#define maxint(a,b) \
  (@{int _a = (a), _b = (b); _a > _b ? _a : _b; @})
@end example

Nếu bạn không biết kiểu của toán hạng, bạn vẫn có thể làm như thế, nhưng bạn
phải sử dụng biểu thức @code{typeof} hay gõ tên kiểu.

@comment Add reference to typeof

Các câu lệnh nhúng là không được phép trong các biểu thức hằng, như là
giá trị của một hằng liệt kê, độ rộng của trường bít, hay
giá trị ban dầu của biến tĩnh.


@node Quyền ưu tiên của Toán tử
@section Quyền ưu tiên của Toán tử trong C
@cindex quyền ưu tiên của toán tử
@cindex quyền ưu tiên, toán tử

Khi một biểu thức có chứa nhiều toán tử, như là @code{a + b *
f()}, các toán tử được nhóm lại trên cơ sở là quy tắc của @dfn{quyền ưu tiên}.
Cụ thể, trong biểu thức trên cú gọi hàm
@code{f} không tham số được gọi, nhân kết quả với @code{b}, sau đó cộng
kết quả đó với @code{a}.  Đấy là những gì mà quy tắc quyền ưu tiên của C
phân giải cho biểu thức này.

Sau đây là danh sách các kiểu biểu thức, trình bày theo thứ tự
các biểu thức có quyền ưu tiên cao nhất đặt đầu tiên.  Đôi chỗ có hai hay nhiều hơn là
cùng mức ưu tiên; tất cả các toán tử đó được liệt kê từ trái sang phải
trừ trường hợp được mô tả khác đi.

@enumerate

@item
Các biểu thức gọi hàm, chỉ số mảng, và toán tử
truy cập thành viên.

@item
Các biểu thức trên toán tử một ngôi, bao gồm toán tử lô-gíc phủ định, bù bít,
gia, giảm, unary positive, phủ định một ngôi, toán tử
gián tiếp, toán tử địa chỉ, áp đổi kiểu, và toán tử
@code{sizeof}.  Khi có nhiều toán tử một ngôi liên tiếp,
cái sau được nằm trong cái nằm trước: @code{!-x}
có nghĩa là @code{!(-x)}.

@item
Biểu thức nhân, chia và phép chia lấy phần dư.

@item
Biểu thức cộng và trừ.

@item
Biểu thức dịch bít.

@item
Biểu thức lớn-hơn, nhỏ-hơn, lớn-hơn-hoặc-bằng, và
nhỏ-hơn-hoặc-băng-với@*.

@item
Biểu thức bằng-với và không-bằng-với.

@item
Biểu thức AND trên bít.

@item
Biểu thức OR loại trừ trên bít.

@item
Biểu thức OR không loại trừ trên bít.

@item
Biểu thức lô-gíc AND.

@item
Biểu thức lô-gíc OR.

@item
Các biểu thức điều kiện (sử dụng @code{?:}).  Khi sử dụng như là
một biểu thức con, chúng được ước tính từ phải sang trái.

@item
Tất cả các biểu thức gán, bao gồm cả gán phức.  Khi có nhiều
lệnh gán xuất hiện như một biểu thức con trong một biểu thức lớn,
chúng được định giá từ phải sang trái.

@item
Biểu thức dấu phẩy.

@end enumerate

@c ??? Lots more examples are needed here!

@c ??? You need to explain when parentheses are strongly
@c recommended in order to make the structure clear.

Danh sách ở trên là dễ hiểu và có vẻ không rắc rối, nhưng
nó tiềm ẩn rất nhiều cạm bẫy.  Xem ví dụ này:

@example
foo = *p++;
@end example

Ở đây @code{p} được gia lên như là hiệu ứng side effect của biểu thức, nhưng
@code{foo} lấy giá trị của @code{*(p++)} thay vì @code{(*p)++},
bởi lẽ toán tử một ngôi thực hiện từ phải sang trái.   Có nhiều ví dụ
khác đáng ngạc nhiên về tiềm lực ẩn dấu sau bảng ưu tiên của
C.  Vì lý do này, nếu có những nguy cơ gây nên sự hiểu lầm
về nghĩa của chương trình cho người đọc, bạn nên sử dụng
dấu ngoặc để làm cho nghĩa được sáng sủa hơn.

@node Thứ tự Định giá
@section Thứ tự Định giá

Trong ngôn ngữ C bạn không thể nhận định rằng các câu lệnh con được định giá
theo thứ tự tự nhiên.  Chẳng hạn như, hãy xem xét biểu thức
@code{++a * f()}.  Nó gia số @code{a} trước hay sau
cú gọi hàm @code{f}?  Trình dịch có thể làm điều này trong cả hai
thứ tự, vì thế bạn không thể đưa ra giả thuyết được.

Quyển sổ tay này giải thích tóm tắt về mặt ngữ nghĩa của ngôn ngữ C.
Tuy nhiên, một trình dịch thực tế dịch mã nguồn thành những hành động
riêng biệt trong một máy tính riêng biệt, và có thể thay đổi các toán tử
vì mục đính nâng cao hiệu suất.  Sự tương thích giữa chương trình bạn viết
và những thứ mà máy tính thực tế thực hiện được chỉ rõ trong các mục của
@emph{side effects} và @emph{sequence points}.

@menu
* Side Effects::
* Sequence Points::
* Biểu thức Yêu cầu Sequence Points::
* Sequence Points và Phân phối Tín hiệu::
@end menu

@node Side Effects
@subsection Side Effects

@cindex side effect
A @dfn{side effect} là một trong số sau:
@enumerate
@item truy cập đối tượng kiểu @code{volatile}
@item sửa một đối tượng
@item sửa một file
@item gọi một hàm mà nó thực hiện một hành vi ở trên
@end enumerate

Về cơ bản, có những hiệu ứng bên ngoài có thể thấy được trong quá trình chạy
một chương trình.  Chúng được gọi là side effects bởi vì chúng tác động đến
sự định giá biểu thức ngoài giá trị thực tế được biểu thức trả về.

Trình dịch cho phép thực hiện thao tác của chương trình của bạn trong
một thứ tự khác với thứ tự mặc nhiên của mã nguồn của bạn,
miễn là ở cuối tất cả các cần thiết side effects thực sự nắm giữ
nhiệm vụ. Trình dịch cũng còn cho phép bỏ qua hoàn toàn một số thao tác;
ví dụ như nó cho phép bỏ qua phần định giá của một biểu thức nếu như
nó có thể chắc chắn rằng giá trị đó không được sử dụng và việc định giá phần đó của
biểu thức không sản sinh ra cái gì cần thiết cho side effects.

@node Sequence Points
@subsection Sequence Points

Điều yêu cầu khác với trình dịch là side effects cần được đặt
tại vị trí trong một thứ tự đúng đắn.  Cốt để mà cung cấp cho nó mà không cần
quan tâm đến sự ràng buộc của trình dịch, chuẩn C89 và C90 đưa ra danh sách
sequence points.  Một @dfn{sequence point} là một trong số
sau:

@cindex sequence point
@enumerate
@c authority: C99 standard, annex C
@item gọi một hàm (sau khi việc định giá tham số hoàn tất)
@item tại cuối của toán hạng phía tay-trái của toán tử and @code{&&}
@item tại cuối của toán hạng phía tay-trái của toán tử or @code{||}
@item tại cuối của toán hạng phía tay-trái của toán tử dấu phẩy @code{,}
@item tại cuối của toán hạng đầu tiên của toán tử tam nguyên @code{a ? b : c}
@item tại cuối của một khai báo đầy đủ
@footnote{một khai báo đầy đủ là một khai báo của một hàm hay một đối tượng mà nó không phải là một bộ phận của một đối tượng khác}
@item tại cuối của một biểu thức khởi tạo
@item tại cuối của một câu lệnh biểu thức (ví dụ một biểu thức theo sau bởi @code{;})
@item tại cuối của biểu thức điều khiển của câu lệnh @code{if} hay @code{switch}
@item tại cuối của biểu thức điều khiển của câu lệnh @code{while} hay @code{do}
@item tại cuối của từng trong ba biểu thức điều khiển của câu lệnh @code{for}
@item tại cuối của biểu thức trong một câu lệnh return
@item ngay trước khi việc return của một hàm từ thư viện
@item sau tác động liên kết với một mục có định dạng I/O (như
sử dụng ví dụ với các hàm thuộc họ @code{strftime} hay @code{printf} và
@code{scanf}).
@item ngay trước hay sau cú gọi hàm so sánh (như cú
gọi bởi @code{qsort})
@end enumerate

@c authority: C99 standard, section 5.1.2.3
Tại sequence point, tất cả các side effects của việc định giá biểu thức
trước đó phải được hoàn thiện, và không có side effects của sự định giá kế sau
được dành chỗ.

@c authority: C89 standard, section 5.1.2.3
@c this description was not included in C99, I assume because of the 
@c introduction of whole-program optimisation
Điều này dường như hơi khó mà hiểu thấu đáo được, nhưng không còn cách nào khác để
xem xét vấn đề này nữa.  Hình dung là bạn đã viết một thư viện (một số hàm của nó
là cho bên ngoài dùng, và một số khác lại không thế) và dịch nó, cho phép
một người nào đó gọi một hàm của bạn từ mã nguồn của họ.  Các định nghĩa
trên cần được đảm bảo rằng, tại lúc mà họ gọi hàm của bạn, dữ liệu họ chuyển qua
cho hàm phải có giá trị mà nó phải phù hợp với hành vi ứng xử đã chỉ định
bởi máy trừu tượng (abstract machine), và bất kỳ dữ liệu nào trả về từ hàm của bạn phải
ở trạng thái mà nó cũng phù hợp với máy trừu tượng (abstract machine).  Điều này
bao gồm việc truy cập dữ liệu thông qua con trỏ (ví dụ không chỉ tham số
hàm và các định danh với liên kết ra ngoài).

Những mô tả ở trên chỉ là sự giải thích sơ sài, vì lẽ rằng các trình dịch hiện có
thực hiện việc tối ưu hóa toàn bộ chương trình tại thời điểm liên kết (link).  Tuy nhiên điều sau mới là trọng yếu nhất,
mặc dù chúng có lẽ sẽ thực hiện việc tối ưu hóa, nhưng các  side effects có thể thấy được của
chương trình phải không phụ thuộc vào phần cứng của
máy tính.

@node Biểu thức Yêu cầu Sequence Points
@subsection Biểu Yêu cầu Sequence Points

@c authority: C89 section 6.3, C99 section 6.5
Đoạn mã
@example
i = i + 1;
@end example 
là hoàn toàn bình thường và thường hay xuất hiện trong mọi chương trình.  Tuy nhiên,
đoạn mã gần giống như vậy
@example
i = ++i + 1;
@end example 
thì khó mà hiểu được; giá trị cuối cùng của @code{i} là bao nhiêu?
Chuẩn C (cả C89 và C99) đều ngăn cấm cấu trúc này trong
chương trình chuẩn.  

Giữa hai sequence points, 
@enumerate
@item một đối tượng có lẽ có giá trị lưu trữ được sửa tại tối đa một lần bởi
sự định giá của một biểu thức
@item giá trị tiên nhiệm của đối tượng sẽ được đọc chỉ để xác định
giá trị mà nó lưu giữ.
@end enumerate

Biểu thức bị cấm chỉ trong số hai cái là các biểu thức giống như thế này
@code{foo(x=2, ++x)}.  Cái thứ hai bị cấm chỉ các biểu thức như
@code{a[i++] = i}.

@c with an appropriate list of counterexamples such as f(x++, x++).

@table @code
@item int x=0; foo(++x, ++x)
Không cho phép trong một chương trình chuẩn; việc can thiệp @code{x} hai lần trước khi
tham số được định giá xong. 
@item int x=0; bar((++x,++x))
Được phép; hàm @code{bar} lấy một tham số (giá trị 2
được chuyển qua ở đây), và đây là một sequence point tại vị trí toán tử dấu phẩy.
@item *p++ || *p++
Được phép; đây là một sequence point ở @code{||}.
@item int x = 1, y = x++;
Được phép; đây là một sequence point sau quá trình khai báo @code{x}.
@item x=2; x++;
Được phép; đây là một sequence point tại cuối của biểu thức câu lệnh
đầu tiên.
@item if (x++ > MAX) x = 0;
Được phép; đây là một sequence point tại cuối của biểu thức
điều khiển của @code{if}@footnote{Tuy nhiên nếu ví dụ @code{MAX} là
@code{INT_MAX} và @code{x} là kiểu @code{int}, chúng ta rõ ràng gặp
vấn đề với tràn.  @xref{Tràn}.}.
@item (x=y) ? ++x : x--;
Được phép; đây là một sequence point trước @code{?}, và chỉ một
trong hai biểu thức theo sau được lượng giá.
@item int *p=malloc(sizeof(*p)), *q=p;  *p=foo(); bar((*p)++,(*q)++);
Không được phép; đối tượng tại @code{p} bị chỉnh sửa hai lần
trước khi việc định giá của tham số cho @code{bar} được hoàn tất.
Thực tế mà chúng làm là một cái thông qua @code{p} và một thông qua @code{q} là
không phù hợp, vì lẽ đó chúng đều cùng chỉ tới một đối tượng.
@end table

Hãy quay trở lại ví dụ mà chúng tôi đã sử dụng để giới thiệu vấn đề về
thứ tự định giá, @code{++a * f()}.   Giả sử mã nguồn trên thực tế
giống như thế này:

@example
@group
static int a = 1;

static int f (void)
@{
  a = 100;
  return 3;
@}

int foo (void)
@{
   return ++a * f();
@}
@end group
@end example

Mã như thế này có được phép trong chuẩn viết chương trình không?  Mặc dù
biểu thức trong @code{foo} sửa @code{a} hai lần, đây cũng chẳng phải
là vấn đề gì cả.  Hãy xem xét hai trường hợp có thể xảy ra.

@table @asis
@item Toán hạng phải @code{f()} được định giá trước
Vì rằng @code{f} trả về một giá trị khác void, nó phải chứa một câu
lệnh @code{return}.   Do đó, ở đây có một sequence point tại vị trí
cuối của biểu thức return.  Nó đến giữa quá trình can thiệp
@code{a} mà @code{f} thực hiện và quá trình định giá của toán hạng bên trái.
@item Toán hạng trái @code{++a} được định giá trước
Trước tiên, @code{a} được gia lên.   Sau đó tham số của @code{f}
được định giá (ở đây không có).  Thế thì ở đây có một sequence point
trước khi @code{f} thực tế được gọi.
@end table

@c C99 does not state explicitly that there is a sequence point after
@c argument evaluation if a function call contains zero arguments.
Như vậy, chúng ta thấy rằng chương trình của chúng ta là hợp-chuẩn.  Chú ý rằng
tham số trên không thực sự phụ thuộc vào chi tiết của thân
hàm @code{f}.  Nó chỉ phụ thuộc vào hàm đó chứa một phần kết
ra sao tại sequence point -- trong ví dụ của chúng ta đây là
một câu lệnh return, nhưng một câu lệnh biểu thức hay một khai báo đầy đủ
cũng tốt.

@cindex cách thực hiện không được nói rõ
Tuy nhiên, kết quả sau thực thi của đoạn mã này phụ thuộc vào thứ tự
của việc định giá của toán hạng @code{*}.  Nếu toán hạng ở phía tay-trái
được định giá trước, @code{foo} trả về 6.  Nếu không, nó sẽ trả về 303.
Chuẩn C không chỉ rõ thứ tự của toán hạng sẽ được
định giá, và cũng không yêu cầu một sự bổ xung hoặc là
cung cấp tư liệu hay là ngay cả quy định một thứ tự.  Kết quả của
đoạn mã này là @dfn{không được chỉ rõ}, nghĩa là nó là một trong nhiều
khả năng sẽ xảy ra, nhưng chuẩn C không nói là cái nào.



@node Sequence Points và Phân phối Tín hiệu
@subsection Sequence Points và Phân phối Tín hiệu

Các tín hiệu thì được cung cấp tư liệu chủ yếu từ sổ tay thư viện GNU C hơn
tài liệu này, thậm chí chuẩn C xem trình dịch và thư
viện C cùng nhau để ``thực hiện''.

@c [This scene-setting is probably too long. - jay@gnu.org]
@c
@c Your C program can be notified of asynchronous events by the
@c @dfn{signal} mechanism.  There are a few dozen different possible
@c signals; these include for example @code{SIGINT}, which tells your
@c program that the user pressed the keyboard interrupt key, and
@c @code{SIGFPE} which tells your program that an arithmetic overflow has
@c occurred.  Signals can be asyncronous, for example @code{SIGINT}
@c generally arises outside your program, or normally synchronous like
@c @code{SIGFPE} or @code{SIGABRT} (which indicates your program called
@c the @code{abort} function, directly or indirectly).  Signals can also
@c be sent using the @code{kill} and @code{raise} functions.
@c 
@c All signals have a default effect, usually to terminate the program.
@c However, you can set up a @dfn{signal handler} -- a funciton to be
@c called when a specified signal is delivered.


Khi tín hiệu được nhận về, nó sẽ xảy đến giữa các sequence points.
Side effects trên đối tượng @code{volatile} tiên nhiệm tới sequence point
trước đó sẽ xuất hiện, nhưng các cập nhật khác có lẽ không xảy ra.
Nó thậm chí áp dụng để gán thẳng, như là @code{x=0;},
bởi vì đoạn mã được phát sinh cho câu lệnh đó có lẽ yêu cầu hơn một
chỉ lệnh, nghĩa là nó có thể bị ngắt giữ-chừng
bởi sự phân phối của một tín hiệu.

Chuẩn C thì hơi hạn chế về việc truy cập dữ liệu nào có thể xảy ra
trong một đoạn chương trình xử lý tín hiệu.  Chúng có thể dĩ nhiên đã sử dụng biến
@code{auto}, nhưng theo điều kiện về đọc hay ghi các đối tượng khác, chúng phải
là @code{volatile sig_atomic_t}.  Từ hạn định kiểu @code{volatile}
đảm bảo việc truy cập biến ở một bộ phận khác của chương trình
không nối đến một sequence points và việc sử dụng kiểu @code{sig_atomic_t}
để đảm bảo rằng các thay đổi cho biến là hạt nhân bằng lưu ý đến
phân phối tín hiệu.

Chuẩn POSIX cũng cho phép sử dụng một lượng nhỏ các thư viện hàm để mà
gọi từ đoạn chương trình xử lý tín hiệu.  Những hàm này được coi như là
một tập hợp các hàm @dfn{async-signal-safe}.  Nếu chương trình của bạn
có ý định chạy trên hệ thống POSIX nhưng không trên các hệ thống khác, bạn có thể
gọi chúng từ đoạn chương trình xử lý tín hiệu của mình một cách an toàn.

@node Tràn
@section Tràn

@include overflow.texi

