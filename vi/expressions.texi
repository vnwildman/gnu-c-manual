@c ??? It might be a good idea to turn each example of an expression
@c into a small program that prints output and thus shows what
@c the expression does.

@c This is part of The GNU C Reference Manual
@c Copyright (C) 2007-2011 Free Software Foundation, Inc.
@c See the file gnu-c-manual.texi for copying conditions.

@node Biểu thức và Toán tử
@chapter Biểu thức và Toán tử

@menu
* Biểu thức::
* Assignment Toán tử::
* Incrementing and Decrementing::
* Arithmetic Toán tử::
* Complex Conjugation::
* Comparison Toán tử::
* Logical Toán tử::
* Bit Shifting::
* Bitwise Logical Toán tử::
* Pointer Toán tử::
* The sizeof Operator::
* Type Casts::
* Array Subscripts::
* Function Calls as Biểu thức::
* The Comma Operator::
* Member Access Biểu thức::
* Conditional Biểu thức::
* Statements and Declarations in Biểu thức::
* Operator Precedence::
* Order of Evaluation::
* Overflow::
@end menu

@node Biểu thức
@section Biểu thức
@cindex expressions

An @dfn{expression} consists of at least one operand and zero or more
toán tử.  Operands typed objects such as constants, variables, and
function calls that return values.  Here are some examples:

@example
@group
47
2 + 2
cosine(3.14159) /* @r{We presume this returns a floating point value.} */
@end group
@end example

Parentheses group subexpressions:

@example
( 2 * ( ( 3 + 10 ) - ( 2 * 6 ) ) )
@end example

@noindent
Innermost expressions are evaluated first.  In the above example,
@code{3 + 10} and @code{2 * 6} evaluate to @code{13} and @code{12},
respectively.  Then @code{12} is subtracted
from @code{13}, resulting in @code{1}.  Finally, @code{1} is multiplied by
@code{2}, resulting in @code{2}.  The outermost parentheses are completely
optional.

@cindex toán tử

An @dfn{operator} specifies an operation to be performed on its operand(s).
Toán tử may have one, two, or three operands, depending on the operator.

@node Assignment Toán tử
@section Assignment Toán tử
@cindex assignment toán tử
@cindex toán tử, assignment

Assignment toán tử store values in variables.  C provides several
variations of assignment toán tử.

The standard assignment operator @code{=} simply stores the value of its
right operand in the variable specified by its left operand.  As with
all assignment toán tử, the left operand (commonly referred to as the
``lvalue'') cannot be a literal or constant value.

@example
@group
int x = 10;
float y = 45.12 + 2.0;
int z = (2 * (3 + function () ));

struct foo @{
  int bar;
  int baz;
@} quux = @{3, 4, 5@};
@end group
@end example

@noindent
Note that, unlike the other assignment toán tử described below, you
can use the plain assignment operator to store values of a structure
type.

Compound assignment toán tử perform an operation involving
both the left and right operands, and then assign the resulting
expression to the left operand.  Here is a list of the compound
assignment toán tử, and a brief description of what they do:

@itemize

@item
@code{+=}

Adds the two operands together, and then assign the result of
the addition to the left operand.

@item
@code{-=}

Subtract the right operand from the left operand, and
then assign the result of the subtraction to the left operand.

@item
@code{*=}

Multiply the two operands together, and then assign the
result of the multiplication to the left operand.

@item
@code{/=}

Divide the left operand by the right operand, and assign
the result of the division to the left operand.

@item
@code{%=}

Perform modular division on the two operands, and assign the
result of the division to the left operand.

@item
@code{<<=}

Perform a left shift operation on the left operand, shifting
by the number of bits specified by the right operand, and assign the
result of the shift to the left operand.

@item
@code{>>=}

Perform a right shift operation on the left operand,
shifting by the number of bits specified by the right operand, and assign
the result of the shift to the left operand.

@item
@code{&=}

Perform a bitwise conjunction operation on the two operands, and
assign the result of the operation to the left operand.

@item
@code{^=}

Performs a bitwise exclusive disjunction operation on the two operands,
and assign the result of the operation to the left operand.

@item
@code{|=}

Performs a bitwise inclusive disjunction operation on the two
operands, and assign the result of the operation to the left operand.

@end itemize
@comment  __End of compound assignment operator list

Here is an example of using one of the compound assignment toán tử:

@example
x += y;
@end example

@noindent
Since there are no side effects wrought by evaluating the variable
@code{x} asn an lvalue, the above code produces the same result as:

@example
x = x + y;
@end example


@c GNU C Extension -- temporarily commented out for manual 0.1
@c @node Generalized Lvalues
@c @subsubsection Generalized Lvalues
@c @cindex compound expressions as lvalues
@c @cindex expressions, compound, as lvalues
@c @cindex conditional expressions as lvalues
@c index expressions, conditional, as lvalues
@c @cindex casts as lvalues
@c @cindex generalized lvalues
@c @cindex lvalues, generalized
@c @cindex extensions, @code{?:}
@c @cindex @code{?:} extensions
@c 
@c Compound expressions, conditional expressions and casts are allowed as
@c lvalues provided their operands are lvalues.  This means that you can take
@c their addresses or store values into them.
@c 
@c For example, you can assign a value to a compound expression, provided the
@c last expression in the sequence is an lvalue.  These two expressions are
@c equivalent:
@c 
@c @example
@c (a, b) += 5
@c a, (b += 5)
@c @end example
@c 
@c Similarly, you can take the address of a compound expression.  So, these two
@c expressions are equivalent:
@c 
@c @example
@c &(a, b)
@c a, &b
@c @end example
@c 
@c A conditional expression is a valid lvalue if its type is not void and if
@c both the second and third operands are valid lvalues.  For example, these two
@c expressions are equivalent:
@c 
@c @example
@c (a ? b : c) = 5
@c (a ? b = 5 : (c = 5))
@c @end example
@c 
@c A type cast is a valid lvalue if its operand is an lvalue.  A simple
@c assignment whose left-hand side is a cast works by converting the
@c right-hand side first to the specified type, then to the type of the
@c inner left-hand side expression.  After this is stored, the value is
@c converted back to the specified type to become the value of the
@c assignment.  Thus, if @code{a} has type @code{char *}, the following two
@c expressions are equivalent:
@c 
@c @example
@c (int)a = 5
@c (int)(a = (char *)(int)5)
@c @end example
@c 
@c An assignment-with-arithmetic operation such as @code{+=} applied to a cast
@c performs the arithmetic using the type resulting from the cast, and then
@c continues as in the previous case.  Therefore, these two expressions are
@c equivalent:
@c 
@c @example
@c (int)a += 5
@c (int)(a = (char *)(int) ((int)a + 5))
@c @end example

@c You cannot take the address of an lvalue cast, because the use of its
@c address would not work out coherently.  Suppose that @code{&(int)f} were
@c permitted, where @code{f} has type @code{float}.  Then the following
@c statement would try to store an integer bit-pattern where a floating
@c point number belongs:
@c 
@c @example
@c *&(int)f = 1;
@c @end example
@c 
@c This is quite different from what @code{(int)f = 1} would do---that
@c would convert 1 to floating point and store it.  Rather than cause this
@c inconsistency, we think it is better to prohibit use of @code{&} on a cast.
@c 
@c If you really do want an @code{int *} pointer with the address of
@c @code{f}, you can simply write @code{(int *)&f}.

@node Incrementing and Decrementing
@section Incrementing and Decrementing
@cindex increment operator
@cindex decrement operator
@cindex operator, increment
@cindex operator, decrement

The increment operator @code{++} adds 1 to its operand.  The operand must
be a either a variable of one of the primitive data types, a pointer, or an
enumeration variable.  You can apply the increment operator either before or after
the operand.  Here are some examples:

@example
@group
char w = '1';
int x = 5;
char y = 'B';
float z = 5.2;
int *p = &x;

x++;   /* @r{@code{x} is now 6.} */
++y;   /* @r{@code{y} is now `C' (on ASCII systems).} */
++w;   /* @r{@code{y} is now the character `2' (not the value 2).} */
z++;   /* @r{@code{z} is now 6.2.} */
++p;   /* @r{@code{p} is now @code{&x} + @code{sizeof(int)}.} */
@end group
@end example

@noindent
(Note that incrementing a pointer only makes sense if you have reason to believe
that the new pointer value will be a valid memory address.)

A prefix increment adds 1 before the operand is evaluated.  A postfix
increment adds 1 after the operand is evaluated.  In the previous
examples, changing the position of the operator would make no difference.
However, there are cases where it does make a difference:

@example
@group
int x = 5;
printf ("%d \n", x++);    /* @r{Print @code{x} and then increment it.} */
/* @r{@code{x} is now equal to 6.} */
printf ("%d \n", ++x);    /* @r{Increment @code{x} and then print it.} */
@end group
@end example

@noindent
The output of the above example is:

@example
@group
5
7
@end group
@end example

Likewise, you can subtract 1 from an operand using the decrement operator:

@example
@group
int x = 5;

x--; /* @r{@code{x} is now 4.} */
@end group
@end example

@noindent
The concepts of prefix and postfix application apply here as with the
increment operator.

@node Arithmetic Toán tử
@section Arithmetic Toán tử
@cindex arithmetic toán tử
@cindex toán tử, arithmetic

C provides toán tử for standard arithmetic operations: addition, subtraction,
multiplication, and division, along with modular division and negation.  Usage
of these toán tử is straightforward; here are some examples:

@example
@group
/* @r{Addition.} */
x = 5 + 3;
y = 10.23 + 37.332;
quux_pointer = foo_pointer + bar_pointer;
@end group
@end example

@example
@group
/* @r{Subtraction.} */
x = 5 - 3;
y = 57.223 - 10.903;
quux_pointer = foo_pointer - bar_pointer;
@end group
@end example

@noindent
You can add and subtract memory pointers, but you cannot multiply
or divide them.

@example
@group
/* @r{Multiplication.} */
x = 5 * 3;
y = 47.4 * 1.001;
@end group
@end example

@example
@group
/* @r{Division.} */
x = 5 / 3;
y = 940.0 / 20.2;
@end group
@end example

@noindent
Integer division of positive values truncates towards zero, so 5/3 is
1.  However, if either operand is negative, the direction of rounding
is implementation-defined.  @ref{Signed Integer Division} for
information about overflow in signed integer division.

@c We should state how GCC behaves if an operand is negative.


You use the modulus operator @code{%} to obtain the remainder produced
by dividing its two operands.  You put the operands on either side of
the operator, and it does matter which operand goes on which
side:  @code{3 % 5} and @code{5 % 3} do not have the same result.
The operands must be expressions of a primitive data type.

@example
@group
/* @r{Modular division.} */
x = 5 % 3;
y = 74 % 47;
@end group
@end example

@noindent
Modular division returns the remainder produced after performing
integer division on the two operands. The operands must be of a
primitive integer type.

@example
@group
/* @r{Negation.} */
int x = -5;
float y = -3.14159;
@end group
@end example

If the operand you use with the negative operator is of an unsigned data
type, then the result cannot negative, but rather is the
maximum value of the unsigned data type, minus the value of the operand.

Many systems use twos-complement arithmetic, and on such systems the
most negative value a signed type can hold is further away from zero
than the most positive value.   For example, on one platform, this
program:

@example
@group
#include <limits.h>
#include <stdio.h>

int main (int argc, char *argv[]) 
@{
  int x;
  x = INT_MAX;
  printf("INT_MAX  = %d\n", x);
  x = INT_MIN;
  printf("INT_MIN  = %d\n", x);
  x = -x;
  printf("-INT_MIN = %d\n", x);
  return 0;
@}
@end group
@end example

Produces this output:

@example
@group
INT_MAX  = 2147483647
INT_MIN  = -2147483648
-INT_MIN = -2147483648
@end group
@end example

Trivially, you can also apply a positive operator to a numeric
expression:

@example
int x = +42;
@end example

@noindent
Numeric values are assumed to be positive unless explicitly made
negative, so this operator has no effect on program operation.

@node Complex Conjugation
@section Complex Conjugation
@cindex complex conjugation
@cindex conjugation
 
As a GNU extension, you can use the complex conjugation operator @code{~} to
perform complex conjugation on its operand --- that is, it reverses the sign of
its imaginary component.   The operand must be an expression of a complex number
type.  Here is an example:
 
@example
@group
__complex__ int x = 5 + 17i;
 
printf ("%d  \n", (x * ~x));
@end group
@end example
 
Since an imaginary number @math{(a + bi)} multiplied by its conjugate is equal
to @math{a^2 + b^2}, the above @code{printf} statement will print 314, which
is equal to @math{25 + 289}.

@node Comparison Toán tử
@section Comparison Toán tử
@cindex comparison toán tử
@cindex toán tử, comparison

You use the comparison toán tử to determine how two operands relate to
each other: are they equal to each other, is one larger than the other,
is one smaller than the other, and so on.   When you use any of the
comparison toán tử, the result is either 1 or 0, meaning true or false,
respectively.

(In the following code examples, the variables @code{x} and @code{y} stand
for any two expressions of arithmetic types, or pointers.)

The equal-to operator @code{==} tests its two operands for equality.
The result is 1 if the operands are equal, and 0 if the operands are not equal.

@example
@group
if (x == y)
  puts (``x is equal to y'');
else
  puts (``x is not equal to y'');
@end group
@end example

The not-equal-to operator @code{!=} tests its two operands for inequality.
The result is 1 if the operands are not equal, and 0 if the operands
@emph{are} equal.

@example
@group
if (x != y)
  puts (``x is not equal to y'');
else
  puts (``x is equal to y'');
@end group
@end example

Comparing floating-point values for exact equality or inequality can
produce unexpected results.  @ref{Real Number Types} for more
information.

You can compare function pointers for equality or inequality; the
comparison tests if two function pointers point to the same function
or not.

Beyond equality and inequality, there are toán tử you can use to test
if one value is less than, greater than, less-than-or-equal-to, or
greater-than-or-equal-to another value.  Here are some code samples that
exemplify usage of these toán tử:

@example
@group
if (x < y)
  puts (``x is less than y'');
@end group
@end example

@example
@group
if (x <= y)
  puts (``x is less than or equal to y'');
@end group
@end example

@example
@group
if (x > y)
  puts (``x is greater than y'');
@end group
@end example

@example
@group
if (x >= y)
  puts (``x is greater than or equal to y'');
@end group
@end example


@node Logical Toán tử
@section Logical Toán tử
@cindex logical toán tử

Logical toán tử test the truth value of a pair of operands.  Any
nonzero expression is considered true in C, while an expression that
evaluates to zero is considered false.

The logical conjunction operator @code{&&} tests if two expressions
are both true.  If the first expression is false, then the second
expression is not evaluated.

@example
@group
if ((x == 5) && (y == 10))
  printf (``x is 5 and y is 10'');
@end group
@end example

The logical conjunction operator @code{||} tests if at least one of
two expressions it true.  If the first expression is true, then the
second expression is not evaluated.

@example
@group
if ((x == 5) || (y == 10))
   printf (``x is 5 or y is 10'');
@end group
@end example

You can prepend a logical expression with a negation operator
@code{!} to flip the truth value:

@example
@group
if (!(x == 5))
  printf (``x is not 5'');
@end group
@end example

Since the second operand in a logical expression pair is not necessarily
evaluated, you can write code with perhaps unintuitive results:

@example
@group
if (foo && x++)
  bar();
@end group
@end example

@noindent
If @code{foo} is ever zero, then not only would @code{bar} not be called,
but @code{x} would not be incremented.  If you intend to increment @code{x}
regardless of the value of @code{foo}, you should do so outside of the
conjunction expression.


@node Bit Shifting
@section Bit Shifting
@cindex bit shifting
@cindex shifting

You use the left-shift operator @code{<<} to shift its first operand's bits
to the left.  The second operand denotes the number of bit places to shift.
Bits shifted off the left side of the value are discarded; new bits added
on the right side will all be 0.

@example
@group
x = 47;    /* @r{47 is 00101111 in binary.} */
x << 1;    /* @r{00101111 << 1 is 01011110.} */
@end group
@end example

Similarly, you use the right-shift operator @code{>>} to shift its
first operand's bits to the right. Bits shifted off the right side are
discarded; new bits added on the left side are @emph{usually} 0, but
if the first operand is a signed negative value, then the added bits will
be either 0 @emph{or} whatever value was previously in the leftmost bit
position.

@example
@group
x = 47;   /* @r{47 is 00101111 in binary.} */
x >> 1;   /* @r{00101111 >> 1 is 00010111.} */
@end group
@end example

For both @code{<<} and @code{>>}, if the second operand is greater
than the bit-width of the first operand, or the second operand is
negative, the behavior is undefined.

You can use the shift toán tử to perform a variety of interesting
hacks.  For example, given a date with the day of the month numbered
as @code{d}, the month numbered as @code{m}, and the year @code{y}, you
can store the entire date in a single number @code{x}:

@example
int d = 12;
int m = 6;
int y = 1983;
int x = ((y << 4) + m) << 5) +  d;
@end example

@noindent
You can then extract the original day, month, and year out of @code{x}
using a combination of shift toán tử and modular division:

@example
d = x % 32;
m = (x >> 5) % 16;
y = x >> 9;
@end example

@node Bitwise Logical Toán tử
@section Bitwise Logical Toán tử
@cindex bitwise logical toán tử
@cindex logical toán tử, bitwise

C provides toán tử for performing bitwise conjunction, inclusive disjunction,
exclusive disjunction, and negation (complement).

Biwise conjunction examines each bit in its two operands, and when two
corresponding bits are both 1, the resulting bit is 1.  All other resulting
bits are 0.  Here is an example of how this works, using binary numbers:

@example
11001001 & 10011011 = 10001001
@end example

Bitwise inclusive disjunction examines each bit in its two operands,
and when two corresponding bits are both 0, the resulting bit is 0.  All
other resulting bits are 1.

@example
11001001 | 10011011 = 11011011
@end example

Bitwise exclusive disjunction examines each bit in its two operands, and when
two corresponding bits are different, the resulting bit is 1.  All other resulting
bits are 0.

@example
11001001 ^ 10011011 = 01010000
@end example

Bitwise negation reverses each bit in its operand:

@example
~11001001 = 00110110
@end example

In C, you can only use these toán tử with operands of an integer (or character)
type, and for maximum portability, you should only use the bitwise negation operator
with unsigned integer types.  Here are some examples of using these toán tử in
C code:

@example
@group
unsigned int foo = 42;
unsigned int bar = 57;
unsigned int quux;

quux = foo & bar;
quux = foo | bar;
quux = foo ^ bar;
quux = ~foo;
@end group
@end example

@node Pointer Toán tử
@section Pointer Toán tử
@cindex pointer toán tử

You can use the address operator @code{&} to obtain the memory address of
an object.

@example
@group
int x = 5;
int *pointer_to_x = &x;
@end group
@end example

It is not necessary to use this operator to obtain the address of
a function, although you can:

@example
@group
extern int foo (void);
int (*fp1) (void) = foo; /* fp1 points to foo */
int (*fp2) (void) = &foo; /* fp1 also points to foo */
@end group
@end example

Function pointers and data pointers are not compatible, in the sense
that you cannot expect to store the address of a function into a data
pointer, and then copy that into a function pointer and call it
successfully.  It might work on some systems, but it's not a portable
technique.

As a GNU extension to C89, you can also obtain the address of a label
with the label address operator @code{&&}.  The result is a
@code{void*} pointer which can be used with @code{goto}.  @xref{The
goto Statement}.

Given a memory address stored in a pointer, you can use the indirection
operator @code{*} to obtain the value stored at the address. (This is called
@dfn{dereferencing} the pointer.)

@example
@group
int x = 5;
int y;
int *ptr;

ptr = &x;    /* @r{@code{ptr} now holds the address of @code{x}.} */

y = *ptr;    /* @r{@code{y} gets the value stored at the address}
                @r{stored in @code{ptr}.} */
@end group
@end example

@noindent
Avoid using dereferencing pointers that have not been initialized to
a known memory location.


@node The sizeof Operator
@section The sizeof Operator
@cindex sizeof operator

You can use the @code{sizeof} operator to obtain the size (in bytes)
of the data type of its operand.  The operand may be an actual type
specifier (such as @code{int} or @code{float}), as well as any valid
expression.  When the operand is a type name, it must be enclosed in
parentheses.  Here are some examples:

@example
@group
size_t a = sizeof(int);
size_t b = sizeof(float);
size_t c = sizeof(5);
size_t d = sizeof(5.143);
size_t e = sizeof a;
@end group
@end example

The result of the @code{sizeof} operator is of a type called @code{size_t},
which is defined in the header file @code{<stddef.h>}.  @code{size_t} is
an unsigned integer type, perhaps identical to @code{unsigned int} or
@code{unsigned long int}; it varies from system to system.

The @code{size_t} type is often a convenient type for a loop index,
since it is guaranteed to be able to hold the number of elements in
any array; this is not the case with @code{int}, for example.

The @code{sizeof} operator can be used to automatically compute the
number of elements in an array:

@example
@group
#include <stddef.h>
#include <stdio.h>

static const int values[] = @{ 1, 2, 48, 681 @};
#define ARRAYSIZE(x) (sizeof x/sizeof x[0])

int main (int argc, char *argv[]) 
@{
    size_t i;
    for (i = 0; i < ARRAYSIZE(values); i++) 
    @{
        printf("%d\n", values[i]);
    @}
    return 0;
@}
@end group
@end example

There are two cases where this technique does not work.  The first is
where the array element has zero size (GCC supports zero-sized
structures as a GNU extension).  The second is where the array is in
fact a function parameter (@pxref{Function Parameters}).

@node Type Casts
@section Type Casts
@cindex type casts
@cindex casts

You can use a type cast to explicitly cause an expression to be of a specified
data type.  A type cast consists of a type specifier enclosed in parentheses,
followed by an expression.  To ensure proper casting, you should also enclose
the expression that follows the type specifier in parentheses.  Here is
an example:

@example
@group
float x;
int y = 7;
int z = 3;
x = (float) (y / z);
@end group
@end example

In that example, since @code{y} and @code{z} are both integers, integer
division is performed, and even though @code{x} is a floating-point
variable, it receives the value 2.  Explicitly casting the result
of the division to @code{float} does no good, because the computed
value of @code{y/z} is already 2.

To fix this problem, you need to convert one of the operands to a
floating-point type before the division takes place:

@example
@group
float x;
int y = 7;
int z = 3;
x = (y / (float)z);
@end group
@end example

@noindent Here, a floating-point value close to 2.333@dots{} is assigned to @code{x}.

Type casting only works with scalar types (that is, integer,
floating-point or pointer types).  Therefore, this is not allowed:

@example
@group
struct fooTag @{ /* members ... */ @};
struct fooTag foo;
unsigned char byteArray[8];

foo = (struct fooType) byteArray; /* @r{Fail!} */
@end group
@end example

@node Array Subscripts
@section Array Subscripts
@cindex array subscripts

You can access array elements by specifying the name of the array, and the
array subscript (or index, or element number) enclosed in brackets.  Here is
an example, supposing an integer array called @code{my_array}:

@example
@group
my_array[0] = 5;
@end group
@end example

The array subscript expression @code{A[i]} is defined as being
identical to the expression @code{(*((A)+(i)))}.  This means that many
uses of an array name are equivalent to a pointer expression.  It also
means that you cannot subscript an array having the @code{register}
storage class.

@node Function Calls as Biểu thức
@section Function Calls as Biểu thức
@cindex function calls, as expressions

A call to any function which returns a value is an expression.

@example
@group
int function(void);
@dots{}
a = 10 + function();
@end group
@end example


@node The Comma Operator
@section The Comma Operator
@cindex comma operator

You use the comma operator @code{,} to separate two (ostensibly related) expressions.
For instance, the first expression might produce a value that is used by the second
expression:
@c This works because there is a sequence point after the evaluation
@c of the left hand side.
@example
@group
x++, y = x * x;
@end group
@end example

More commonly, the comma operator is used in @code{for} statements, like
this:

@example
@group
/* @r{Using the comma operator in a @code{for} statement.} */

for (x = 1, y = 10;  x <=10 && y >=1;  x++, y--)
  @{
    @dots{}
  @}
@end group
@end example

@noindent
This lets you conveniently set, monitor, and modify multiple control
expressions for the @code{for} statement.

A comma is also used to separate function parameters; however, this
is @emph{not} the comma operator in action.   In fact, if the comma
operator is used as we have discussed here in a function call, then
the compiler will
interpret that as calling the function with an extra parameter.

If you want to use the comma operator in a function argument, you need
to put parentheses around it.  That's because commas in a function
argument list have a different meaning: they separate arguments.
Thus,

@example
foo (x,  y=47,  x,  z);
@end example

@noindent
is interpreted as a function call with four arguments, but

@example
foo (x,  (y=47,  x),  z);
@end example

@noindent
is a function call with just three arguments.  (The second argument is
@code{(y=47, x)}.)

@node Member Access Biểu thức
@section Member Access Biểu thức
@cindex member access expressions

You can use the member access operator @code{.} to access the members
of a structure or union variable.  You put the name of the structure
variable on the left side of the operator, and the name of the
member on the right side.

@example
@group
struct point
@{
  int x, y;
@};

struct point first_point;

first_point.x = 0;
first_point.y = 5;
@end group
@end example

@cindex indirect member access operator
You can also access the members of a structure or union variable via
a pointer by using the indirect member access operator @code{->}.
@code{x->y} is equivalent to @code{(*x).y}.

@example
@group
struct fish
  @{
    int length, weight;
  @};

struct fish salmon;

struct fish *fish_pointer = &salmon;

fish_pointer->length = 3;
fish_pointer->weight = 9;
@end group
@end example 

@xref{Pointers}.


@node Conditional Biểu thức
@section Conditional Biểu thức
@cindex conditional expressions
@cindex expressions, conditional
@cindex ternary operator

You use the conditional operator to cause the entire conditional
expression to evaluate to either its second or its third operand, based
on the truth value of its first operand.  Here's an example:

@example
a ? b : c
@end example

If expression @code{a} is true, then expression @code{b} is evaluated
and the result is the value of @code{b}.  Otherwise, expression
@code{c} is evaluated and the result is @code{c}.  

Biểu thức @code{b} and @code{c} must be compatible.   That is, they
must both be 

@enumerate
@item arithmetic types
@item compatible @code{struct} or @code{union} types
@item pointers to compatible types (one of which might be the NULL pointer)
@end enumerate 

Alternatively, one operand is a pointer and the other is a
@code{void*} pointer.

Here is an example

@example
a = (x == 5) ? y : z;
@end example

Here, if @code{x} equals 5, then @code{a} will receive
the value of @code{y}.  Otherwise, @code{a} will receive the value of
@code{z}.  This can be considered a shorthand method for writing a simple
@code{if}@dots{}@code{else} statement.  The following example will
accomplish the same task as the previous one:

@example
@group
if (x == 5)
    a = y;
else
    a = z;
@end group
@end example

If the first operand of the conditional operator is true, then the third
operand is never evaluated.  Similarly, if the first operand is false,
then the second operand is never evaluated.  The first operand is always
evaluated.


@c GNU C Extension

@node Statements and Declarations in Biểu thức
@section Statements and Declarations in Biểu thức
@cindex statements inside expressions
@cindex declarations inside expressions
@cindex expressions containing statements
@cindex macros, statements in expressions

As a GNU C extension, you can build an expression using compound
statement enclosed in parentheses.  This allows you to included
loops, switches, and local variables within an expression.

Recall that a compound statement (also known as a block) is a sequence of
statements surrounded by braces.  In this construct, parentheses go around
the braces.  Here is an example:

@example
@group
(@{ int y = function (); int z;
    if (y > 0) z = y;
   else z = - y;
   z; @})
@end group
@end example

That is a valid (though slightly more complex than necessary) expression
for the absolute value of @code{function ()}.

The last thing in the compound statement should be an expression
followed by a semicolon; the value of this subexpression serves as the
value of the entire construct.  (If you use some other kind of statement
last within the braces, the construct has type @code{void}, and thus
effectively no value.)

This feature is especially useful in making macro definitions ``safe'' (so
that they evaluate each operand exactly once).  For example, the
``maximum'' function is commonly defined as a macro in standard C as
follows:

@example
#define max(a,b) ((a) > (b) ? (a) : (b))
@end example

@noindent
@cindex side effects, macro argument
But this definition computes either @code{a} or @code{b} twice, with bad
results if the operand has side effects.  In GNU C, if you know the
type of the operands (here let's assume @code{int}), you can define
the macro safely as follows:

@example
#define maxint(a,b) \
  (@{int _a = (a), _b = (b); _a > _b ? _a : _b; @})
@end example

If you don't know the type of the operand, you can still do this, but you
must use @code{typeof} expressions or type naming.

@comment Add reference to typeof

Embedded statements are not allowed in constant expressions, such as
the value of an enumeration constant, the width of a bit field, or
the initial value of a static variable.


@node Operator Precedence
@section Operator Precedence in C
@cindex operator precedence
@cindex precedence, operator

When an expression contains multiple toán tử, such as @code{a + b *
f()}, the toán tử are grouped based on rules of @dfn{precedence}.
For instance, the meaning of that expression is to call the function
@code{f} with no arguments, multiply the result by @code{b}, then add
that result to @code{a}.  That's what the C rules of operator
precedence determine for this expression.

The following is a list of types of expressions, presented in order of
highest precedence first.  Sometimes two or more toán tử have equal
precedence; all those toán tử are applied from left to right
unless stated otherwise.

@enumerate

@item
Function calls, array subscripting, and membership access operator
expressions.

@item
Unary toán tử, including logical negation, bitwise complement,
increment, decrement, unary positive, unary negative, indirection
operator, address operator, type casting, and @code{sizeof}
expressions.  When several unary toán tử are consecutive,
the later ones are nested within the earlier ones: @code{!-x}
means @code{!(-x)}.

@item
Multiplication, division, and modular division expressions.

@item
Addition and subtraction expressions.

@item
Bitwise shifting expressions.

@item
Greater-than, less-than, greater-than-or-equal-to, and less-than-or-equal-to@*
expressions.

@item
Equal-to and not-equal-to expressions.

@item
Bitwise AND expressions.

@item
Bitwise exclusive OR expressions.

@item
Bitwise inclusive OR expressions.

@item
Logical AND expressions.

@item
Logical OR expressions.

@item
Conditional expressions (using @code{?:}).  When used as
subexpressions, these are evaluated right to left.

@item
All assignment expressions, including compound assignment.  When multiple
assignment statements appear as subexpressions in a single larger expression,
they are evaluated right to left.

@item
Comma operator expressions.

@end enumerate

@c ??? Lots more examples are needed here!

@c ??? You need to explain when parentheses are strongly
@c recommended in order to make the structure clear.

The above list is somewhat dry and is apparently straightforward, but
it does hide some pitfalls.  Take this example:

@example
foo = *p++;
@end example

Here @code{p} is incremented as a side effect of the expression, but
@code{foo} takes the value of @code{*(p++)} rather than @code{(*p)++},
since the unary operators bind right to left.   There are other
examples of potential surprises lurking behind the C precedence
table.  For this reason if there is the slightest risk of the reader
misunderstanding the meaning of the program, you should use
parentheses to make your meaning clear.

@node Order of Evaluation
@section Order of Evaluation

In C you cannot assume that multiple subexpressions are evaluated in
the order that seems natural.  For instance, consider the expression
@code{++a * f()}.  Does this increment @code{a} before or after
calling the function @code{f}?  The compiler could do it in either
order, so you cannot make assumptions.

This manual explains the semantics of the C language in the abstract.
However, an actual compiler translates source code into specific
actions in an actual computer, and may re-order operations for the
sake of efficiency.  The correspondence between the program you write
and the things the computer actually does are specified in terms of
@emph{side effects} and @emph{sequence points}.

@menu
* Side Effects::
* Sequence Points::
* Sequence Points Constrain Biểu thức::
* Sequence Points and Signal Delivery::
@end menu

@node Side Effects
@subsection Side Effects

@cindex side effect
A @dfn{side effect} is one of the following:
@enumerate
@item accessing a @code{volatile} object
@item modifying an object
@item modifying a file
@item a call to a function which performs any of the above side effects
@end enumerate

These are essentially the externally-visible effects of running a
program.   They are called side effects because they are effects of
expression evalation beyond the expression's actual resulting value.

The compiler is allowed to perform the operations of your program in
an order different to the order implied by the source of your program, 
provided that in the end all the necessary side effects actually take
place. The compiler is also allowed to entirely omit some operations;
for example it's allowed to skip evaluating part of an expression if
it can be certain that the value is not used and evaluating that part
of the expression won't produce any needed side effects.

@node Sequence Points
@subsection Sequence Points

Another requirement on the compiler is that side effects should take
place in the correct order.  In order to provide this without
over-constraining the compiler, the C89 and C90 standards specfy a
list of sequence points.  A @dfn{sequence point} is one of the
following:

@cindex sequence point
@enumerate
@c authority: C99 standard, annex C
@item a call to a function (after argument evaluation is complete)
@item the end of the left-hand operand of the and operator @code{&&}
@item the end of the left-hand operand of the or operator @code{||}
@item the end of the left-hand operand of the comma operator @code{,}
@item the end of the first operand of the ternary operator @code{a ? b : c}
@item the end of a full declarator
@footnote{a full declarator is a declaration of a function or an object which is not part of another object}
@item the end of an initialisation expression 
@item the end of an expression statement (i.e. an expression followed by @code{;})
@item the end of the controlling expression of an @code{if} or @code{switch} statement
@item the end of the controlling expression of a @code{while} or @code{do}statement
@item the end of any of the three controlling expressions of a @code{for} statement
@item the end of the expression in a return statement
@item immediately before the return of a library function
@item after the actions associated with an item of formatted I/O (as
used for example with the @code{strftime} or the @code{printf} and
@code{scanf} famlies of functions).
@item immediately before and after a call to a comparison function (as
called for example by @code{qsort})
@end enumerate

@c authority: C99 standard, section 5.1.2.3
At a sequence point, all the side effects of previous expression
evaluations must be complete, and no side effects of later evaluations
may have taken place.

@c authority: C89 standard, section 5.1.2.3
@c this description was not included in C99, I assume because of the 
@c introduction of whole-program optimisation
This may seem a little hard to grasp, but there is another way to
consider this.  Imagine you wrote a library (some of whose functions
are external and perhaps others not) and compiled it, allowing someone
else to call one of your functions from their code.  The definitions
above ensure that, at the time they call your function, the data they
pass in has values which are consistent with the behaviour specified
by the abstract machine, and any data returned by your function has a
state which is also consistent with the abstract machine.  This
includes data accessible via pointers (i.e. not just function
parameters and identifiers with external linkage).

The above is a slight simplification, since compilers exist that
perform whole-program optimisation at link time.  Importantly however,
although they might perform optimisations, the visible side effects of
the program must be the same as if they were produced by the abstract
machine.

@node Sequence Points Constrain Biểu thức
@subsection Sequence Points Constrain Biểu thức

@c authority: C89 section 6.3, C99 section 6.5
The code fragment 
@example
i = i + 1;
@end example 
is quite normal and no doubt occurs in many programs.  However, the
quite similar code fragment
@example
i = ++i + 1;
@end example 
is a little harder to understand; what is the final value of @code{i}?
The C standards (both C89 and C99) both forbid this construct in 
conforming programs.  

Between two sequence points, 
@enumerate
@item an object may have its stored value modified at most once by the
evaluation of an expression
@item the prior value of the object shall be read only to determine
the value to be stored.
@end enumerate

The first of these two conditions forbids expressions like 
@code{foo(x=2, ++x)}.  The second condition forbids expressions like
@code{a[i++] = i}.

@c with an appropriate list of counterexamples such as f(x++, x++).

@table @code
@item int x=0; foo(++x, ++x)
Not allowed in a conforming program; modifies @code{x} twice before
argument evaluation is complete. 
@item int x=0; bar((++x,++x))
Allowed; the function @code{bar} takes one argument (the value 2
is passed here), and there is a sequence point at the comma operator.
@item *p++ || *p++
Allowed; there is a sequence point at @code{||}.
@item int x = 1, y = x++;
Allowed; there is a sequence point after the full declarator of @code{x}.
@item x=2; x++;
Allowed; there is a sequence point at the end of the first expression
statement.
@item if (x++ > MAX) x = 0;
Allowed; there is a sequence point at the end of the controlling
expression of the @code{if}@footnote{However if for example @code{MAX} is
@code{INT_MAX} and @code{x} is of type @code{int}, we clearly have a
problem with overflow.  @xref{Overflow}.}.
@item (x=y) ? ++x : x--;
Allowed; there is a sequence point before the @code{?}, and only one
of the two following expressions is evaluated.
@item int *p=malloc(sizeof(*p)), *q=p;  *p=foo(); bar((*p)++,(*q)++);
Not allowed; the object at @code{p} is being modified twice
before the evaluation of the arguments to @code{bar} is complete.  The
fact that this is done once via @code{p} and once via @code{q} is
irrelevant, since they both point to the same object.
@end table

Let's go back to the example we used to introduce the problem of the
order of evaluation, @code{++a * f()}.   Suppose the code actually
looks like this:

@example
@group
static int a = 1;

static int f (void)
@{
  a = 100;
  return 3;
@}

int foo (void)
@{
   return ++a * f();
@}
@end group
@end example

Is this code allowed in a standard-conforming program?  Although the
expression in @code{foo} modifies @code{a} twice, this is not a
problem.  Let's look at the two possible cases.

@table @asis
@item The right operand @code{f()} is evaluated first
Since @code{f} returns a value other than void, it must contain a
@code{return} statement.   Therefore, there is a sequence point at the
end of the return expression.  That comes between the modification to
@code{a} that @code{f} makes and the evaluation of the left operand.
@item The left operand @code{++a} is evaluated first
First, @code{a} is incremented.   Then the arguments to @code{f} are
evaluated (there are zero of them).  Then there is a sequence point
before @code{f} is actually called.
@end table

@c C99 does not state explicitly that there is a sequence point after
@c argument evaluation if a function call contains zero arguments.
So, we see that our program is standard-conforming.  Notice that the
above argument does not actually depend on the details of the body of
the function @code{f}.  It only depends on the function containing
something ending in a sequence point -- in our example this is a
return statement, but an expression statement or a full declarator
would do just as well.

@cindex unspecified behaviour
However, the result of executing this code depends on the order of
evaluation of the operands of @code{*}.  If the left-hand operand is
evaluated first, @code{foo} returns 6.  Otherwise, it returns 303.
The C standard does not specify in which order the operands should be
evaluated, and also does not require an implementation either to
document the order or even to stick to one order.  The effect of this
code is @dfn{unspecified}, meaning that one of several specific
things will happen, but the C standards do not say which.



@node Sequence Points and Signal Delivery
@subsection Sequence Points and Signal Delivery

Singals are mainly documented in the GNU C Library manual rather than
this document, even though the C standards consider the compiler and
the C library together to be ``the implementation''.

@c [This scene-setting is probably too long. - jay@gnu.org]
@c
@c Your C program can be notified of asynchronous events by the
@c @dfn{signal} mechanism.  There are a few dozen different possible
@c signals; these include for example @code{SIGINT}, which tells your
@c program that the user pressed the keyboard interrupt key, and
@c @code{SIGFPE} which tells your program that an arithmetic overflow has
@c occurred.  Signals can be asyncronous, for example @code{SIGINT}
@c generally arises outside your program, or normally synchronous like
@c @code{SIGFPE} or @code{SIGABRT} (which indicates your program called
@c the @code{abort} function, directly or indirectly).  Signals can also
@c be sent using the @code{kill} and @code{raise} functions.
@c 
@c All signals have a default effect, usually to terminate the program.
@c However, you can set up a @dfn{signal handler} -- a funciton to be
@c called when a specified signal is delivered.


When a signal is received, this will happen between sequence points.
Side effects on @code{volatile} objects prior to the previous sequence
point will have occurred, but other updates may not have occurred
yet.  This even applies to straight assignments, such as @code{x=0;},
because the code generated for that statement may require more than
one instruction, meaning that it can be interrupted part-way through
by the delivery of a signal.

The C standard is quite restrictive about what data access can occur
within a signal handler.  They can of course use @code{auto}
variables, but in terms of reading or writing other objects, they must
be @code{volatile sig_atomic_t}.  The @code{volatile} type qualifier
ensures that access to the variable in the other parts of the program
doesn't span sequence points and the use of the @code{sig_atomic_t}
type ensures that changes to the variable are atomic with respect to
signal delivery.

The POSIX standard also allows a small number of library functions to
be called from a signal handler.  These functions are referred to as
the set of @dfn{async-signal-safe} functions.  If your program is
intended to run on a POSIX system but not on other systems, you can
safely call these from your signal handler too.

@node Overflow
@section Overflow

@include overflow.texi

