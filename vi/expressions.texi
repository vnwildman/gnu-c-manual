@c ??? It might be a good idea to turn each example of an expression
@c into a small program that prints output and thus shows what
@c the expression does.

@c This is part of The GNU C Reference Manual
@c Copyright (C) 2007-2011 Free Software Foundation, Inc.
@c See the file gnu-c-manual.texi for copying conditions.

@node Biểu thức và Toán tử
@chapter Biểu thức và Toán tử

@menu
* Biểu thức::
* Toán tử Gán::
* Gia và Giảm::
* Toán tử Số học::
* Toán tử Kết hợp với Số phức::
* Toán tử So sánh::
* Toán tử Lô-gíc::
* Dịch Bít::
* Toán tử Lô-gíc trên Bít::
* Toán tử Con trỏ::
* Toán tử sizeof::
* Áp đổi Kiểu::
* Array Subscripts::
* Function Calls as Biểu thức::
* Toán tử Dấu phẩy::
* Member Access Biểu thức::
* Conditional Biểu thức::
* Statements and Declarations in Biểu thức::
* Operator Precedence::
* Mức ưu tiên::
* Tràn::
@end menu

@node Biểu thức
@section Biểu thức
@cindex biểu thức

Một @dfn{biểu thức} gồm có ít nhất là một toán hạng không hoặc nhiều hơn một
toán tử.  Đối tượng kiểu của toán hạng như là hằng, biến, và
giá trị trả về từ cú gọi hàm.  Đây là một số ví dụ:

@example
@group
47
2 + 2
cosine(3.14159) /* @r{Chúng ta giả sử rằng nó trả về giá trị dấu chấm động.} */
@end group
@end example

Các dấu ngoặc đơn dùng để nhóm các biểu thức con:

@example
( 2 * ( ( 3 + 10 ) - ( 2 * 6 ) ) )
@end example

@noindent
Biểu thức ở trong cùng được định giá trước.  Trong ví dụ trên,
@code{3 + 10} và @code{2 * 6} được định giá là @code{13} và @code{12},
tương ứng.  Sau đó @code{12} được trừ đi
@code{13}, kết quả là một @code{1}.  Cuối cùng, @code{1} được nhân với
@code{2}, kết quả là @code{2}.  Cặp dấu ngoặc ngoài cùng chỉ là
tùy chọn.

@cindex toán tử

Một @dfn{toán tử} định ra một hành động để thực thi trên toán hạng.
Toán tử có thể có một, hai hay nhiều toán hạng, còn phụ thuộc vào toán tử.

@node Toán tử Gán
@section Toán tử Gán
@cindex toán tử gán
@cindex toán tử, gán

Toán tử gán đưa giá trị lưu trữ vào biến.  C cung cấp nhiều biến thể
khác nhau của toán tử gán.

Toán tử gán theo tiêu chuẩn @code{=} đơn giản chỉ lưu trữ giá trị của
toán hạng bên phải của nó vào biến được chỉ ra ở toán hạng bên trái.  Với
mọi toán tử gán, toán hạng bên trái (thông thường được xem như là
``lvalue'') không thể là dạng văn bản hay hằng giá trị.

@example
@group
int x = 10;
float y = 45.12 + 2.0;
int z = (2 * (3 + function () ));

struct foo @{
  int bar;
  int baz;
@} quux = @{3, 4, 5@};
@end group
@end example

@noindent
Chú ý rằng, không giống như phần mô tả các toán tử gán ở phía dưới, bạn
có thể sử dụng toán tử gán thường để mà lưu trữ giá trị của kiểu
cấu trúc.

Toán tử gán phức hợp thực hiện việc thi hành perform an operation bao gồm
cả hai phía trái và phải của các toán tử, và sau đó gán kết quả của
biểu thức cho toán hạng trái.  Sau đây là danh sách các toán tử
gán phức hợp, và mô tả vắn tắt về hoạt động của chúng:

@itemize

@item
@code{+=}

Cộng hai toán hạng với nhau, sau đó thì gán kết quả của phép
cộng cho toán hạng bên trái.

@item
@code{-=}

Trừ toán hạng bên phải cho toán hạng bên trái, và
sau đó thì gán kết quả của phép trừ cho toán hạng bên trái.

@item
@code{*=}

Nhân hai toán hạng với nhau, sau đó thì gán kết quả của phép
nhân cho toán hạng bên trái.

@item
@code{/=}

Lấy toán hạng bên trái chia cho toán hạng bên phải, và
gán kết quả cho toán hạng bên trái.

@item
@code{%=}

Thực hiện phép lấy chia lấy phần dư trên hai toán hạng, và
gán kết quả cho toán hạng bên trái.

@item
@code{<<=}

Thực hiện việc đẩy trái toán hạng trái, số bít
được đẩy được chỉ định bởi toán hạng bên phải, và gán
kết quả của quá trình đẩy này cho toán hạng bên trái.

@item
@code{>>=}

Thực hiện việc đẩy phải toán hạng trái, số bít
được đẩy được chỉ định bởi toán hạng bên phải, và gán
kết quả của quá trình đẩy này cho toán hạng bên trái.

@item
@code{&=}

Thực hiện phép luận lý VÀ trên bít (bitwise) trên hai toán hạng, và
gán kết quả sau khi thực hiện cho toán hạng bên phải.

@item
@code{^=}

Thực hiện phép luận lý LOẠI TRỪ trên bít (bitwise) trên hai toán hạng, và
gán kết quả sau khi thực hiện cho toán hạng bên phải.

@item
@code{|=}

Thực hiện phép luận lý HOẶC trên bít (bitwise) trên hai toán hạng, và
gán kết quả sau khi thực hiện cho toán hạng bên phải.

@end itemize
@comment  __End of compound assignment operator list

Đây là một ví dụ về việc sử dụng toán tử gán phức hợp:

@example
x += y;
@end example

@noindent
Từ đó không có kết quả cuối cùng khác biệt nào bởi việc định giá biến
@code{x} là một lvalue (giá trị có địa chỉ), đoạn mã trên có cùng kết quả với:

@example
x = x + y;
@end example


@c GNU C Extension -- temporarily commented out for manual 0.1
@c @node Generalized Lvalues
@c @subsubsection Generalized Lvalues
@c @cindex compound expressions as lvalues
@c @cindex expressions, compound, as lvalues
@c @cindex conditional expressions as lvalues
@c index expressions, conditional, as lvalues
@c @cindex casts as lvalues
@c @cindex generalized lvalues
@c @cindex lvalues, generalized
@c @cindex extensions, @code{?:}
@c @cindex @code{?:} extensions
@c 
@c Compound expressions, conditional expressions and casts are allowed as
@c lvalues provided their operands are lvalues.  This means that you can take
@c their addresses or store values into them.
@c 
@c For example, you can assign a value to a compound expression, provided the
@c last expression in the sequence is an lvalue.  These two expressions are
@c equivalent:
@c 
@c @example
@c (a, b) += 5
@c a, (b += 5)
@c @end example
@c 
@c Similarly, you can take the address of a compound expression.  So, these two
@c expressions are equivalent:
@c 
@c @example
@c &(a, b)
@c a, &b
@c @end example
@c 
@c A conditional expression is a valid lvalue if its type is not void and if
@c both the second and third operands are valid lvalues.  For example, these two
@c expressions are equivalent:
@c 
@c @example
@c (a ? b : c) = 5
@c (a ? b = 5 : (c = 5))
@c @end example
@c 
@c A type cast is a valid lvalue if its operand is an lvalue.  A simple
@c assignment whose left-hand side is a cast works by converting the
@c right-hand side first to the specified type, then to the type of the
@c inner left-hand side expression.  After this is stored, the value is
@c converted back to the specified type to become the value of the
@c assignment.  Thus, if @code{a} has type @code{char *}, the following two
@c expressions are equivalent:
@c 
@c @example
@c (int)a = 5
@c (int)(a = (char *)(int)5)
@c @end example
@c 
@c An assignment-with-arithmetic operation such as @code{+=} applied to a cast
@c performs the arithmetic using the type resulting from the cast, and then
@c continues as in the previous case.  Therefore, these two expressions are
@c equivalent:
@c 
@c @example
@c (int)a += 5
@c (int)(a = (char *)(int) ((int)a + 5))
@c @end example

@c You cannot take the address of an lvalue cast, because the use of its
@c address would not work out coherently.  Suppose that @code{&(int)f} were
@c permitted, where @code{f} has type @code{float}.  Then the following
@c statement would try to store an integer bit-pattern where a floating
@c point number belongs:
@c 
@c @example
@c *&(int)f = 1;
@c @end example
@c 
@c This is quite different from what @code{(int)f = 1} would do---that
@c would convert 1 to floating point and store it.  Rather than cause this
@c inconsistency, we think it is better to prohibit use of @code{&} on a cast.
@c 
@c If you really do want an @code{int *} pointer with the address of
@c @code{f}, you can simply write @code{(int *)&f}.

@node Gia và Giảm
@section Gia và Giảm
@cindex toán tử gia
@cindex toán tử giảm
@cindex toán tử, gia
@cindex toán tử, giảm

Toán tử gia số @code{++} thêm 1 vào toán hạng của nó.  Toán hạng phải
hoặc là biến thuộc một kiểu dữ liệu cơ bản, một con trỏ, hay một
biến thuộc kiểu liệt kê.  Bạn có thể áp dụng toán tử gia trước cũng như sau
toán hạng.  Đây là một số ví dụ:

@example
@group
char w = '1';
int x = 5;
char y = 'B';
float z = 5.2;
int *p = &x;

x++;   /* @r{@code{x} bây giờ là 6.} */
++y;   /* @r{@code{y} bây giờ là `C' (on ASCII systems).} */
++w;   /* @r{@code{y} bây giờ là ký tự `2' (không phải giá trị là 2).} */
z++;   /* @r{@code{z} bây giờ là 6.2.} */
++p;   /* @r{@code{p} bây giờ là @code{&x} + @code{sizeof(int)}.} */
@end group
@end example

@noindent
(Chú ý là việc gia một con trỏ chỉ khôn ngoan nếu như bạn có lý do để mà tin rằng
giá trị mới của con trỏ sẽ trong vùng nhớ hợp lệ.)

Việc gia số trước thêm 1 trước khi toán hạng được ước lượng.  Một sự gia
số sau thêm một sau khi toán hạng được ước lượng.  Trong ví dụ trước,
việc thay đổi vị trí của toán tử cũng không làm thay đổi gì.
Tuy nhiên, có một số trường hợp lại tạo ra sự khác biệt:

@example
@group
int x = 5;
printf ("%d \n", x++);    /* @r{In @code{x} ra màn hình sau đó mới gia số.} */
/* @r{@code{x} is now equal to 6.} */
printf ("%d \n", ++x);    /* @r{Gia số @code{x} lên và sau đó mới in ra màn hình.} */
@end group
@end example

@noindent
Kết xuất của ví dụ trên là:

@example
@group
5
7
@end group
@end example

Cũng giống vậy, bạn có thể trừ một từ toán hạng sử dụng toán tử giảm:

@example
@group
int x = 5;

x--; /* @r{@code{x} giờ là 4.} */
@end group
@end example

@noindent
Việc giảm trước và sau cũng giống như toán tử
gia được giới thiệu ở trên.

@node Toán tử Số học
@section Toán tử Số học
@cindex toán tử số học
@cindex toán tử, số học

C cung cấp các toán tử cho các tính toán số học: phép cộng, phép trừ,
phép nhân, và phép chia, cùng với phép chia lấy phần dư và phép phủ định.  Cách sử dụng
của những toán tử này không phức tạp; đây là một số ví dụ:

@example
@group
/* @r{Phép cộng.} */
x = 5 + 3;
y = 10.23 + 37.332;
quux_pointer = foo_pointer + bar_pointer;
@end group
@end example

@example
@group
/* @r{Phép trừ.} */
x = 5 - 3;
y = 57.223 - 10.903;
quux_pointer = foo_pointer - bar_pointer;
@end group
@end example

@noindent
Bạn có thể cộng và trừ bộ nhớ con trỏ, nhưng không thể nhân
hay chia chúng.

@example
@group
/* @r{Phép nhân.} */
x = 5 * 3;
y = 47.4 * 1.001;
@end group
@end example

@example
@group
/* @r{Phép chia.} */
x = 5 / 3;
y = 940.0 / 20.2;
@end group
@end example

@noindent
Sự chia hai số nguyên dương được cắt cụt phần thập phân phía sau, vậy thì 5/3 bằng
1.  Tuy nhiên, nếu một trong hai toán hạng là số âm, hướng làm tròn
được thực hiện.  @ref{Phép chia số Nguyên có Dấu} để
có thông tin thêm về tràn số âm trong phép chia số nguyên có dấu.

@c We should state how GCC behaves if an operand is negative.


Bạn có thể sử dụng toán tử modulus @code{%} để mà lấy được phần dư của
phép chia hai toán hạng.  Bạn đặt các toán hạng hai bên của toán
tử, và thứ tự các bên của toán hạng không giao hoán:
@code{3 % 5} và @code{5 % 3} là không có cùng kết quả.
Các toán hạng phải là biểu thức của một kiểu nguyên.

@example
@group
/* @r{Phép chia lầy Modular.} */
x = 5 % 3;
y = 74 % 47;
@end group
@end example

@noindent
Phép chia Modular trả về phân dư của việc chia hai toán hạng
số nguyên. Các toán hạng phải là kiểu dữ liệu
nguyên.

@example
@group
/* @r{Phép đảo.} */
int x = -5;
float y = -3.14159;
@end group
@end example

Nếu toán hạng bạn sử dụng với toán tử đảo (âm) với một kiểu dữ liệu
không dấu, thế thì kết quả sẽ không thể âm được, nhưng đúng hơn là
bít có giá trị lớn nhất của kiểu dữ liệu không dấu, chứa dấu trừ của toán hạng.

Nhiều hệ thống sử dụng hệ thống số bù hai, và trên những hệ thống như vậy
tất cả các giá trị âm của kiểu không dấu có thể lưu giữ ở xa số không hơn là
các giá trị dương.   Ví dụ, trên một hệ thống, chương
trình này:

@example
@group
#include <limits.h>
#include <stdio.h>

int main (int argc, char *argv[]) 
@{
  int x;
  x = INT_MAX;
  printf("INT_MAX  = %d\n", x);
  x = INT_MIN;
  printf("INT_MIN  = %d\n", x);
  x = -x;
  printf("-INT_MIN = %d\n", x);
  return 0;
@}
@end group
@end example

Sản phẩm đầu ra là:

@example
@group
INT_MAX  = 2147483647
INT_MIN  = -2147483648
-INT_MIN = -2147483648
@end group
@end example

Điều này không quan trọng, bạn còn có thể áp dụng toán tử dương (cộng)
cho một biểu thức số học:

@example
int x = +42;
@end example

@noindent
Numeric values are assumed to be positive unless explicitly made
negative, so this operator has no effect on program operation.

@node Toán tử Kết hợp cho Số phức
@section Toán tử Kết hợp cho Số phức
@cindex toán tử kết hợp cho số phức
@cindex kết hợp
 
Đây là phần mở rộng của GNU, bạn có thể sử dụng toán tử kết hợp cho số phức @code{~} để
mà thực hiện các phép toán trên toán hạng --- thật vậy, nó đảo ngược dấu
của phần ảo của nó.   Toán hạng phải là một biểu thức thuộc kiểu dữ liệu
số phức.  Đây là một ví dụ:
 
@example
@group
__complex__ int x = 5 + 17i;
 
printf ("%d  \n", (x * ~x));
@end group
@end example
 
Từ đó phần ảo của số phức @math{(a + bi)} được nhân bằng sự tiếp hợp thì bằng
@math{a^2 + b^2}, câu lệnh @code{printf} phía trên sẽ in ra 314, mà nó lại
bằng với @math{25 + 289}.

@node Toán tử So sánh
@section Toán tử So sánh
@cindex toán tử so sánh
@cindex toán tử, so sánh

Bạn sử dụng toán tử so sánh để mà phân định rõ sự tương quan giữa hai toán
hạng: có phải chúng như nhau, cái này lớn hơn cái kia,
cái này nhỏ hơn cái kia, và cứ thế.   Khi bạn sử dụng bất kỳ toán tử
so sánh nào, kết quả chỉ là 1 hoặc 0, nghĩa là đúng (true) hay sai (false),
một cách tương ứng.

(Trong ví dụ sau đây, biến @code{x} và @code{y} có thể
là hai biểu thức của kiểu số học hay con trỏ.)

Toán tử băng-với @code{==} kiểu tra hai toán hạng của nó về tính ngang bằng.
Kết quả là 1 nếu hai toán hạng bằng nhau và 0 nếu chúng không bằng.

@example
@group
if (x == y)
  puts (``x bằng với y'');
else
  puts (``x không bằng với y'');
@end group
@end example

Toán tử không-bằng @code{!=} kiểm tra sự khác nhau của hai toán hạng.
Kết quả trả về là một nếu hai toán hạng không bằng nhau và không nếu các toán hạng
@emph{là} như nhau.

@example
@group
if (x != y)
  puts (``x không bằng với y'');
else
  puts (``x bằng với y'');
@end group
@end example

Việc so sánh hai giá trị số chấm động theo cách thông thường
có thể tạo ra các kết quả không như mong muốn.  @ref{Kiểu Số Thực} để có
thêm thông tin.

Bạn có thể so sánh con trỏ hàm; quá trình so sánh
cho biết con trỏ có trả về cùng một hàm
hay không.

Ngoài việc so sánh bằng hay không như ở trên, có một số toán tử mà bạn có thể
sử dụng để mà kiểm tra một giá trị có nhỏ hơn, lớn hơn, nhỏ-hơn-hoặc-bằng, hay
lớn-hơn-hoặc-bằng một giá trị khác.  Đây là một số ví dụ mẫu mà nó
đưa ra các ví dụ minh họa về các toán tử này:

@example
@group
if (x < y)
  puts (``x nhỏ hơn y'');
@end group
@end example

@example
@group
if (x <= y)
  puts (``x nhỏ hơn hoặc bằng y'');
@end group
@end example

@example
@group
if (x > y)
  puts (``x lớn hơn y'');
@end group
@end example

@example
@group
if (x >= y)
  puts (``x lớn hơn hoặc bằng y'');
@end group
@end example


@node Toán tử Lô-gíc
@section Toán tử Lô-gíc
@cindex toán tử lô-gíc

Toán tử lô-gíc kiểm tra giá trị chân lý của một cặp toán hạng.  Bất kỳ
biểu thức khác không nào đều coi là đúng (true) trong C, trong khi một biểu thức mà
được ước tính là không sẽ được coi là sai (false).

Toán tử lô-gíc tiếp hợp @code{&&} kiểm tra xem cả hai biểu thức
có cùng đúng không.  Nếu biểu thức thứ nhất là sai, thế thì biểu thức
thứ hai không cần định giá nữa.

@example
@group
if ((x == 5) && (y == 10))
  printf (``x là 5 và y là 10'');
@end group
@end example

Toán tử lô-gíc tiếp hợp @code{||} kiểm tra xem có ít nhất một
trong hai biểu thức là đúng.  Nếu biểu thức thứ nhất là đúng, thế thì
biểu thức thứ hai không cần phải định giá nữa.

@example
@group
if ((x == 5) || (y == 10))
   printf (``x bằng 5 hay y là 10'');
@end group
@end example

Bạn có thể đặt trước một biểu thức lô-gíc một toán tử
phủ định @code{!} để lật ngược giá trị chân lý:

@example
@group
if (!(x == 5))
  printf (``x không là 5'');
@end group
@end example

Vì lẽ rằng toán hạng thứ hai trong cặp biểu thức lô-gíc không cần thiết phải
định giá, bạn có thể viết mã với kết quả có lẽ không trực giác:

@example
@group
if (foo && x++)
  bar();
@end group
@end example

@noindent
Nếu @code{foo} mãi là số không, thế thì không chỉ những hàm @code{bar} không được gọi,
mà @code{x} cũng sẽ không được gia số lên.  Nếu bạn có ý định gia số cho @code{x}
nà không cần biết giá trị của @code{foo} là gì, bạn phải viết biểu thức đó ra ngoài
chỗ toán tử tiếp hợp.


@node Dịch Bít
@section Dịch Bít Bit
@cindex dịch bít bit
@cindex dịch

Bạn có thể sử dụng toán tử dịch-trái @code{<<} để mà dịch chuyển bít của toán hạng
đầu tiên sang phía bên trái.  Toán hạng thứ hai là số vị trí bít cần dịch chuyển.
Các bít được đẩy ra ngoài phía bên trái của giá trị sẽ bị bỏ qua; các bít mối được
thêm vào từ phía bên phải tất cả đều là số không.

@example
@group
x = 47;    /* @r{47 là 00101111 ở dạng nhị phân.} */
x << 1;    /* @r{00101111 << 1 thành 01011110.} */
@end group
@end example

Cũng tương tự như thế, bạn có thể sử dụng toán tử dịch-phải @code{>>} để mà dịch chuyển
các bít của toán hạng thứ nhất sang phải. Số bít tràn ra ngoài cạnh phải
được bỏ đi; các bít mới được thêm vào cạnh trái @emph{thường} là số 0, nhưng
nếu toán hạng thứ nhất là kiểu có dấu, thế thì việc thêm bít sẽ hoặc là
0 @emph{hoặc là} còn phụ thuộc vào giá trị bít ngoài cùng bên
trái trước đó.

@example
@group
x = 47;   /* @r{47 là 00101111 ở dạng nhị phân.} */
x >> 1;   /* @r{00101111 >> 1 thành 00010111.} */
@end group
@end example

Đối với cả hai @code{<<} và @code{>>}, nếu toán hạng thứ hai lớn hơn
độ rộng bít của toán hạng thứ nhất, hay toán hạng thứ hai
kà âm, cách thực hiện là không được định nghĩa.

Bạn có thể sử dụng toán tử dịch để mà thực hiện được nhiều việc thú vị
khác nhau.  Ví dụ như, một ngày mà ngày của nó được coi là số
@code{d}, tháng là @code{m}, và năm là @code{y}, bạn
có thể lưu trữ các mục của ngày tháng này vào trong một số @code{x}:

@example
int d = 12;
int m = 6;
int y = 1983;
int x = ((y << 4) + m) << 5) +  d;
@end example

@noindent
Bạn có thẻ rút trích ngày, tháng và năm từ @code{x}
sử dụng kết hợp toán tử dịch và phép chia lấy phần dư:

@example
d = x % 32;
m = (x >> 5) % 16;
y = x >> 9;
@end example

@node Toán tử Lô-gíc trên Bít
@section Toán tử Lô-gíc trên Bít
@cindex toán tử lô-gíc trên bít
@cindex toán tử lô-gíc, trên bít

C cung cấp các toán tử để thi hành phép hội, phép tuyển không loại,
phép tuyển loại, và phép phủ định (lấy bù).

Phép hội trên bít thực thi trên từng bít tương ứng của hai toán hạng, và khi hai
bít tương ứng đều là 1 thì kết quả là 1.  Tất cả các trường hợp khác
kết quả là 0.  Đây là một ví dụ để thấy được nó hoạt động như thế nào, sử dụng số nhị phân:

@example
11001001 & 10011011 = 10001001
@end example

Phép tuyển không loại trên bít cũng thực hiện trên từng bít của hai toán hạng,
và khi hai bít này đều cùng là 0, bít kết quả sẽ là 0.  Tất cả các trường hợp
khác bít kết quả là 1.

@example
11001001 | 10011011 = 11011011
@end example

Phép tuyển không loại trên bít thực hiện trên từng bít của hai toán hạng, và khi
hai bít tương ứng là khác nhau, bít kết quả là 1.  Tất cả các trường hợp
khác bít kết quả là 0.

@example
11001001 ^ 10011011 = 01010000
@end example

Phép phủ định trên bít đảo ngược từng bít của toán hạng của nó:

@example
~11001001 = 00110110
@end example

Trong ngôn ngữ C, bạn chỉ có thể sử dụng các toán tử này với toán hạng là một kiểu số nguyên
(hay ký tự), và cho dễ thích nghi với các hệ thống khác nhau, bạn nên sử dụng toán tử phủ định trên bít
với kiểu nguyên không dấu.  Đây là một số ví dụ về việc sử dụng các toán tử này trong
mã C:

@example
@group
unsigned int foo = 42;
unsigned int bar = 57;
unsigned int quux;

quux = foo & bar;
quux = foo | bar;
quux = foo ^ bar;
quux = ~foo;
@end group
@end example

@node Toán tử Con trỏ
@section Toán tử Con trỏ
@cindex toán tử con trỏ

Bạn có thể sử dụng toán tử lấy địa chỉ @code{&} để có được địa chỉ bộ nhớ của một
đối tượng.

@example
@group
int x = 5;
int *pointer_to_x = &x;
@end group
@end example

Việc sử dụng toán tử này để lấy được địa chỉ của một hàm là không thực sự
cần thiết, cho dù bạn vẫn có thể làm thế:

@example
@group
extern int foo (void);
int (*fp1) (void) = foo; /* fp1 chỉ đến foo */
int (*fp2) (void) = &foo; /* fp1 cũng chỉ đến foo */
@end group
@end example

Con trỏ hàm và con trỏ dữ liệu là không tương thích nhau, về ý nghĩa
rằng bạn không thể kỳ vọng lưu trữ địa chỉ của một hàm vào vào trong một con trỏ
dữ liệu, và sau đó sao chép nó vào một con trỏ hàm và gọi nó
được.  Nó có thể hoạt động trên một số hệ thống, nhưng nó không tương thích
về mặt kỹ thuật.

Với phân mở rộng GNU C89, bạn cũng còn có thể lấy được địa chỉ của một nhãn
bằng toán tử lấy địa chỉ nhãn @code{&&}.  Kết quả là một con
trỏ @code{void*} mà nó có thể sử dụng với câu lệnh @code{goto}.  @xref{
Câu lệnh goto}.

Với địa chỉ bộ nhớ xác định được lưu trữ trong một con trỏ, bạn có thể sử dụng toán tử
gián tiếp @code{*} để có thể có được giá trị tại địa chỉ. (Đây được gọi là
con trỏ @dfn{tham chiếu}.)

@example
@group
int x = 5;
int y;
int *ptr;

ptr = &x;    /* @r{@code{ptr} bây giờ giữ địa chỉ của @code{x}.} */

y = *ptr;    /* @r{@code{y} lấy giá trị lưu trong địa chỉ}
                @r{được lưu trữ trong @code{ptr}.} */
@end group
@end example

@noindent
Tránh việc sử dụng con trỏ tham chiếu mà nó được khởi tạo vào
một vị trí bộ nhớ không xác định.


@node Toán tử sizeof
@section Toán tử sizeof
@cindex toán tử sizeof

Bạn có thể sử dụng toán tử @code{sizeof} để lấy kích thước (bằng bytes)
của kiểu dữ liệu của toán hạng của nó.  Toán hạng có thể là một kiểu được chỉ
ra, như là @code{int} hay @code{float}), cũng còn có thể là bất kỳ một
biểu thức hợp lệ nào.  Khi toán hạng là tên một kiểu, nó phải được bao trong cặp
dấu ngoặc.  Đây là một số ví dụ:

@example
@group
size_t a = sizeof(int);
size_t b = sizeof(float);
size_t c = sizeof(5);
size_t d = sizeof(5.143);
size_t e = sizeof a;
@end group
@end example

Kết quả trả về từ toán tử @code{sizeof} thì thuộc một kiểu có tên @code{size_t},
mà nó được định nghĩa trong file @code{<stddef.h>}.  @code{size_t} là kiểu
số nguyên không dấu, có lẽ là đồng nhất với @code{unsigned int} hay
@code{unsigned long int}; nó biến đổi phụ thuộc vào từng hệ thống.

Kiểu @code{size_t} là kiểu thường thích hợp cho chỉ số vòng lặp,
vì lẽ rằng nó được đảm bảo rằng có thể giữ số các phần tử trong
một mảng; Điểu này không chỉ đúng với trường hợp kiểu @code{int}, ví dụ.

Toán tử @code{sizeof} có thể sử dụng để tính toán tự động số
phần tử trong một mảng:

@example
@group
#include <stddef.h>
#include <stdio.h>

static const int values[] = @{ 1, 2, 48, 681 @};
#define ARRAYSIZE(x) (sizeof x/sizeof x[0])

int main (int argc, char *argv[]) 
@{
    size_t i;
    for (i = 0; i < ARRAYSIZE(values); i++) 
    @{
        printf("%d\n", values[i]);
    @}
    return 0;
@}
@end group
@end example

Có hai trường hợp mà kỹ thuật này không dùng được.  Đầu tiên là
mảng mà phần tử đầu có kích thước là không (GCC hỗ trợ cấu trúc có
kích-thước-bằng-không đây là phần mở rộng của GNU).  Trường hợp thứ hai là mảng là
tham số cho một hàm (@pxref{Tham số Hàm}).

@node Áp đổi Kiểu
@section Áp đổi Kiểu
@cindex áp đổi kiểu
@cindex áp đổi

Bạn có thể sử dụng áp đổi kiểu để biểu thức trả về kiểu dữ liệu
bạn mong muốn.  Việc áp đổi kiểu bao gồm kiểu được chỉ ra bao quanh bằng cặp dấu ngoặc đơn,
theo sau là một biểu thức.  Để chắc chắn hơn, bạn cũng nên đóng biểu thức
theo sau đó bằng cặp dấu ngoặc đơn.  Đây là một
ví dụ:

@example
@group
float x;
int y = 7;
int z = 3;
x = (float) (y / z);
@end group
@end example

Trong ví dụ đó, vì lẽ @code{y} và @code{z} đều thuộc kiểu nguyên, phép chia
số nguyên sẽ được thực hiện, và thậm chỉ là cho dù @code{x} thuộc kiểu biến
dấu chấm động, nó vẫn nhận về giá trị là 2.  Rõ ràng là việc áp đổi kết quả
phép chia thành @code{float} không tốt, bởi vì việc tính toán
biểu thức @code{y/z} đã là 2 trước rồi.

Để mà sửa lỗi này, bạn cần chuyển đổi kiểu của một trong hai toán hạng
thành kiểu dấu chấm động trước khi đặt phép chia:

@example
@group
float x;
int y = 7;
int z = 3;
x = (y / (float)z);
@end group
@end example

@noindent Ở đây, giá trị đấu chấm động 2.333@dots{} được gán cho @code{x}.

Việc áp đổi kiểu chỉ hoạt động với các kiểu vô hướng (đó là kiểu nguyên,
dấu chấm động hay là con trỏ).  Thành ra, điểu này là không được phép:

@example
@group
struct fooTag @{ /* các thành viên ... */ @};
struct fooTag foo;
unsigned char byteArray[8];

foo = (struct fooType) byteArray; /* @r{Lỗi!} */
@end group
@end example

@node Array Subscripts
@section Array Subscripts
@cindex array subscripts

You can access array elements by specifying the name of the array, and the
array subscript (or index, or element number) enclosed in brackets.  Here is
an example, supposing an integer array called @code{my_array}:

@example
@group
my_array[0] = 5;
@end group
@end example

The array subscript expression @code{A[i]} is defined as being
identical to the expression @code{(*((A)+(i)))}.  This means that many
uses of an array name are equivalent to a pointer expression.  It also
means that you cannot subscript an array having the @code{register}
storage class.

@node Function Calls as Biểu thức
@section Function Calls as Biểu thức
@cindex function calls, as expressions

A call to any function which returns a value is an expression.

@example
@group
int function(void);
@dots{}
a = 10 + function();
@end group
@end example


@node The Comma Operator
@section The Comma Operator
@cindex comma operator

You use the comma operator @code{,} to separate two (ostensibly related) expressions.
For instance, the first expression might produce a value that is used by the second
expression:
@c This works because there is a sequence point after the evaluation
@c of the left hand side.
@example
@group
x++, y = x * x;
@end group
@end example

More commonly, the comma operator is used in @code{for} statements, like
this:

@example
@group
/* @r{Using the comma operator in a @code{for} statement.} */

for (x = 1, y = 10;  x <=10 && y >=1;  x++, y--)
  @{
    @dots{}
  @}
@end group
@end example

@noindent
This lets you conveniently set, monitor, and modify multiple control
expressions for the @code{for} statement.

A comma is also used to separate function parameters; however, this
is @emph{not} the comma operator in action.   In fact, if the comma
operator is used as we have discussed here in a function call, then
the compiler will
interpret that as calling the function with an extra parameter.

If you want to use the comma operator in a function argument, you need
to put parentheses around it.  That's because commas in a function
argument list have a different meaning: they separate arguments.
Thus,

@example
foo (x,  y=47,  x,  z);
@end example

@noindent
is interpreted as a function call with four arguments, but

@example
foo (x,  (y=47,  x),  z);
@end example

@noindent
is a function call with just three arguments.  (The second argument is
@code{(y=47, x)}.)

@node Member Access Biểu thức
@section Member Access Biểu thức
@cindex member access expressions

You can use the member access operator @code{.} to access the members
of a structure or union variable.  You put the name of the structure
variable on the left side of the operator, and the name of the
member on the right side.

@example
@group
struct point
@{
  int x, y;
@};

struct point first_point;

first_point.x = 0;
first_point.y = 5;
@end group
@end example

@cindex indirect member access operator
You can also access the members of a structure or union variable via
a pointer by using the indirect member access operator @code{->}.
@code{x->y} is equivalent to @code{(*x).y}.

@example
@group
struct fish
  @{
    int length, weight;
  @};

struct fish salmon;

struct fish *fish_pointer = &salmon;

fish_pointer->length = 3;
fish_pointer->weight = 9;
@end group
@end example 

@xref{Pointers}.


@node Conditional Biểu thức
@section Conditional Biểu thức
@cindex conditional expressions
@cindex expressions, conditional
@cindex ternary operator

You use the conditional operator to cause the entire conditional
expression to evaluate to either its second or its third operand, based
on the truth value of its first operand.  Here's an example:

@example
a ? b : c
@end example

If expression @code{a} is true, then expression @code{b} is evaluated
and the result is the value of @code{b}.  Otherwise, expression
@code{c} is evaluated and the result is @code{c}.  

Biểu thức @code{b} and @code{c} must be compatible.   That is, they
must both be 

@enumerate
@item arithmetic types
@item compatible @code{struct} or @code{union} types
@item pointers to compatible types (one of which might be the NULL pointer)
@end enumerate 

Alternatively, one operand is a pointer and the other is a
@code{void*} pointer.

Here is an example

@example
a = (x == 5) ? y : z;
@end example

Here, if @code{x} equals 5, then @code{a} will receive
the value of @code{y}.  Otherwise, @code{a} will receive the value of
@code{z}.  This can be considered a shorthand method for writing a simple
@code{if}@dots{}@code{else} statement.  The following example will
accomplish the same task as the previous one:

@example
@group
if (x == 5)
    a = y;
else
    a = z;
@end group
@end example

If the first operand of the conditional operator is true, then the third
operand is never evaluated.  Similarly, if the first operand is false,
then the second operand is never evaluated.  The first operand is always
evaluated.


@c GNU C Extension

@node Statements and Declarations in Biểu thức
@section Statements and Declarations in Biểu thức
@cindex statements inside expressions
@cindex declarations inside expressions
@cindex expressions containing statements
@cindex macros, statements in expressions

As a GNU C extension, you can build an expression using compound
statement enclosed in parentheses.  This allows you to included
loops, switches, and local variables within an expression.

Recall that a compound statement (also known as a block) is a sequence of
statements surrounded by braces.  In this construct, parentheses go around
the braces.  Here is an example:

@example
@group
(@{ int y = function (); int z;
    if (y > 0) z = y;
   else z = - y;
   z; @})
@end group
@end example

That is a valid (though slightly more complex than necessary) expression
for the absolute value of @code{function ()}.

The last thing in the compound statement should be an expression
followed by a semicolon; the value of this subexpression serves as the
value of the entire construct.  (If you use some other kind of statement
last within the braces, the construct has type @code{void}, and thus
effectively no value.)

This feature is especially useful in making macro definitions ``safe'' (so
that they evaluate each operand exactly once).  For example, the
``maximum'' function is commonly defined as a macro in standard C as
follows:

@example
#define max(a,b) ((a) > (b) ? (a) : (b))
@end example

@noindent
@cindex side effects, macro argument
But this definition computes either @code{a} or @code{b} twice, with bad
results if the operand has side effects.  In GNU C, if you know the
type of the operands (here let's assume @code{int}), you can define
the macro safely as follows:

@example
#define maxint(a,b) \
  (@{int _a = (a), _b = (b); _a > _b ? _a : _b; @})
@end example

If you don't know the type of the operand, you can still do this, but you
must use @code{typeof} expressions or type naming.

@comment Add reference to typeof

Embedded statements are not allowed in constant expressions, such as
the value of an enumeration constant, the width of a bit field, or
the initial value of a static variable.


@node Operator Precedence
@section Operator Precedence in C
@cindex operator precedence
@cindex precedence, operator

When an expression contains multiple toán tử, such as @code{a + b *
f()}, the toán tử are grouped based on rules of @dfn{precedence}.
For instance, the meaning of that expression is to call the function
@code{f} with no arguments, multiply the result by @code{b}, then add
that result to @code{a}.  That's what the C rules of operator
precedence determine for this expression.

The following is a list of types of expressions, presented in order of
highest precedence first.  Sometimes two or more toán tử have equal
precedence; all those toán tử are applied from left to right
unless stated otherwise.

@enumerate

@item
Function calls, array subscripting, and membership access operator
expressions.

@item
Unary toán tử, including logical negation, bitwise complement,
increment, decrement, unary positive, unary negative, indirection
operator, address operator, type casting, and @code{sizeof}
expressions.  When several unary toán tử are consecutive,
the later ones are nested within the earlier ones: @code{!-x}
means @code{!(-x)}.

@item
Multiplication, division, and modular division expressions.

@item
Addition and subtraction expressions.

@item
Bitwise shifting expressions.

@item
Greater-than, less-than, greater-than-or-equal-to, and less-than-or-equal-to@*
expressions.

@item
Equal-to and not-equal-to expressions.

@item
Bitwise AND expressions.

@item
Bitwise exclusive OR expressions.

@item
Bitwise inclusive OR expressions.

@item
Logical AND expressions.

@item
Logical OR expressions.

@item
Conditional expressions (using @code{?:}).  When used as
subexpressions, these are evaluated right to left.

@item
All assignment expressions, including compound assignment.  When multiple
assignment statements appear as subexpressions in a single larger expression,
they are evaluated right to left.

@item
Comma operator expressions.

@end enumerate

@c ??? Lots more examples are needed here!

@c ??? You need to explain when parentheses are strongly
@c recommended in order to make the structure clear.

The above list is somewhat dry and is apparently straightforward, but
it does hide some pitfalls.  Take this example:

@example
foo = *p++;
@end example

Here @code{p} is incremented as a side effect of the expression, but
@code{foo} takes the value of @code{*(p++)} rather than @code{(*p)++},
since the unary operators bind right to left.   There are other
examples of potential surprises lurking behind the C precedence
table.  For this reason if there is the slightest risk of the reader
misunderstanding the meaning of the program, you should use
parentheses to make your meaning clear.

@node Order of Evaluation
@section Order of Evaluation

In C you cannot assume that multiple subexpressions are evaluated in
the order that seems natural.  For instance, consider the expression
@code{++a * f()}.  Does this increment @code{a} before or after
calling the function @code{f}?  The compiler could do it in either
order, so you cannot make assumptions.

This manual explains the semantics of the C language in the abstract.
However, an actual compiler translates source code into specific
actions in an actual computer, and may re-order operations for the
sake of efficiency.  The correspondence between the program you write
and the things the computer actually does are specified in terms of
@emph{side effects} and @emph{sequence points}.

@menu
* Side Effects::
* Sequence Points::
* Sequence Points Constrain Biểu thức::
* Sequence Points and Signal Delivery::
@end menu

@node Side Effects
@subsection Side Effects

@cindex side effect
A @dfn{side effect} is one of the following:
@enumerate
@item accessing a @code{volatile} object
@item modifying an object
@item modifying a file
@item a call to a function which performs any of the above side effects
@end enumerate

These are essentially the externally-visible effects of running a
program.   They are called side effects because they are effects of
expression evalation beyond the expression's actual resulting value.

The compiler is allowed to perform the operations of your program in
an order different to the order implied by the source of your program, 
provided that in the end all the necessary side effects actually take
place. The compiler is also allowed to entirely omit some operations;
for example it's allowed to skip evaluating part of an expression if
it can be certain that the value is not used and evaluating that part
of the expression won't produce any needed side effects.

@node Sequence Points
@subsection Sequence Points

Another requirement on the compiler is that side effects should take
place in the correct order.  In order to provide this without
over-constraining the compiler, the C89 and C90 standards specfy a
list of sequence points.  A @dfn{sequence point} is one of the
following:

@cindex sequence point
@enumerate
@c authority: C99 standard, annex C
@item a call to a function (after argument evaluation is complete)
@item the end of the left-hand operand of the and operator @code{&&}
@item the end of the left-hand operand of the or operator @code{||}
@item the end of the left-hand operand of the comma operator @code{,}
@item the end of the first operand of the ternary operator @code{a ? b : c}
@item the end of a full declarator
@footnote{a full declarator is a declaration of a function or an object which is not part of another object}
@item the end of an initialisation expression 
@item the end of an expression statement (i.e. an expression followed by @code{;})
@item the end of the controlling expression of an @code{if} or @code{switch} statement
@item the end of the controlling expression of a @code{while} or @code{do}statement
@item the end of any of the three controlling expressions of a @code{for} statement
@item the end of the expression in a return statement
@item immediately before the return of a library function
@item after the actions associated with an item of formatted I/O (as
used for example with the @code{strftime} or the @code{printf} and
@code{scanf} famlies of functions).
@item immediately before and after a call to a comparison function (as
called for example by @code{qsort})
@end enumerate

@c authority: C99 standard, section 5.1.2.3
At a sequence point, all the side effects of previous expression
evaluations must be complete, and no side effects of later evaluations
may have taken place.

@c authority: C89 standard, section 5.1.2.3
@c this description was not included in C99, I assume because of the 
@c introduction of whole-program optimisation
This may seem a little hard to grasp, but there is another way to
consider this.  Imagine you wrote a library (some of whose functions
are external and perhaps others not) and compiled it, allowing someone
else to call one of your functions from their code.  The definitions
above ensure that, at the time they call your function, the data they
pass in has values which are consistent with the behaviour specified
by the abstract machine, and any data returned by your function has a
state which is also consistent with the abstract machine.  This
includes data accessible via pointers (i.e. not just function
parameters and identifiers with external linkage).

The above is a slight simplification, since compilers exist that
perform whole-program optimisation at link time.  Importantly however,
although they might perform optimisations, the visible side effects of
the program must be the same as if they were produced by the abstract
machine.

@node Sequence Points Constrain Biểu thức
@subsection Sequence Points Constrain Biểu thức

@c authority: C89 section 6.3, C99 section 6.5
The code fragment 
@example
i = i + 1;
@end example 
is quite normal and no doubt occurs in many programs.  However, the
quite similar code fragment
@example
i = ++i + 1;
@end example 
is a little harder to understand; what is the final value of @code{i}?
The C standards (both C89 and C99) both forbid this construct in 
conforming programs.  

Between two sequence points, 
@enumerate
@item an object may have its stored value modified at most once by the
evaluation of an expression
@item the prior value of the object shall be read only to determine
the value to be stored.
@end enumerate

The first of these two conditions forbids expressions like 
@code{foo(x=2, ++x)}.  The second condition forbids expressions like
@code{a[i++] = i}.

@c with an appropriate list of counterexamples such as f(x++, x++).

@table @code
@item int x=0; foo(++x, ++x)
Not allowed in a conforming program; modifies @code{x} twice before
argument evaluation is complete. 
@item int x=0; bar((++x,++x))
Allowed; the function @code{bar} takes one argument (the value 2
is passed here), and there is a sequence point at the comma operator.
@item *p++ || *p++
Allowed; there is a sequence point at @code{||}.
@item int x = 1, y = x++;
Allowed; there is a sequence point after the full declarator of @code{x}.
@item x=2; x++;
Allowed; there is a sequence point at the end of the first expression
statement.
@item if (x++ > MAX) x = 0;
Allowed; there is a sequence point at the end of the controlling
expression of the @code{if}@footnote{However if for example @code{MAX} is
@code{INT_MAX} and @code{x} is of type @code{int}, we clearly have a
problem with overflow.  @xref{Overflow}.}.
@item (x=y) ? ++x : x--;
Allowed; there is a sequence point before the @code{?}, and only one
of the two following expressions is evaluated.
@item int *p=malloc(sizeof(*p)), *q=p;  *p=foo(); bar((*p)++,(*q)++);
Not allowed; the object at @code{p} is being modified twice
before the evaluation of the arguments to @code{bar} is complete.  The
fact that this is done once via @code{p} and once via @code{q} is
irrelevant, since they both point to the same object.
@end table

Let's go back to the example we used to introduce the problem of the
order of evaluation, @code{++a * f()}.   Suppose the code actually
looks like this:

@example
@group
static int a = 1;

static int f (void)
@{
  a = 100;
  return 3;
@}

int foo (void)
@{
   return ++a * f();
@}
@end group
@end example

Is this code allowed in a standard-conforming program?  Although the
expression in @code{foo} modifies @code{a} twice, this is not a
problem.  Let's look at the two possible cases.

@table @asis
@item The right operand @code{f()} is evaluated first
Since @code{f} returns a value other than void, it must contain a
@code{return} statement.   Therefore, there is a sequence point at the
end of the return expression.  That comes between the modification to
@code{a} that @code{f} makes and the evaluation of the left operand.
@item The left operand @code{++a} is evaluated first
First, @code{a} is incremented.   Then the arguments to @code{f} are
evaluated (there are zero of them).  Then there is a sequence point
before @code{f} is actually called.
@end table

@c C99 does not state explicitly that there is a sequence point after
@c argument evaluation if a function call contains zero arguments.
So, we see that our program is standard-conforming.  Notice that the
above argument does not actually depend on the details of the body of
the function @code{f}.  It only depends on the function containing
something ending in a sequence point -- in our example this is a
return statement, but an expression statement or a full declarator
would do just as well.

@cindex unspecified behaviour
However, the result of executing this code depends on the order of
evaluation of the operands of @code{*}.  If the left-hand operand is
evaluated first, @code{foo} returns 6.  Otherwise, it returns 303.
The C standard does not specify in which order the operands should be
evaluated, and also does not require an implementation either to
document the order or even to stick to one order.  The effect of this
code is @dfn{unspecified}, meaning that one of several specific
things will happen, but the C standards do not say which.



@node Sequence Points and Signal Delivery
@subsection Sequence Points and Signal Delivery

Singals are mainly documented in the GNU C Library manual rather than
this document, even though the C standards consider the compiler and
the C library together to be ``the implementation''.

@c [This scene-setting is probably too long. - jay@gnu.org]
@c
@c Your C program can be notified of asynchronous events by the
@c @dfn{signal} mechanism.  There are a few dozen different possible
@c signals; these include for example @code{SIGINT}, which tells your
@c program that the user pressed the keyboard interrupt key, and
@c @code{SIGFPE} which tells your program that an arithmetic overflow has
@c occurred.  Signals can be asyncronous, for example @code{SIGINT}
@c generally arises outside your program, or normally synchronous like
@c @code{SIGFPE} or @code{SIGABRT} (which indicates your program called
@c the @code{abort} function, directly or indirectly).  Signals can also
@c be sent using the @code{kill} and @code{raise} functions.
@c 
@c All signals have a default effect, usually to terminate the program.
@c However, you can set up a @dfn{signal handler} -- a funciton to be
@c called when a specified signal is delivered.


When a signal is received, this will happen between sequence points.
Side effects on @code{volatile} objects prior to the previous sequence
point will have occurred, but other updates may not have occurred
yet.  This even applies to straight assignments, such as @code{x=0;},
because the code generated for that statement may require more than
one instruction, meaning that it can be interrupted part-way through
by the delivery of a signal.

The C standard is quite restrictive about what data access can occur
within a signal handler.  They can of course use @code{auto}
variables, but in terms of reading or writing other objects, they must
be @code{volatile sig_atomic_t}.  The @code{volatile} type qualifier
ensures that access to the variable in the other parts of the program
doesn't span sequence points and the use of the @code{sig_atomic_t}
type ensures that changes to the variable are atomic with respect to
signal delivery.

The POSIX standard also allows a small number of library functions to
be called from a signal handler.  These functions are referred to as
the set of @dfn{async-signal-safe} functions.  If your program is
intended to run on a POSIX system but not on other systems, you can
safely call these from your signal handler too.

@node Overflow
@section Overflow

@include overflow.texi

