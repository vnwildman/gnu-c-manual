@c ??? It might be a good idea to turn each example of an expression
@c into a small program that prints output and thus shows what
@c the expression does.

@c This is part of The GNU C Reference Manual
@c Copyright (C) 2007-2011 Free Software Foundation, Inc.
@c See the file gnu-c-manual.texi for copying conditions.

@node Biểu thức và Toán tử
@chapter Biểu thức và Toán tử

@menu
* Biểu thức::
* Toán tử Gán::
* Gia và Giảm::
* Toán tử Số học::
* Toán tử Kết hợp với Số phức::
* Toán tử So sánh::
* Toán tử Logical::
* Bit Shifting::
* Bitwise Logical Toán tử::
* Pointer Toán tử Con trỏ::
* Toán tử sizeof::
* Type Casts::
* Array Subscripts::
* Function Calls as Biểu thức::
* Toán tử Dấu phẩy::
* Member Access Biểu thức::
* Conditional Biểu thức::
* Statements and Declarations in Biểu thức::
* Operator Precedence::
* Mức ưu tiên::
* Tràn::
@end menu

@node Biểu thức
@section Biểu thức
@cindex biểu thức

Một @dfn{biểu thức} gồm có ít nhất là một toán hạng không hoặc nhiều hơn một
toán tử.  Đối tượng kiểu của toán hạng như là hằng, biến, và
giá trị trả về từ cú gọi hàm.  Đây là một số ví dụ:

@example
@group
47
2 + 2
cosine(3.14159) /* @r{Chúng ta giả sử rằng nó trả về giá trị dấu chấm động.} */
@end group
@end example

Các dấu ngoặc đơn dùng để nhóm các biểu thức con:

@example
( 2 * ( ( 3 + 10 ) - ( 2 * 6 ) ) )
@end example

@noindent
Biểu thức ở trong cùng được định giá trước.  Trong ví dụ trên,
@code{3 + 10} và @code{2 * 6} được định giá là @code{13} và @code{12},
tương ứng.  Sau đó @code{12} được trừ đi
@code{13}, kết quả là một @code{1}.  Cuối cùng, @code{1} được nhân với
@code{2}, kết quả là @code{2}.  Cặp dấu ngoặc ngoài cùng chỉ là
tùy chọn.

@cindex toán tử

Một @dfn{toán tử} định ra một hành động để thực thi trên toán hạng.
Toán tử có thể có một, hai hay nhiều toán hạng, còn phụ thuộc vào toán tử.

@node Toán tử Gán
@section Toán tử Gán
@cindex toán tử gán
@cindex toán tử, gán

Toán tử gán đưa giá trị lưu trữ vào biến.  C cung cấp nhiều biến thể
khác nhau của toán tử gán.

Toán tử gán theo tiêu chuẩn @code{=} đơn giản chỉ lưu trữ giá trị của
toán hạng bên phải của nó vào biến được chỉ ra ở toán hạng bên trái.  Với
mọi toán tử gán, toán hạng bên trái (thông thường được xem như là
``lvalue'') không thể là dạng văn bản hay hằng giá trị.

@example
@group
int x = 10;
float y = 45.12 + 2.0;
int z = (2 * (3 + function () ));

struct foo @{
  int bar;
  int baz;
@} quux = @{3, 4, 5@};
@end group
@end example

@noindent
Chú ý rằng, không giống như phần mô tả các toán tử gán ở phía dưới, bạn
có thể sử dụng toán tử gán thường để mà lưu trữ giá trị của kiểu
cấu trúc.

Toán tử gán phức hợp thực hiện việc thi hành perform an operation bao gồm
cả hai phía trái và phải của các toán tử, và sau đó gán kết quả của
biểu thức cho toán hạng trái.  Sau đây là danh sách các toán tử
gán phức hợp, và mô tả vắn tắt về hoạt động của chúng:

@itemize

@item
@code{+=}

Cộng hai toán hạng với nhau, sau đó thì gán kết quả của phép
cộng cho toán hạng bên trái.

@item
@code{-=}

Trừ toán hạng bên phải cho toán hạng bên trái, và
sau đó thì gán kết quả của phép trừ cho toán hạng bên trái.

@item
@code{*=}

Nhân hai toán hạng với nhau, sau đó thì gán kết quả của phép
nhân cho toán hạng bên trái.

@item
@code{/=}

Lấy toán hạng bên trái chia cho toán hạng bên phải, và
gán kết quả cho toán hạng bên trái.

@item
@code{%=}

Thực hiện phép lấy chia lấy phần dư trên hai toán hạng, và
gán kết quả cho toán hạng bên trái.

@item
@code{<<=}

Thực hiện việc đẩy trái toán hạng trái, số bít
được đẩy được chỉ định bởi toán hạng bên phải, và gán
kết quả của quá trình đẩy này cho toán hạng bên trái.

@item
@code{>>=}

Thực hiện việc đẩy phải toán hạng trái, số bít
được đẩy được chỉ định bởi toán hạng bên phải, và gán
kết quả của quá trình đẩy này cho toán hạng bên trái.

@item
@code{&=}

Thực hiện phép luận lý VÀ trên bít (bitwise) trên hai toán hạng, và
gán kết quả sau khi thực hiện cho toán hạng bên phải.

@item
@code{^=}

Thực hiện phép luận lý LOẠI TRỪ trên bít (bitwise) trên hai toán hạng, và
gán kết quả sau khi thực hiện cho toán hạng bên phải.

@item
@code{|=}

Thực hiện phép luận lý HOẶC trên bít (bitwise) trên hai toán hạng, và
gán kết quả sau khi thực hiện cho toán hạng bên phải.

@end itemize
@comment  __End of compound assignment operator list

Đây là một ví dụ về việc sử dụng toán tử gán phức hợp:

@example
x += y;
@end example

@noindent
Từ đó không có kết quả cuối cùng khác biệt nào bởi việc định giá biến
@code{x} là một lvalue (giá trị có địa chỉ), đoạn mã trên có cùng kết quả với:

@example
x = x + y;
@end example


@c GNU C Extension -- temporarily commented out for manual 0.1
@c @node Generalized Lvalues
@c @subsubsection Generalized Lvalues
@c @cindex compound expressions as lvalues
@c @cindex expressions, compound, as lvalues
@c @cindex conditional expressions as lvalues
@c index expressions, conditional, as lvalues
@c @cindex casts as lvalues
@c @cindex generalized lvalues
@c @cindex lvalues, generalized
@c @cindex extensions, @code{?:}
@c @cindex @code{?:} extensions
@c 
@c Compound expressions, conditional expressions and casts are allowed as
@c lvalues provided their operands are lvalues.  This means that you can take
@c their addresses or store values into them.
@c 
@c For example, you can assign a value to a compound expression, provided the
@c last expression in the sequence is an lvalue.  These two expressions are
@c equivalent:
@c 
@c @example
@c (a, b) += 5
@c a, (b += 5)
@c @end example
@c 
@c Similarly, you can take the address of a compound expression.  So, these two
@c expressions are equivalent:
@c 
@c @example
@c &(a, b)
@c a, &b
@c @end example
@c 
@c A conditional expression is a valid lvalue if its type is not void and if
@c both the second and third operands are valid lvalues.  For example, these two
@c expressions are equivalent:
@c 
@c @example
@c (a ? b : c) = 5
@c (a ? b = 5 : (c = 5))
@c @end example
@c 
@c A type cast is a valid lvalue if its operand is an lvalue.  A simple
@c assignment whose left-hand side is a cast works by converting the
@c right-hand side first to the specified type, then to the type of the
@c inner left-hand side expression.  After this is stored, the value is
@c converted back to the specified type to become the value of the
@c assignment.  Thus, if @code{a} has type @code{char *}, the following two
@c expressions are equivalent:
@c 
@c @example
@c (int)a = 5
@c (int)(a = (char *)(int)5)
@c @end example
@c 
@c An assignment-with-arithmetic operation such as @code{+=} applied to a cast
@c performs the arithmetic using the type resulting from the cast, and then
@c continues as in the previous case.  Therefore, these two expressions are
@c equivalent:
@c 
@c @example
@c (int)a += 5
@c (int)(a = (char *)(int) ((int)a + 5))
@c @end example

@c You cannot take the address of an lvalue cast, because the use of its
@c address would not work out coherently.  Suppose that @code{&(int)f} were
@c permitted, where @code{f} has type @code{float}.  Then the following
@c statement would try to store an integer bit-pattern where a floating
@c point number belongs:
@c 
@c @example
@c *&(int)f = 1;
@c @end example
@c 
@c This is quite different from what @code{(int)f = 1} would do---that
@c would convert 1 to floating point and store it.  Rather than cause this
@c inconsistency, we think it is better to prohibit use of @code{&} on a cast.
@c 
@c If you really do want an @code{int *} pointer with the address of
@c @code{f}, you can simply write @code{(int *)&f}.

@node Gia và Giảm
@section Gia và Giảm
@cindex toán tử gia
@cindex toán tử giảm
@cindex toán tử, gia
@cindex toán tử, giảm

Toán tử gia số @code{++} thêm 1 vào toán hạng của nó.  Toán hạng phải
hoặc là biến thuộc một kiểu dữ liệu cơ bản, một con trỏ, hay một
biến thuộc kiểu liệt kê.  Bạn có thể áp dụng toán tử gia trước cũng như sau
toán hạng.  Đây là một số ví dụ:

@example
@group
char w = '1';
int x = 5;
char y = 'B';
float z = 5.2;
int *p = &x;

x++;   /* @r{@code{x} bây giờ là 6.} */
++y;   /* @r{@code{y} bây giờ là `C' (on ASCII systems).} */
++w;   /* @r{@code{y} bây giờ là ký tự `2' (không phải giá trị là 2).} */
z++;   /* @r{@code{z} bây giờ là 6.2.} */
++p;   /* @r{@code{p} bây giờ là @code{&x} + @code{sizeof(int)}.} */
@end group
@end example

@noindent
(Chú ý là việc gia một con trỏ chỉ khôn ngoan nếu như bạn có lý do để mà tin rằng
giá trị mới của con trỏ sẽ trong vùng nhớ hợp lệ.)

Việc gia số trước thêm 1 trước khi toán hạng được ước lượng.  Một sự gia
số sau thêm một sau khi toán hạng được ước lượng.  Trong ví dụ trước,
việc thay đổi vị trí của toán tử cũng không làm thay đổi gì.
Tuy nhiên, có một số trường hợp lại tạo ra sự khác biệt:

@example
@group
int x = 5;
printf ("%d \n", x++);    /* @r{In @code{x} ra màn hình sau đó mới gia số.} */
/* @r{@code{x} is now equal to 6.} */
printf ("%d \n", ++x);    /* @r{Gia số @code{x} lên và sau đó mới in ra màn hình.} */
@end group
@end example

@noindent
Kết xuất của ví dụ trên là:

@example
@group
5
7
@end group
@end example

Cũng giống vậy, bạn có thể trừ một từ toán hạng sử dụng toán tử giảm:

@example
@group
int x = 5;

x--; /* @r{@code{x} giờ là 4.} */
@end group
@end example

@noindent
Việc giảm trước và sau cũng giống như toán tử
gia được giới thiệu ở trên.

@node Toán tử Số học
@section Toán tử Số học
@cindex toán tử số học
@cindex toán tử, số học

C cung cấp các toán tử cho các tính toán số học: phép cộng, phép trừ,
phép nhân, và phép chia, cùng với phép chia lấy phần dư và phép phủ định.  Cách sử dụng
của những toán tử này không phức tạp; đây là một số ví dụ:

@example
@group
/* @r{Phép cộng.} */
x = 5 + 3;
y = 10.23 + 37.332;
quux_pointer = foo_pointer + bar_pointer;
@end group
@end example

@example
@group
/* @r{Phép trừ.} */
x = 5 - 3;
y = 57.223 - 10.903;
quux_pointer = foo_pointer - bar_pointer;
@end group
@end example

@noindent
Bạn có thể cộng và trừ bộ nhớ con trỏ, nhưng không thể nhân
hay chia chúng.

@example
@group
/* @r{Phép nhân.} */
x = 5 * 3;
y = 47.4 * 1.001;
@end group
@end example

@example
@group
/* @r{Phép chia.} */
x = 5 / 3;
y = 940.0 / 20.2;
@end group
@end example

@noindent
Sự chia hai số nguyên dương được cắt cụt phần thập phân phía sau, vậy thì 5/3 bằng
1.  Tuy nhiên, nếu một trong hai toán hạng là số âm, hướng làm tròn
được thực hiện.  @ref{Phép chia số Nguyên có Dấu} để
có thông tin thêm về tràn số âm trong phép chia số nguyên có dấu.

@c We should state how GCC behaves if an operand is negative.


Bạn có thể sử dụng toán tử modulus @code{%} để mà lấy được phần dư của
phép chia hai toán hạng.  Bạn đặt các toán hạng hai bên của toán
tử, và thứ tự các bên của toán hạng không giao hoán:
@code{3 % 5} và @code{5 % 3} là không có cùng kết quả.
Các toán hạng phải là biểu thức của một kiểu nguyên.

@example
@group
/* @r{Phép chia lầy Modular.} */
x = 5 % 3;
y = 74 % 47;
@end group
@end example

@noindent
Phép chia Modular trả về phân dư của việc chia hai toán hạng
số nguyên. Các toán hạng phải là kiểu dữ liệu
nguyên.

@example
@group
/* @r{Phép đảo.} */
int x = -5;
float y = -3.14159;
@end group
@end example

Nếu toán hạng bạn sử dụng với toán tử đảo (âm) với một kiểu dữ liệu
không dấu, thế thì kết quả sẽ không thể âm được, nhưng đúng hơn là
bít có giá trị lớn nhất của kiểu dữ liệu không dấu, chứa dấu trừ của toán hạng.

Nhiều hệ thống sử dụng hệ thống số bù hai, và trên những hệ thống như vậy
tất cả các giá trị âm của kiểu không dấu có thể lưu giữ ở xa số không hơn là
các giá trị dương.   Ví dụ, trên một hệ thống, chương
trình này:

@example
@group
#include <limits.h>
#include <stdio.h>

int main (int argc, char *argv[]) 
@{
  int x;
  x = INT_MAX;
  printf("INT_MAX  = %d\n", x);
  x = INT_MIN;
  printf("INT_MIN  = %d\n", x);
  x = -x;
  printf("-INT_MIN = %d\n", x);
  return 0;
@}
@end group
@end example

Sản phẩm đầu ra là:

@example
@group
INT_MAX  = 2147483647
INT_MIN  = -2147483648
-INT_MIN = -2147483648
@end group
@end example

Điều này không quan trọng, bạn còn có thể áp dụng toán tử dương (cộng)
cho một biểu thức số học:

@example
int x = +42;
@end example

@noindent
Numeric values are assumed to be positive unless explicitly made
negative, so this operator has no effect on program operation.

@node Toán tử Kết hợp cho Số phức
@section Toán tử Kết hợp cho Số phức
@cindex toán tử kết hợp cho số phức
@cindex kết hợp
 
Đây là phần mở rộng của GNU, bạn có thể sử dụng toán tử kết hợp cho số phức @code{~} để
mà thực hiện các phép toán trên toán hạng --- thật vậy, nó đảo ngược dấu
của phần ảo của nó.   Toán hạng phải là một biểu thức thuộc kiểu dữ liệu
số phức.  Đây là một ví dụ:
 
@example
@group
__complex__ int x = 5 + 17i;
 
printf ("%d  \n", (x * ~x));
@end group
@end example
 
Từ đó phần ảo của số phức @math{(a + bi)} được nhân bằng sự tiếp hợp thì bằng
@math{a^2 + b^2}, câu lệnh @code{printf} phía trên sẽ in ra 314, mà nó lại
bằng với @math{25 + 289}.

@node Toán tử So sánh
@section Toán tử So sánh
@cindex toán tử so sánh
@cindex toán tử, so sánh

Bạn sử dụng toán tử so sánh để mà phân định rõ sự tương quan giữa hai toán
hạng: có phải chúng như nhau, cái này lớn hơn cái kia,
cái này nhỏ hơn cái kia, và cứ thế.   Khi bạn sử dụng bất kỳ toán tử
so sánh nào, kết quả chỉ là 1 hoặc 0, nghĩa là đúng (true) hay sai (false),
một cách tương ứng.

(Trong ví dụ sau đây, biến @code{x} và @code{y} có thể
là hai biểu thức của kiểu số học hay con trỏ.)

Toán tử băng-với @code{==} kiểu tra hai toán hạng của nó về tính ngang bằng.
Kết quả là 1 nếu hai toán hạng bằng nhau và 0 nếu chúng không bằng.

@example
@group
if (x == y)
  puts (``x bằng với y'');
else
  puts (``x không bằng với y'');
@end group
@end example

Toán tử không-bằng @code{!=} kiểm tra sự khác nhau của hai toán hạng.
Kết quả trả về là một nếu hai toán hạng không bằng nhau và không nếu các toán hạng
@emph{là} như nhau.

@example
@group
if (x != y)
  puts (``x không bằng với y'');
else
  puts (``x bằng với y'');
@end group
@end example

Việc so sánh hai giá trị số chấm động theo cách thông thường
có thể tạo ra các kết quả không như mong muốn.  @ref{Kiểu Số Thực} để có
thêm thông tin.

Bạn có thể so sánh con trỏ hàm; quá trình so sánh
cho biết con trỏ có trả về cùng một hàm
hay không.

Ngoài việc so sánh bằng hay không như ở trên, có một số toán tử mà bạn có thể
sử dụng để mà kiểm tra một giá trị có nhỏ hơn, lớn hơn, nhỏ-hơn-hoặc-bằng, hay
lớn-hơn-hoặc-bằng một giá trị khác.  Đây là một số ví dụ mẫu mà nó
đưa ra các ví dụ minh họa về các toán tử này:

@example
@group
if (x < y)
  puts (``x nhỏ hơn y'');
@end group
@end example

@example
@group
if (x <= y)
  puts (``x nhỏ hơn hoặc bằng y'');
@end group
@end example

@example
@group
if (x > y)
  puts (``x lớn hơn y'');
@end group
@end example

@example
@group
if (x >= y)
  puts (``x lớn hơn hoặc bằng y'');
@end group
@end example


@node Logical Toán tử
@section Logical Toán tử
@cindex logical toán tử

Logical toán tử test the truth value of a pair of operands.  Any
nonzero expression is considered true in C, while an expression that
evaluates to zero is considered false.

The logical conjunction operator @code{&&} tests if two expressions
are both true.  If the first expression is false, then the second
expression is not evaluated.

@example
@group
if ((x == 5) && (y == 10))
  printf (``x is 5 and y is 10'');
@end group
@end example

The logical conjunction operator @code{||} tests if at least one of
two expressions it true.  If the first expression is true, then the
second expression is not evaluated.

@example
@group
if ((x == 5) || (y == 10))
   printf (``x is 5 or y is 10'');
@end group
@end example

You can prepend a logical expression with a negation operator
@code{!} to flip the truth value:

@example
@group
if (!(x == 5))
  printf (``x is not 5'');
@end group
@end example

Since the second operand in a logical expression pair is not necessarily
evaluated, you can write code with perhaps unintuitive results:

@example
@group
if (foo && x++)
  bar();
@end group
@end example

@noindent
If @code{foo} is ever zero, then not only would @code{bar} not be called,
but @code{x} would not be incremented.  If you intend to increment @code{x}
regardless of the value of @code{foo}, you should do so outside of the
conjunction expression.


@node Bit Shifting
@section Bit Shifting
@cindex bit shifting
@cindex shifting

You use the left-shift operator @code{<<} to shift its first operand's bits
to the left.  The second operand denotes the number of bit places to shift.
Bits shifted off the left side of the value are discarded; new bits added
on the right side will all be 0.

@example
@group
x = 47;    /* @r{47 is 00101111 in binary.} */
x << 1;    /* @r{00101111 << 1 is 01011110.} */
@end group
@end example

Similarly, you use the right-shift operator @code{>>} to shift its
first operand's bits to the right. Bits shifted off the right side are
discarded; new bits added on the left side are @emph{usually} 0, but
if the first operand is a signed negative value, then the added bits will
be either 0 @emph{or} whatever value was previously in the leftmost bit
position.

@example
@group
x = 47;   /* @r{47 is 00101111 in binary.} */
x >> 1;   /* @r{00101111 >> 1 is 00010111.} */
@end group
@end example

For both @code{<<} and @code{>>}, if the second operand is greater
than the bit-width of the first operand, or the second operand is
negative, the behavior is undefined.

You can use the shift toán tử to perform a variety of interesting
hacks.  For example, given a date with the day of the month numbered
as @code{d}, the month numbered as @code{m}, and the year @code{y}, you
can store the entire date in a single number @code{x}:

@example
int d = 12;
int m = 6;
int y = 1983;
int x = ((y << 4) + m) << 5) +  d;
@end example

@noindent
You can then extract the original day, month, and year out of @code{x}
using a combination of shift toán tử and modular division:

@example
d = x % 32;
m = (x >> 5) % 16;
y = x >> 9;
@end example

@node Bitwise Logical Toán tử
@section Bitwise Logical Toán tử
@cindex bitwise logical toán tử
@cindex logical toán tử, bitwise

C provides toán tử for performing bitwise conjunction, inclusive disjunction,
exclusive disjunction, and negation (complement).

Biwise conjunction examines each bit in its two operands, and when two
corresponding bits are both 1, the resulting bit is 1.  All other resulting
bits are 0.  Here is an example of how this works, using binary numbers:

@example
11001001 & 10011011 = 10001001
@end example

Bitwise inclusive disjunction examines each bit in its two operands,
and when two corresponding bits are both 0, the resulting bit is 0.  All
other resulting bits are 1.

@example
11001001 | 10011011 = 11011011
@end example

Bitwise exclusive disjunction examines each bit in its two operands, and when
two corresponding bits are different, the resulting bit is 1.  All other resulting
bits are 0.

@example
11001001 ^ 10011011 = 01010000
@end example

Bitwise negation reverses each bit in its operand:

@example
~11001001 = 00110110
@end example

In C, you can only use these toán tử with operands of an integer (or character)
type, and for maximum portability, you should only use the bitwise negation operator
with unsigned integer types.  Here are some examples of using these toán tử in
C code:

@example
@group
unsigned int foo = 42;
unsigned int bar = 57;
unsigned int quux;

quux = foo & bar;
quux = foo | bar;
quux = foo ^ bar;
quux = ~foo;
@end group
@end example

@node Pointer Toán tử
@section Pointer Toán tử
@cindex pointer toán tử

You can use the address operator @code{&} to obtain the memory address of
an object.

@example
@group
int x = 5;
int *pointer_to_x = &x;
@end group
@end example

It is not necessary to use this operator to obtain the address of
a function, although you can:

@example
@group
extern int foo (void);
int (*fp1) (void) = foo; /* fp1 points to foo */
int (*fp2) (void) = &foo; /* fp1 also points to foo */
@end group
@end example

Function pointers and data pointers are not compatible, in the sense
that you cannot expect to store the address of a function into a data
pointer, and then copy that into a function pointer and call it
successfully.  It might work on some systems, but it's not a portable
technique.

As a GNU extension to C89, you can also obtain the address of a label
with the label address operator @code{&&}.  The result is a
@code{void*} pointer which can be used with @code{goto}.  @xref{The
goto Statement}.

Given a memory address stored in a pointer, you can use the indirection
operator @code{*} to obtain the value stored at the address. (This is called
@dfn{dereferencing} the pointer.)

@example
@group
int x = 5;
int y;
int *ptr;

ptr = &x;    /* @r{@code{ptr} now holds the address of @code{x}.} */

y = *ptr;    /* @r{@code{y} gets the value stored at the address}
                @r{stored in @code{ptr}.} */
@end group
@end example

@noindent
Avoid using dereferencing pointers that have not been initialized to
a known memory location.


@node The sizeof Operator
@section The sizeof Operator
@cindex sizeof operator

You can use the @code{sizeof} operator to obtain the size (in bytes)
of the data type of its operand.  The operand may be an actual type
specifier (such as @code{int} or @code{float}), as well as any valid
expression.  When the operand is a type name, it must be enclosed in
parentheses.  Here are some examples:

@example
@group
size_t a = sizeof(int);
size_t b = sizeof(float);
size_t c = sizeof(5);
size_t d = sizeof(5.143);
size_t e = sizeof a;
@end group
@end example

The result of the @code{sizeof} operator is of a type called @code{size_t},
which is defined in the header file @code{<stddef.h>}.  @code{size_t} is
an unsigned integer type, perhaps identical to @code{unsigned int} or
@code{unsigned long int}; it varies from system to system.

The @code{size_t} type is often a convenient type for a loop index,
since it is guaranteed to be able to hold the number of elements in
any array; this is not the case with @code{int}, for example.

The @code{sizeof} operator can be used to automatically compute the
number of elements in an array:

@example
@group
#include <stddef.h>
#include <stdio.h>

static const int values[] = @{ 1, 2, 48, 681 @};
#define ARRAYSIZE(x) (sizeof x/sizeof x[0])

int main (int argc, char *argv[]) 
@{
    size_t i;
    for (i = 0; i < ARRAYSIZE(values); i++) 
    @{
        printf("%d\n", values[i]);
    @}
    return 0;
@}
@end group
@end example

There are two cases where this technique does not work.  The first is
where the array element has zero size (GCC supports zero-sized
structures as a GNU extension).  The second is where the array is in
fact a function parameter (@pxref{Function Parameters}).

@node Type Casts
@section Type Casts
@cindex type casts
@cindex casts

You can use a type cast to explicitly cause an expression to be of a specified
data type.  A type cast consists of a type specifier enclosed in parentheses,
followed by an expression.  To ensure proper casting, you should also enclose
the expression that follows the type specifier in parentheses.  Here is
an example:

@example
@group
float x;
int y = 7;
int z = 3;
x = (float) (y / z);
@end group
@end example

In that example, since @code{y} and @code{z} are both integers, integer
division is performed, and even though @code{x} is a floating-point
variable, it receives the value 2.  Explicitly casting the result
of the division to @code{float} does no good, because the computed
value of @code{y/z} is already 2.

To fix this problem, you need to convert one of the operands to a
floating-point type before the division takes place:

@example
@group
float x;
int y = 7;
int z = 3;
x = (y / (float)z);
@end group
@end example

@noindent Here, a floating-point value close to 2.333@dots{} is assigned to @code{x}.

Type casting only works with scalar types (that is, integer,
floating-point or pointer types).  Therefore, this is not allowed:

@example
@group
struct fooTag @{ /* members ... */ @};
struct fooTag foo;
unsigned char byteArray[8];

foo = (struct fooType) byteArray; /* @r{Fail!} */
@end group
@end example

@node Array Subscripts
@section Array Subscripts
@cindex array subscripts

You can access array elements by specifying the name of the array, and the
array subscript (or index, or element number) enclosed in brackets.  Here is
an example, supposing an integer array called @code{my_array}:

@example
@group
my_array[0] = 5;
@end group
@end example

The array subscript expression @code{A[i]} is defined as being
identical to the expression @code{(*((A)+(i)))}.  This means that many
uses of an array name are equivalent to a pointer expression.  It also
means that you cannot subscript an array having the @code{register}
storage class.

@node Function Calls as Biểu thức
@section Function Calls as Biểu thức
@cindex function calls, as expressions

A call to any function which returns a value is an expression.

@example
@group
int function(void);
@dots{}
a = 10 + function();
@end group
@end example


@node The Comma Operator
@section The Comma Operator
@cindex comma operator

You use the comma operator @code{,} to separate two (ostensibly related) expressions.
For instance, the first expression might produce a value that is used by the second
expression:
@c This works because there is a sequence point after the evaluation
@c of the left hand side.
@example
@group
x++, y = x * x;
@end group
@end example

More commonly, the comma operator is used in @code{for} statements, like
this:

@example
@group
/* @r{Using the comma operator in a @code{for} statement.} */

for (x = 1, y = 10;  x <=10 && y >=1;  x++, y--)
  @{
    @dots{}
  @}
@end group
@end example

@noindent
This lets you conveniently set, monitor, and modify multiple control
expressions for the @code{for} statement.

A comma is also used to separate function parameters; however, this
is @emph{not} the comma operator in action.   In fact, if the comma
operator is used as we have discussed here in a function call, then
the compiler will
interpret that as calling the function with an extra parameter.

If you want to use the comma operator in a function argument, you need
to put parentheses around it.  That's because commas in a function
argument list have a different meaning: they separate arguments.
Thus,

@example
foo (x,  y=47,  x,  z);
@end example

@noindent
is interpreted as a function call with four arguments, but

@example
foo (x,  (y=47,  x),  z);
@end example

@noindent
is a function call with just three arguments.  (The second argument is
@code{(y=47, x)}.)

@node Member Access Biểu thức
@section Member Access Biểu thức
@cindex member access expressions

You can use the member access operator @code{.} to access the members
of a structure or union variable.  You put the name of the structure
variable on the left side of the operator, and the name of the
member on the right side.

@example
@group
struct point
@{
  int x, y;
@};

struct point first_point;

first_point.x = 0;
first_point.y = 5;
@end group
@end example

@cindex indirect member access operator
You can also access the members of a structure or union variable via
a pointer by using the indirect member access operator @code{->}.
@code{x->y} is equivalent to @code{(*x).y}.

@example
@group
struct fish
  @{
    int length, weight;
  @};

struct fish salmon;

struct fish *fish_pointer = &salmon;

fish_pointer->length = 3;
fish_pointer->weight = 9;
@end group
@end example 

@xref{Pointers}.


@node Conditional Biểu thức
@section Conditional Biểu thức
@cindex conditional expressions
@cindex expressions, conditional
@cindex ternary operator

You use the conditional operator to cause the entire conditional
expression to evaluate to either its second or its third operand, based
on the truth value of its first operand.  Here's an example:

@example
a ? b : c
@end example

If expression @code{a} is true, then expression @code{b} is evaluated
and the result is the value of @code{b}.  Otherwise, expression
@code{c} is evaluated and the result is @code{c}.  

Biểu thức @code{b} and @code{c} must be compatible.   That is, they
must both be 

@enumerate
@item arithmetic types
@item compatible @code{struct} or @code{union} types
@item pointers to compatible types (one of which might be the NULL pointer)
@end enumerate 

Alternatively, one operand is a pointer and the other is a
@code{void*} pointer.

Here is an example

@example
a = (x == 5) ? y : z;
@end example

Here, if @code{x} equals 5, then @code{a} will receive
the value of @code{y}.  Otherwise, @code{a} will receive the value of
@code{z}.  This can be considered a shorthand method for writing a simple
@code{if}@dots{}@code{else} statement.  The following example will
accomplish the same task as the previous one:

@example
@group
if (x == 5)
    a = y;
else
    a = z;
@end group
@end example

If the first operand of the conditional operator is true, then the third
operand is never evaluated.  Similarly, if the first operand is false,
then the second operand is never evaluated.  The first operand is always
evaluated.


@c GNU C Extension

@node Statements and Declarations in Biểu thức
@section Statements and Declarations in Biểu thức
@cindex statements inside expressions
@cindex declarations inside expressions
@cindex expressions containing statements
@cindex macros, statements in expressions

As a GNU C extension, you can build an expression using compound
statement enclosed in parentheses.  This allows you to included
loops, switches, and local variables within an expression.

Recall that a compound statement (also known as a block) is a sequence of
statements surrounded by braces.  In this construct, parentheses go around
the braces.  Here is an example:

@example
@group
(@{ int y = function (); int z;
    if (y > 0) z = y;
   else z = - y;
   z; @})
@end group
@end example

That is a valid (though slightly more complex than necessary) expression
for the absolute value of @code{function ()}.

The last thing in the compound statement should be an expression
followed by a semicolon; the value of this subexpression serves as the
value of the entire construct.  (If you use some other kind of statement
last within the braces, the construct has type @code{void}, and thus
effectively no value.)

This feature is especially useful in making macro definitions ``safe'' (so
that they evaluate each operand exactly once).  For example, the
``maximum'' function is commonly defined as a macro in standard C as
follows:

@example
#define max(a,b) ((a) > (b) ? (a) : (b))
@end example

@noindent
@cindex side effects, macro argument
But this definition computes either @code{a} or @code{b} twice, with bad
results if the operand has side effects.  In GNU C, if you know the
type of the operands (here let's assume @code{int}), you can define
the macro safely as follows:

@example
#define maxint(a,b) \
  (@{int _a = (a), _b = (b); _a > _b ? _a : _b; @})
@end example

If you don't know the type of the operand, you can still do this, but you
must use @code{typeof} expressions or type naming.

@comment Add reference to typeof

Embedded statements are not allowed in constant expressions, such as
the value of an enumeration constant, the width of a bit field, or
the initial value of a static variable.


@node Operator Precedence
@section Operator Precedence in C
@cindex operator precedence
@cindex precedence, operator

When an expression contains multiple toán tử, such as @code{a + b *
f()}, the toán tử are grouped based on rules of @dfn{precedence}.
For instance, the meaning of that expression is to call the function
@code{f} with no arguments, multiply the result by @code{b}, then add
that result to @code{a}.  That's what the C rules of operator
precedence determine for this expression.

The following is a list of types of expressions, presented in order of
highest precedence first.  Sometimes two or more toán tử have equal
precedence; all those toán tử are applied from left to right
unless stated otherwise.

@enumerate

@item
Function calls, array subscripting, and membership access operator
expressions.

@item
Unary toán tử, including logical negation, bitwise complement,
increment, decrement, unary positive, unary negative, indirection
operator, address operator, type casting, and @code{sizeof}
expressions.  When several unary toán tử are consecutive,
the later ones are nested within the earlier ones: @code{!-x}
means @code{!(-x)}.

@item
Multiplication, division, and modular division expressions.

@item
Addition and subtraction expressions.

@item
Bitwise shifting expressions.

@item
Greater-than, less-than, greater-than-or-equal-to, and less-than-or-equal-to@*
expressions.

@item
Equal-to and not-equal-to expressions.

@item
Bitwise AND expressions.

@item
Bitwise exclusive OR expressions.

@item
Bitwise inclusive OR expressions.

@item
Logical AND expressions.

@item
Logical OR expressions.

@item
Conditional expressions (using @code{?:}).  When used as
subexpressions, these are evaluated right to left.

@item
All assignment expressions, including compound assignment.  When multiple
assignment statements appear as subexpressions in a single larger expression,
they are evaluated right to left.

@item
Comma operator expressions.

@end enumerate

@c ??? Lots more examples are needed here!

@c ??? You need to explain when parentheses are strongly
@c recommended in order to make the structure clear.

The above list is somewhat dry and is apparently straightforward, but
it does hide some pitfalls.  Take this example:

@example
foo = *p++;
@end example

Here @code{p} is incremented as a side effect of the expression, but
@code{foo} takes the value of @code{*(p++)} rather than @code{(*p)++},
since the unary operators bind right to left.   There are other
examples of potential surprises lurking behind the C precedence
table.  For this reason if there is the slightest risk of the reader
misunderstanding the meaning of the program, you should use
parentheses to make your meaning clear.

@node Order of Evaluation
@section Order of Evaluation

In C you cannot assume that multiple subexpressions are evaluated in
the order that seems natural.  For instance, consider the expression
@code{++a * f()}.  Does this increment @code{a} before or after
calling the function @code{f}?  The compiler could do it in either
order, so you cannot make assumptions.

This manual explains the semantics of the C language in the abstract.
However, an actual compiler translates source code into specific
actions in an actual computer, and may re-order operations for the
sake of efficiency.  The correspondence between the program you write
and the things the computer actually does are specified in terms of
@emph{side effects} and @emph{sequence points}.

@menu
* Side Effects::
* Sequence Points::
* Sequence Points Constrain Biểu thức::
* Sequence Points and Signal Delivery::
@end menu

@node Side Effects
@subsection Side Effects

@cindex side effect
A @dfn{side effect} is one of the following:
@enumerate
@item accessing a @code{volatile} object
@item modifying an object
@item modifying a file
@item a call to a function which performs any of the above side effects
@end enumerate

These are essentially the externally-visible effects of running a
program.   They are called side effects because they are effects of
expression evalation beyond the expression's actual resulting value.

The compiler is allowed to perform the operations of your program in
an order different to the order implied by the source of your program, 
provided that in the end all the necessary side effects actually take
place. The compiler is also allowed to entirely omit some operations;
for example it's allowed to skip evaluating part of an expression if
it can be certain that the value is not used and evaluating that part
of the expression won't produce any needed side effects.

@node Sequence Points
@subsection Sequence Points

Another requirement on the compiler is that side effects should take
place in the correct order.  In order to provide this without
over-constraining the compiler, the C89 and C90 standards specfy a
list of sequence points.  A @dfn{sequence point} is one of the
following:

@cindex sequence point
@enumerate
@c authority: C99 standard, annex C
@item a call to a function (after argument evaluation is complete)
@item the end of the left-hand operand of the and operator @code{&&}
@item the end of the left-hand operand of the or operator @code{||}
@item the end of the left-hand operand of the comma operator @code{,}
@item the end of the first operand of the ternary operator @code{a ? b : c}
@item the end of a full declarator
@footnote{a full declarator is a declaration of a function or an object which is not part of another object}
@item the end of an initialisation expression 
@item the end of an expression statement (i.e. an expression followed by @code{;})
@item the end of the controlling expression of an @code{if} or @code{switch} statement
@item the end of the controlling expression of a @code{while} or @code{do}statement
@item the end of any of the three controlling expressions of a @code{for} statement
@item the end of the expression in a return statement
@item immediately before the return of a library function
@item after the actions associated with an item of formatted I/O (as
used for example with the @code{strftime} or the @code{printf} and
@code{scanf} famlies of functions).
@item immediately before and after a call to a comparison function (as
called for example by @code{qsort})
@end enumerate

@c authority: C99 standard, section 5.1.2.3
At a sequence point, all the side effects of previous expression
evaluations must be complete, and no side effects of later evaluations
may have taken place.

@c authority: C89 standard, section 5.1.2.3
@c this description was not included in C99, I assume because of the 
@c introduction of whole-program optimisation
This may seem a little hard to grasp, but there is another way to
consider this.  Imagine you wrote a library (some of whose functions
are external and perhaps others not) and compiled it, allowing someone
else to call one of your functions from their code.  The definitions
above ensure that, at the time they call your function, the data they
pass in has values which are consistent with the behaviour specified
by the abstract machine, and any data returned by your function has a
state which is also consistent with the abstract machine.  This
includes data accessible via pointers (i.e. not just function
parameters and identifiers with external linkage).

The above is a slight simplification, since compilers exist that
perform whole-program optimisation at link time.  Importantly however,
although they might perform optimisations, the visible side effects of
the program must be the same as if they were produced by the abstract
machine.

@node Sequence Points Constrain Biểu thức
@subsection Sequence Points Constrain Biểu thức

@c authority: C89 section 6.3, C99 section 6.5
The code fragment 
@example
i = i + 1;
@end example 
is quite normal and no doubt occurs in many programs.  However, the
quite similar code fragment
@example
i = ++i + 1;
@end example 
is a little harder to understand; what is the final value of @code{i}?
The C standards (both C89 and C99) both forbid this construct in 
conforming programs.  

Between two sequence points, 
@enumerate
@item an object may have its stored value modified at most once by the
evaluation of an expression
@item the prior value of the object shall be read only to determine
the value to be stored.
@end enumerate

The first of these two conditions forbids expressions like 
@code{foo(x=2, ++x)}.  The second condition forbids expressions like
@code{a[i++] = i}.

@c with an appropriate list of counterexamples such as f(x++, x++).

@table @code
@item int x=0; foo(++x, ++x)
Not allowed in a conforming program; modifies @code{x} twice before
argument evaluation is complete. 
@item int x=0; bar((++x,++x))
Allowed; the function @code{bar} takes one argument (the value 2
is passed here), and there is a sequence point at the comma operator.
@item *p++ || *p++
Allowed; there is a sequence point at @code{||}.
@item int x = 1, y = x++;
Allowed; there is a sequence point after the full declarator of @code{x}.
@item x=2; x++;
Allowed; there is a sequence point at the end of the first expression
statement.
@item if (x++ > MAX) x = 0;
Allowed; there is a sequence point at the end of the controlling
expression of the @code{if}@footnote{However if for example @code{MAX} is
@code{INT_MAX} and @code{x} is of type @code{int}, we clearly have a
problem with overflow.  @xref{Overflow}.}.
@item (x=y) ? ++x : x--;
Allowed; there is a sequence point before the @code{?}, and only one
of the two following expressions is evaluated.
@item int *p=malloc(sizeof(*p)), *q=p;  *p=foo(); bar((*p)++,(*q)++);
Not allowed; the object at @code{p} is being modified twice
before the evaluation of the arguments to @code{bar} is complete.  The
fact that this is done once via @code{p} and once via @code{q} is
irrelevant, since they both point to the same object.
@end table

Let's go back to the example we used to introduce the problem of the
order of evaluation, @code{++a * f()}.   Suppose the code actually
looks like this:

@example
@group
static int a = 1;

static int f (void)
@{
  a = 100;
  return 3;
@}

int foo (void)
@{
   return ++a * f();
@}
@end group
@end example

Is this code allowed in a standard-conforming program?  Although the
expression in @code{foo} modifies @code{a} twice, this is not a
problem.  Let's look at the two possible cases.

@table @asis
@item The right operand @code{f()} is evaluated first
Since @code{f} returns a value other than void, it must contain a
@code{return} statement.   Therefore, there is a sequence point at the
end of the return expression.  That comes between the modification to
@code{a} that @code{f} makes and the evaluation of the left operand.
@item The left operand @code{++a} is evaluated first
First, @code{a} is incremented.   Then the arguments to @code{f} are
evaluated (there are zero of them).  Then there is a sequence point
before @code{f} is actually called.
@end table

@c C99 does not state explicitly that there is a sequence point after
@c argument evaluation if a function call contains zero arguments.
So, we see that our program is standard-conforming.  Notice that the
above argument does not actually depend on the details of the body of
the function @code{f}.  It only depends on the function containing
something ending in a sequence point -- in our example this is a
return statement, but an expression statement or a full declarator
would do just as well.

@cindex unspecified behaviour
However, the result of executing this code depends on the order of
evaluation of the operands of @code{*}.  If the left-hand operand is
evaluated first, @code{foo} returns 6.  Otherwise, it returns 303.
The C standard does not specify in which order the operands should be
evaluated, and also does not require an implementation either to
document the order or even to stick to one order.  The effect of this
code is @dfn{unspecified}, meaning that one of several specific
things will happen, but the C standards do not say which.



@node Sequence Points and Signal Delivery
@subsection Sequence Points and Signal Delivery

Singals are mainly documented in the GNU C Library manual rather than
this document, even though the C standards consider the compiler and
the C library together to be ``the implementation''.

@c [This scene-setting is probably too long. - jay@gnu.org]
@c
@c Your C program can be notified of asynchronous events by the
@c @dfn{signal} mechanism.  There are a few dozen different possible
@c signals; these include for example @code{SIGINT}, which tells your
@c program that the user pressed the keyboard interrupt key, and
@c @code{SIGFPE} which tells your program that an arithmetic overflow has
@c occurred.  Signals can be asyncronous, for example @code{SIGINT}
@c generally arises outside your program, or normally synchronous like
@c @code{SIGFPE} or @code{SIGABRT} (which indicates your program called
@c the @code{abort} function, directly or indirectly).  Signals can also
@c be sent using the @code{kill} and @code{raise} functions.
@c 
@c All signals have a default effect, usually to terminate the program.
@c However, you can set up a @dfn{signal handler} -- a funciton to be
@c called when a specified signal is delivered.


When a signal is received, this will happen between sequence points.
Side effects on @code{volatile} objects prior to the previous sequence
point will have occurred, but other updates may not have occurred
yet.  This even applies to straight assignments, such as @code{x=0;},
because the code generated for that statement may require more than
one instruction, meaning that it can be interrupted part-way through
by the delivery of a signal.

The C standard is quite restrictive about what data access can occur
within a signal handler.  They can of course use @code{auto}
variables, but in terms of reading or writing other objects, they must
be @code{volatile sig_atomic_t}.  The @code{volatile} type qualifier
ensures that access to the variable in the other parts of the program
doesn't span sequence points and the use of the @code{sig_atomic_t}
type ensures that changes to the variable are atomic with respect to
signal delivery.

The POSIX standard also allows a small number of library functions to
be called from a signal handler.  These functions are referred to as
the set of @dfn{async-signal-safe} functions.  If your program is
intended to run on a POSIX system but not on other systems, you can
safely call these from your signal handler too.

@node Overflow
@section Overflow

@include overflow.texi

