
@c This is part of The GNU C Reference Manual
@c Copyright (C) 2003, 2004, 2006-2009 Free Software Foundation, Inc.
@c See the file gnu-c-manual.texi for copying conditions.

@node Câu lệnh
@chapter Câu lệnh
@cindex câu lệnh

Bạn viết câu lệnh để mà thực thi hành động hay điều khiển việc rẽ nhánh trong một chương trình
của mình.  Bạn cũng còn có thể viết câu lệnh chẳng làm gì cả,
hay làm những thứ rất bình thường.

@menu
* Nhãn::
* Expression Câu lệnh::       
* Câu lệnh if::     
* Câu lệnh switch::  
* Câu lệnh while::  
* Câu lệnh do::     
* Câu lệnh for::    
* Khối lệnh::                      
* Câu lệnh Rỗng::          
* Câu lệnh goto::   
* Câu lệnh break::  
* Câu lệnh continue::  
* Câu lệnh return::  
* Câu lệnh typedef::
@end menu

@node Nhãn
@section Nhãn
@cindex nhãn
@cindex nhãn câu lệnh
@cindex câu lệnh, nhãn

Bạn có thể sử dụng nhãn để đại diện vùng mà mã nguồn sử dụng sau này
với @code{goto} (@pxref{Câu lệnh goto}).  Một nhãn bao gồm một
định danh (giống như sử dụng cho tên biến) theo sau là một
dấu hai chấm.  Đây là một ví dụ:

@example
@group
treet:
@end group
@end example

Bạn nên hiểu rằng tên của nhãn không được xung đột với các
định danh khác:

@example
@group
int treet = 5;    /* @r{biến @code{treet}.} */
treet:            /* @r{nhãn @code{treet}.} */
@end group
@end example

Theo tiêu chuẩn ISO C yêu cầu rằng theo sau nhãn phải có ít nhất một
câu lệnh, một câu lệnh rỗng cũng được (@pxref{Câu lệnh Rỗng}).
GCC sẽ dịch mã nguồn mà không yêu cầu điều này, nhưng cần phải hiểu rằng
nếu bạn lạm dụng nó, mã chương trình của bạn sẽ không tương thích với các
trình dịch khác.


@node Biểu thức Câu lệnh
@section Biểu thức Câu lệnh
@cindex biểu thức câu lệnh
@cindex câu lệnh, biểu thức

Bạn kết tạo bất kỳ một biểu thức nào thành một câu lệnh bằng cách thêm dấu chấm phẩy
vào cuối của biểu thức.  Đây là một ví dụ:

@example
@group
5;
2 + 2;
10 >= 9;
@end group
@end example

Từng cái trong số đó, việc tất cả đều xảy ra là mỗi biểu thức được định
giá trị.  Tuy nhiên, chúng chẳng để làm gì cả bởi vì chúng không lưu trữ
giá trị ở đâu cả, cũng không làm được gì thực tế, chẳng qua chỉ là
sự tự định giá trị.  Trình dịch sẽ tự loại bỏ những câu lệnh
như thế này.

Biểu thức câu lệnh chỉ hữu dụng khi chúng tạo ra được một
số tác dụng, như là lưu giá trị, gọi hàm, hay
(đây là bí mật) là nguyên nhân hỏng hóc trong một chương trình.  Sau đây là
một số ví dụ hữu dụng:

@example
@group
x++;
y = x + 25;
puts ("Hello, user!");
*cucumber;
@end group
@end example

Câu lệnh cuối cùng trong số chúng, @code{*cucumber;}, có khả năng
là nguyên nhân đổ vỡ của một chương trình nếu như giá trị của @code{cucumber} không là
một con trỏ hợp lệ và được khai báo là @code{volatile}.

@comment reference to `volatile'


@node Câu lệnh if
@section Câu lệnh @code{if}
@cindex câu lệnh @code{if}
@cindex câu lệnh @code{else}

Bạn có thể sử dụng câu lệnh @code{if} để thực thi một cách có điều kiện một phần của
chương trình của mình, trên cơ sở giá trị đúng được đưa ra bởi biểu thức.  Đây là
dạng thức chung của câu lệnh @code{if}:

@example
@group
if (@var{test})
  @var{then-statement}
else
  @var{else-statement}
@end group
@end example

Nếu @var{test} được ước lượng là đúng, thế thì @var{then-statement} được thực thi và
@var{else-statement} không thực hiện.  Nếu @var{test} được ước tính là sai, thế thì
@var{else-statement} được thực hiện và @var{then-statement} thì không.  Mệnh đề
@code{else} là tùy chọn.

Đây là một ví dụ thực tế:

@example
@group
if (x == 10)
  puts ("x is 10");
@end group
@end example

Nếu @code{x == 10} được ước lượng là đúng, thế thì câu lệnh
@code{puts ("x is 10");} được thực thi.  Nếu @code{x == 10} được ước lượng là
sai, thế thì câu lệnh @code{puts ("x is 10");} không được thực hiện.

Đây là một ví dụ sử dụng @code{else}:

@example
@group
if (x == 10)
  puts ("x is 10");
else
  puts ("x is not 10");
@end group
@end example

Bạn có thể sử dụng các câu lệnh @code{if} nối tiếp nhau để kiểm tra
nhiều điều kiện:

@example
@group
if (x == 1)
  puts ("x is 1");
else if (x == 2)
  puts ("x is 2");
else if (x == 3)
  puts ("x is 3");
else
  puts ("x is something else");
@end group
@end example

Hàm sau sẽ tính toán và hiện thị ngày tháng Phục Sinh cho năm @code{y} được đưa ra:

@example
void
easterDate (int y)
@{
  int n = 0;
  int g = (y % 19) + 1;
  int c = (y / 100) + 1;
  int x = ((3 * c) / 4) - 12;
  int z = (((8 * c) + 5) / 25) - 5;
  int d = ((5 * y) / 4) - x - 10;
  int e = ((11 * g) + 20 + z - x) % 30;

  if (((e == 25) && (g > 11)) || (e == 24))
    e++;

  n = 44 - e;

  if (n < 21)
    n += 30;

  n = n + 7 - ((d + n) % 7);

  if (n > 31)
    printf ("Easter: %d April %d", n - 31, y);
  else
    printf ("Easter: %d March %d", n, y);
@}
@end example

@node Câu lệnh switch
@section Câu lệnh @code{switch}
@cindex câu lệnh @code{switch}

Bạn có thể sử dụng câu lệnh @code{switch} để so sánh một biểu thức này với những cái khác,
và thực hiện một chuỗi các câu lệnh con trên cơ sở kết quả trả về từ việc
so sánh.  Sau đây là dạng thức chung của câu lệnh @code{switch}:

@example
@group
switch (@var{test})
  @{
    case @var{compare-1}:
      @var{if-equal-statement-1}
    case @var{compare-2}:
      @var{if-equal-statement-2}
    @dots{}
    default:
      @var{default-statement}
  @}
@end group
@end example

Câu lệnh @code{switch} so sánh @var{test} với từng biểu thức
@var{compare}, cho đến khi nó tìm thấy một cái mà nó
bằng với @var{test}.  Sau đó, các câu lệnh theo sau bởi case thành công
đó sẽ được thi hành.  Tất cả các biểu thức để so sánh phải là thuộc kiểu dữ liệu
số nguyên, và biểu thức @var{compare-N} phải là kiểu hằng
số nguyên (ví dụ, một số nguyên hay một biểu thức xây dựng nên số nguyên).

Đây là tùy chọn, bạn có thể chỉ định một case mặc định.  Nếu như @var{test} không khớp
với bất kỳ cases được liệt kê nào trước case mặc định, thế thì
câu lệnh dành cho case mặc định sẽ được thực thi.  Theo kiểu cổ điển,
case mặc định được đặt sau các cases khác, nhưng đây không phải là điều bắt buộc.


@example
@group
switch (x)
  @{
    case 0:
      puts ("x is 0");
      break;
    case 1:
      puts ("x is 1");
      break;
    default:
      puts ("x is something else");
      break;
  @}
@end group
@end example

Chú ý đến cách dùng của câu lệnh @code{break} trong mỗi case.  Đó là
bởi vì, một khi việc khớp với case được tìm thấy, không chỉ những lệnh của nó
được thi hành, mà toàn bộ các câu lệnh theo sau nó nữa:

@example
@group
int x = 0;
switch (x)
  @{
    case 0:
      puts ("x is 0");
    case 1:
      puts ("x is 1");
    default:
      puts ("x is something else");
  @}
@end group
@end example

@noindent
Kết quả sẽ là:

@example
@group
x is 0
x is 1
x is something else
@end group
@end example

Đây không phải là thứ mọi người mong muốn.  Việc gộp thêm câu lệnh @code{break} tại cuối
mỗi case sẽ làm chuyển hướng chương trình ra sau câu lệnh @code{switch}.

Phần mở rộng GNU C cho phép bạn cũng có thể chỉ định một vùng các số nguyên liên tiếp
nhau cho giá trị của một nhãn @code{case}, như thế này:

@example
case @var{low} ... @var{high}:
@end example

@noindent
Cách này có hiệu ứng giống với việc từng nhãn @code{case}
riêng lẻ được gán cho một trong mỗi giá trị nguyên từ @var{low} đến @var{high}, tất cả.

Đặc tính này cực kỳ hữu dụng cho một vùng mã ASCII:

@example
case 'A' ... 'Z':
@end example

Hãy cẩn thận với việc có các khoảng trắng xung quanh @code{...}; hay nó cách khác nó
có thể phân tích không đúng khi bạn sử dụng nó với các số nguyên.
Ví dụ như, nếu viết thế này:

@example
case 1 ... 5:
@end example

@noindent
Thay vì viết:

@example
case 1...5:
@end example

Việc sử dụng câu lệnh @code{switch} như trên thông thường để xử lý các giá trị
khác nhau của @code{errno}.  Trong trường hợp này một chương trình
ngoài có thể theo dõi tình trạng mà hai macros cho giá trị @code{errno}
trên thực tế có giá trị là cùng một, ví dụ như @code{EWOULDBLOCK} và
@code{EAGAIN}.


@node The while Statement
@section The @code{while} Statement
@cindex @code{while} statement

The @code{while} statement is a loop statement with an exit test at
the beginning of the loop.  Here is the general form of the @code{while}
statement:

@example
@group
while (@var{test})
  @var{statement}
@end group
@end example

The @code{while} statement first evaluates @var{test}.  If @var{test}
evaluates to true, @var{statement} is executed, and then @var{test} is
evaluated again.  @var{statement} continues to execute repeatedly as long as
@var{test} is true after each execution of @var{statement}.  

This example prints the integers from zero through nine:

@example
@group
int counter = 0;
while (counter < 10)
  printf ("%d ", counter++);
@end group
@end example

A @code{break} statement can also cause a @code{while} loop to exit.

@node The do Statement
@section The @code{do} Statement
@cindex @code{do} statement

The @code{do} statement is a loop statement with an exit test at the end
of the loop.  Here is the general form of the @code{do} statement:

@example
@group
do
  @var{statement}
while (@var{test});
@end group
@end example

The @code{do} statement first executes @var{statement}.  After that,
it evaluates @var{test}.  If @var{test} is true, then @var{statement} is
executed again.  @var{statement} continues to execute repeatedly as long as
@var{test} is true after each execution of @var{statement}.

This example also prints the integers from zero through nine:

@example
@group
int x = 0;
do
  printf ("%d ", x++);
while (x < 10);
@end group
@end example

A @code{break} statement can also cause a @code{do} loop to exit.

@node The for Statement
@section The @code{for} Statement
@cindex @code{for} statement

The @code{for} statement is a loop statement whose structure allows
easy variable initialization, expression testing, and variable
modification.  It is very convenient for making counter-controlled
loops.  Here is the general form of the @code{for} statement:

@example
for (@var{initialize}; @var{test}; @var{step})
  @var{statement}
@end example

The @code{for} statement first evaluates the expression @var{initialize}.
Then it evaluates the expression @var{test}.  If @var{test} is false, then
the loop ends and program control resumes after @var{statement}.  Otherwise,
if @var{test} is true, then @var{statement} is executed.  Finally,
@var{step} is evaluated, and the next iteration of the loop begins with
evaluating @var{test} again.

Most often, @var{initialize} assigns values to one or more variables,
which are generally used as counters,  @var{test} compares those
variables to a predefined expression, and @var{step} modifies those
variables' values.  Here is another example that prints the integers
from zero through nine:

@example
@group
int x;
for (x = 0; x < 10; x++)
  printf ("%d ", x);
@end group
@end example

First, it evaluates @var{initialize}, which assigns @code{x} the value
0.  Then, as long as @code{x} is less than 10, the value of @code{x}
is printed (in the body of the loop).  Then @code{x} is incremented in
the @var{step} clause and the test re-evaluated.

All three of the expressions in a @code{for} statement are optional, and any
combination of the three is valid.  Since the first expression is evaluated
only once, it is perhaps the most commonly omitted expression.  You could
also write the above example as:

@example
@group
int x = 1;
for (; x <= 10; x++)
  printf ("%d ", x);
@end group
@end example

@noindent
In this example, @code{x} receives its value prior to the beginning of the
@code{for} statement.

If you leave out the @var{test} expression, then the @code{for} statement
is an infinite loop (unless you put a @code{break} or @code{goto} statement
somewhere in @var{statement}).  This is like using @code{1} as
@var{test}; it is never false.

This @code{for} statement starts printing numbers at 1 and then
continues indefinitely, always printing @code{x} incremented by 1:

@example
@group
for (x = 1; ; x++)
  printf ("%d ", x);
@end group
@end example

If you leave out the @var{step} expression, then no progress is made
toward completing the loop---at least not as is normally expected with
a @code{for} statement.

This example prints the number 1 over and over, indefinitely:

@example
@group
for (x = 1; x <= 10;)
  printf ("%d ", x);
@end group
@end example

Perhaps confusingly, you cannot use the comma operator (@pxref{The
Comma Operator}) for monitoring and modifying multiple variables in a
@code{for} statement, because as usual the comma operator discards the
result of its left operand.  This loop:

@example
@group
int x, y;
for (x = 1, y = 10; x <= 10, y >= 1; x+=2, y--)
  printf ("%d %d\n", x, y);
@end group
@end example

@noindent Outputs:

@example
1 10
3 9
5 8
7 7
9 6
11 5
13 4
15 3
17 2
19 1
@end example

If you need to test two conditions, you will need to use the @code{&&}
operator:

@example
@group
int x, y;
for (x = 1, y = 10; x <= 10 && y >= 1; x+=2, y--)
  printf ("%d %d\n", x, y);
@end group
@end example

A @code{break} statement can also cause a @code{for} loop to exit.

Đây là một ví dụ of a function that computes the summation of squares, given a 
starting integer to square and an ending integer to square:

@example
@group
int
sum_of_squares (int start, int end)
@{
  int i, sum = 0;
  for (i = start; i <= end; i++)
    sum += i * i;
  return sum;
@}
@end group
@end example

@node Blocks
@section Blocks
@cindex blocks
@cindex compound statements

A @dfn{block} is a set of zero or more statements enclosed in braces.
Blocks are also known as @dfn{compound statements}.  Often, a block is
used as the body of an @code{if} statement or a loop statement, to
group statements together.

@example
@group
for (x = 1; x <= 10; x++)
  @{
    printf ("x is %d\n", x);
    
    if ((x % 2) == 0)
      printf ("%d is even\n", x);
    else
      printf ("%d is odd\n", x);
  @}
@end group
@end example

You can also put blocks inside other blocks:

@example
@group
for (x = 1; x <= 10; x++)
  @{
    if ((x % 2) == 0)
      @{
        printf ("x is %d\n", x);
        printf ("%d is even\n", x);
      @}
    else
      @{
        printf ("x is %d\n", x);
        printf ("%d is odd\n", x);
      @}
  @}
@end group
@end example  

You can declare variables inside a block; such variables are local to
that block.  In C89, declarations must occur before other statements,
and so sometimes it is useful to introduce a block simply for this
purpose:

@comment scope reference  (locality)

@example
@group
@{
  int x = 5;
  printf ("%d\n", x);
@}
printf ("%d\n", x);   /* @r{Compilation error! @code{x} exists only}
                       @r{in the preceding block.} */
@end group
@end example


@node The Null Statement
@section The Null Statement
@cindex null statement
@cindex statement, null

The @dfn{null statement} is merely a semicolon alone.

@example
@group
;
@end group
@end example

A null statement does not do anything.  It does not store a value anywhere.
It does not cause time to pass during the execution of your program.

Most often, a null statement is used as the body of
a loop statement, or as one or more of the expressions in a @code{for}
statement.  Đây là một ví dụ of a @code{for} statement that uses the
null statement as the body of the loop (and also calculates the integer
square root of @code{n}, just for fun):

@example
@group
for (i = 1; i*i < n; i++)
  ;
@end group
@end example

Here is another example that uses the null statement as the body
of a @code{for} loop and also produces output:

@example
@group
for (x = 1; x <= 5; printf ("x is now %d\n", x), x++)
  ;
@end group
@end example

A null statement is also sometimes used to follow a label that would
otherwise be the last thing in a block.


@node The goto Statement
@section The @code{goto} Statement
@cindex @code{goto} statement

You can use the @code{goto} statement to unconditionally jump to a different
place in the program.  Here is the general form of a @code{goto} statement:

@example
goto @var{label};
@end example

You have to specify a label to jump to; when the @code{goto} statement
is executed, program control jumps to that label.  @xref{Labels}.  Here
is an example:

@example
@group
goto end_of_program;
@dots{}
end_of_program:
@end group
@end example

The label can be anywhere in the same function as the @code{goto}
statement that jumps to it, but a @code{goto} statement cannot jump to a
label in a different function.

You @emph{can} use @code{goto} statements to simulate loop statements,
but we do not recommend it---it makes the program harder to read, and GCC
cannot optimize it as well.  You should use @code{for},
@code{while}, and @code{do} statements instead of @code{goto} statements,
when possible.

As an extension, GCC allows a goto statement to jump to an address
specified by a @code{void*} variable.  To make this work, you also
need to take the address of a label by using the unary operator
@code{&&} (not @code{&}).  Here is a contrived example:

@example
@group
enum Play @{ ROCK=0, PAPER=1, SCISSORS=2 @};
enum Result @{ WIN, LOSE, DRAW @};

static enum Result turn (void) 
@{
  const void * const jumptable[] = @{&&rock, &&paper, &&scissors@};
  enum Play opp;                /* @r{opponent's play} */
  goto *jumptable[select_option (&opp)];
 rock:
  return opp == ROCK ? DRAW : (opp == PAPER ? LOSE : WIN);
 paper:
  return opp == ROCK ? WIN  : (opp == PAPER ? DRAW : LOSE);
 scissors:
  return opp == ROCK ? LOSE : (opp == PAPER ? WIN  : DRAW);
@}
@end group
@end example

@c Here we should mention that programs should not jump over an
@c initializer with a goto (and elsewhere say the same for a case
@c label).  However, just now I can't find the section of the C89
@c standard that stipulates this.


@node The break Statement
@section The @code{break} Statement
@cindex @code{break} statement

You can use the @code{break} statement to terminate a @code{while}, @code{do},
@code{for}, or @code{switch} statement.  Đây là một ví dụ:

@example
@group
int x;
for (x = 1; x <= 10; x++)
  @{
    if (x == 8)
      break;
    else
      printf ("%d ", x);
  @}
@end group
@end example

That example prints numbers from 1 to 7.  When @code{x} is incremented
to 8, @code{x == 8} is true, so the @code{break} statement is executed, 
terminating the @code{for} loop prematurely.

If you put a @code{break} statement inside of a loop or @code{switch}
statement which itself is inside of a loop or @code{switch} statement, the
@code{break} only terminates the innermost loop or @code{switch} statement.


@node The continue Statement
@section The @code{continue} Statement
@cindex @code{continue} statement

You can use the @code{continue} statement in loops to terminate an
iteration of the loop and begin the next iteration.  Here is an
example:

@example
@group
for (x = 0; x < 100; x++)
  @{
    if (x % 2 == 0)
      continue;
    else
      sum_of_odd_numbers + = x;
  @}
@end group
@end example

If you put a @code{continue} statement inside a loop which itself is
inside a loop, then it affects only the innermost loop.



@node The return Statement
@section The @code{return} Statement
@cindex @code{return} statement

You can use the @code{return} statement to end the execution of a function
and return program control to the function that called it.  Here is the
general form of the @code{return} statement:

@example
return @var{return-value};
@end example

@var{return-value} is an optional expression to return.  If the
function's return type is @code{void}, then it is invalid to return
an expression.  You can, however, use the @code{return} statement
without a return value.

If the function's return type is not the same as the type of
@var{return-value}, and automatic type conversion cannot be performed,
then returning @var{return-value} is invalid.

@comment Reference to type conversion

If the function's return type is not @code{void} and no return value
is specified, then the @code{return} statement is valid unless the
function is called in a context that requires a return value.  For
example:

@example
x = cosine (y);
@end example

In that case, the function @code{cosine} was called in a context that
required a return value, so the value could be assigned to @code{x}.

Even in contexts where a return value is not required, it is a bad idea
for a non-@code{void} function to omit the return value.  With GCC, you
can use the command line option @code{@w{-Wreturn}-type} to issue a warning
if you omit the return value in such functions.

Here are some examples of using the @code{return} statement, in both
a @code{void} and non-@code{void} function:

@example
@group
void
print_plus_five (int x)
@{
  printf ("%d ", x + 5);
  return;
@}
@end group
@end example

@example
@group
int
square_value (int x)
@{
  return x * x;
@}
@end group
@end example


@node The typedef Statement
@section The @code{typedef} Statement
@cindex @code{typedef} statement

You can use the @code{typedef} statement to create new names for data
types.  Here is the general form of the @code{typedef} statement:

@example
typedef @var{old-type-name} @var{new-type-name}
@end example

@var{old-type-name} is the existing name for the type, and may consist
of more than one token (e.g., @code{unsigned long int}).
@var{new-type-name} is the resulting new name for the type, and must
be a single identifier.  Creating this new name for the type does
not cause the old name to cease to exist.  Here are some examples:

@example
@group
typedef unsigned char byte_type;
typedef double real_number_type;
@end group
@end example

@noindent
In the case of custom data types, you can use @code{typedef} to make a
new name for the type while defining the type:

@example
@group
typedef struct fish
@{
  float weight;
  float length;
  float probability_of_being_caught;
@} fish_type;
@end group
@end example

@noindent
To make a type definition of an array, you first provide the type of the element, and
then establish the number of elements at the end of the type definition:

@example
@group
typedef char array_of_bytes [5];
array_of_bytes five_bytes = @{0, 1, 2, 3, 4@};
@end group
@end example

When selecting names for types, you should avoid ending your type names with
a @code{_t} suffix.  The compiler will allow you to do this, but the
POSIX standard reserves use of the @code{_t} suffix for standard library
type names.
